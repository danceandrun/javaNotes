###### 想写一个用来高效复习集合框架知识的总纲，主要方面是将学习时前后关联的问题串起来，一些琐碎的注意事项统筹起来比如迭代器使用时的常错点，最后希望能把算法题目巩固一下，预计耗时4天(第一天大框架目录，第二天塞细节代码，第三、四天常错点常用点总结，算法回顾)

# 集合框架

JCF：`Java Collection Framework`

`ArrayList`底层是数组，`LinkedList`底层是链表 。

数据的插入流程是什么，删除流程是什么。`HashMap`底层源码是什么样的，扩容机制是什么样的。

# `Collection`

学习目标：

- 了解`Collection`接口的作用
- 掌握`Collection`的增、删、查方法
- 掌握`Collection`的遍历方法
- 掌握`Collection`遍历方法的特点及迭代器方法需要小心的bug
- <span style=color:yellow;background:red>**熟练掌握什么场景下使用Collection及其子类**</span>

> 单列数据时使用`Collection`

![集合类](.\assets\集合类.jpg)



![集合家族](.\assets\集合家族.png)

## 特点

1. 体系结构中的位置：`Collection`是顶级接口，**描述数据存储**的接口.
2. `Collection`的一些子实现有序，一些无序(指的是**存取顺序**)
3. 一些子实现允许存储重复的数据，一些不允许
4. 一些子实现允许存储`null`，一些不允许

> 不能直接`new Collection() `，这样只会得到一个匿名内部类
>
> ```Java
> Collection<Integer> collection = new ArrayList<>();
> ```

> 对于一个数据存储来说，有哪些方法是必要的？
>
> 增删改查。

传统的三件套:

-  数据存储是否**读写有序**
- 是否可以存重复的数据
- 是否可以存储`null`

> - 什么叫有序，什么叫无序？
>
> 集合类中指的是存储和读取的顺序，比如存入进去的是 `1 2 3 4 9`。读取出来的是`1 2 3 4 9`。或者 `9 4 3 2 1 `均称为有序。
>
> 其中有序的：`ArrayList` , `LinkedList`
>
> 无序的：`HashSet`
>
> - 什么可以存储重复，哪些不允许重复？
>
> 允许重复：`ArrayList`
>
> 不允许重复：`HashSet`
>
> - 哪些允许存储 `null`？
>
> 允许存储`null`: `ArrayList`，`HashSet`
>
> 不允许存储`null`: `TreeSet`

## `API`

> `Collection`作为顶级容器没有提供修改方法，因为有些子类容器不允许修改

**增**

```Java
//添加一个元素进入Collection
	boolean add(E e): 
//添加一个Collection进目标Collection；谁调用方法就向谁里面添加
	boolean addAll(Collection<? extends E> c): 
```

**删**

​	如果存在多个只会删除第一个

​	如果删除一个不存在的元素，不会报错，会返回`false`；成功返回`true`

```Java
// 删除元素， 只删除第一个出现的(如果存在多个)
	boolean remove(Object o)：
//删除Collection中的所有存在的元素,会全部删除；相当于差集。
	boolean removeAll(Collection<?> c)： 
```

**查**

```Java
//判断是否存在指定元素
	boolean contains(Object o)： 
//判断给定的collection中是否全部存在于目标Collection；也就是判断是否为子集
	boolean containsAll(Collection<?> c)： 
//在原有collection中只保留传入的collection。也就是取交集
	boolean retainAll(Collection<?> c)： 
```

**特殊方法**

> 注意：`Collection<String>` 清空操作返回的不是`null`而是空字符。

```java
//清空collection
	void clear();
// 判断是否相等
	boolean equals(Object o);
// 计算hashCode
	int hashCode();
// 是否为空
	boolean isEmpty():
// collection里面的元素个数
	int size();
```

**方便遍历方法**

```Java
// 将collection转成一个数组，方便遍历
	Object[] toArray();
// 类似，只是传入了一个数组
	<T> T[] toArray(T[] a);
// 返回一个迭代器
	Iterator<E> iterator();
```

> 遍历：对一个集合中的元素，按照一定的顺序，访问且仅访问一遍。对集合的元素，挨个访问

### `toArray()`方法

<font color=red>**无参方法**</font>

就是直接拷贝一份数据，创建一个新的数组。

![image-20230223192132808](.\assets\image-20230223192132808.png)

```java
// 底层是数组的实现
class ArrayList{
    //elementData: 存储数据的数组 
    Object[] elementData;

    // 数组列表的大小（它包含的元素数）
    int size;
}

```

<font color=red>**有参方法**</font>

![image-20230830224402331](.\assets\image-20230830224402331.png)

使用有参时只需要传一个类型就可以，长度可以是0。

```java
// ArrayList底层是数组
class ArrayList{
    // elementData就是底层用来存储数据的数组
    Object[] elementData;
    
    // size ： ArrayList底层实际存储的数据的长度。
    // 比如最开始 初始化 长度10；  elementData = new Object[10];
    // size = 0;    size=1; 
    int size;
    
    
    // 是ArrayList的toArray实现
    //  a = new String[3]
    // ArrayList里面，实际存了3个元素
    public <T> T[] toArray(T[] a) {
        // a.length(3)   <   size(3)
        if (a.length < size)
          // 如果你传入的数组长度，小于集合的长度。  这时候，会直接 复制底层存储的数据，只使用类型。
            return (T[]) Arrays.copyOf(elementData, size, a.getClass());
        
        // 只要走到这一行。说明  a.length >= size 。 传进来的数组长度，大于等于  元素个数
        // arraycopy 就是把一个数组 copy。 
        // 把elementData的所有数据 拷贝到  a(传进来的数组)
        System.arraycopy(elementData, 0, a, 0, size);
        
        // 传入的数组长度，大于size(实际存储的数据长度)
        if (a.length > size)
            // 直接把elementData后面的位置，赋了null。
            a[size] = null;
        return a;
    }
}
```

```JAVA
// a是传入的数组，用于接收这个
public <T> T[] toArray(T[] a) {
    if (a.length < size)
        // 当传入的数组长度 小于 原有集合的长度时候。使用一个类型，不使用这个数组
        // Make a new array of a's runtime type, but my contents:
        return (T[]) Arrays.copyOf(elementData, size, a.getClass());
    // 走到这一行，说明传入的数组 大于或者等于 原有集合的长度。
    // 直接将 elementData(原有数组) 拷贝到a(传入的数组) 
    System.arraycopy(elementData, 0, a, 0, size);

    // 如果数组长度大于集合长度。直接把a[size] = null。 直接把最后一个元素的后面置为null。
    if (a.length > size)
        a[size] = null;
    return a;
}
```

```Java
// 这是系统提供的一个数组拷贝方法。  --》 把一个数组复制到另外一个数组
// src 源数组
// srcPos 从什么地址开始复制（starting position in the source array.）
// dest 目标数组
// destPos 粘贴到的下标位置
// length 复制的长度（the number of array elements to be copied.）
public static native void arraycopy(Object src, int  srcPos, Object dest, int destPos, int length);
```

 🏷️`toArray()`的<font color=red>**有参构造方法**</font>

传入的数组长度与集合长度的对比。

1. 如果数组长度<font color=red>**小于**</font>集合长度。只会使用传入的数组的类型，不会使用这个数组
2. 如果数组长度<font color=red>**等于**</font>集合长度，会直接使用这个数组
3. 如果数组长度<font color=red>**大于**</font>集合长度，也会使用这个数组，并且将数组的`index=length` 位置的元素设置为`null`

 🏷️<span style=color:red;background:yellow>**直接使用`toArray`这个有什么弊端？**</span>

`toArray`是将原`Collection`直接copy了一份。

- 耗费时间，需要将原有collection全部拷贝一遍
- 耗费空间，两倍的collection占有空间
- 后续使用完毕，还需要`GC`

我们一般遍历一个集合，有时候是想统计个数，有时候是想找出符合条件的，如果每次都复制一次，不仅耗费时间，而且使用完后，还需要`GC`。

在处理大量数据时，使用`toArray`方法需要谨慎考虑，因为它会将集合中的所有元素都复制到新的数组中，占用大量的内存空间。如果数据量非常大，**可能会导致内存溢出**。

在处理大量数据时，建议使用迭代器进行遍历，而不是将集合转换为数组。迭代器可以**逐个访问**集合中的元素，并且不需要将所有元素都复制到新的数组中，从而减少内存的占用。

### `iterator`方法

**迭代器**（`iterator`），有时又称**光标**（`cursor`）是程序设计的**软件设计模式**，可在容器对象（`container`，例如链表或数组）上遍历的接口，设计人员无需关心**容器对象的内存分配的实现细节**。

<span style=color:red;background:yellow>**是用来遍历这个容器对象所有数据的接口。**</span>

迭代器相当于只保留了一个标识，标识我可以怎么拿到这个数据，不copy数据。所有操作的数据都是针对的原有的`Collection`。

对于一个集合（底层实现：数组）来说，我想遍历这个集合，只需要下标；对于底层实现是链表来说，只需要指针。

> 好处是什么？
>
> `Iterator`是个接口，接口只定义规范，我们获取到了`iterator`，就可以使用这个对象对数据进行遍历。把接口与实现隔离。

比如`Collection`底层有的是数组，有的是链表。数组的`Iterator`里面维护的是下标，链表的`Iterato`r里面维护的是指针。

所有的具体实现都交给具体的子类。接口只定义一个规范。

![image-20230830225141880](.\assets\image-20230830225141880.png)

![image-20230830225154408](.\assets\image-20230830225154408.png)

**迭代器是个游标，它遍历的时候，如果有别的线程操作把原集合中加了几个元素，减了几个元素，那这时候这次遍历的意义大吗？**

`JDK`采用了存储一个值的方式，去保证在迭代器使用过程中，原有的集合不被修改（当前线程、其他线程）。

在`Collection` 内部，有一个`modCount`,用来<span style=color:green;background:white>**标识结构变化**</span>的次数(`get/contains` 这种查询不叫结构变化)

生成迭代器的时候，存储这个`expectedModCount=modCount`，在调用 `next `\ `remove`时候，会检查这个值。使用迭代器过程中，如果原结构发生了变化，会报**并发修改异常**<span style=color:yellow;background:red>**（ConcurrentModificationException）**</span>。

如果见到了，需要检查，是不是在迭代器使用过程中，修改了原有集合。

 🏷️**迭代器的使用**：

```JAVA
//  是否有下一个元素   
	boolean hasNext():
// 获取下一个元素    
	E next()： 
// 删除刚刚遍历过的元素    
	void remove()：
```

![image-20230830224948512](.\assets\image-20230830224948512.png)

> + `.next()`光标往后挪返回刚刚经过的元素。
>
> + `void remove()`----->  删除刚刚遍历过的元素。也就是只能遍历一下删除一下，不能连续删除。
>
> + `iterator`是否保存集合中的数据 ----> 不保存
>
> + 删除的是哪里的数据？ ---->  集合中的数据

```JAVA
//    boolean hasNext(): 是否有下一个元素
//    E next()： 获取下一个元素
//    void remove()： 删除刚刚遍历过的元素

    @Test
    public void iteratorDemo1() {
        Collection<String> collection = new ArrayList<>();
        collection.add("zs");
        collection.add("ls");
        collection.add("wu");

        // 现有collection里面有 三个元素。 [zs, ls, wu]
        System.out.println(collection);

        // 调用iterator()方法，生成一个迭代器。迭代器本身不存储数据。所以它操作的数据都是原有集合的
        Iterator<String> iterator = collection.iterator();

        // 现在的迭代器和数据 示意图：
        //  数据：   [     zs           ls           wu   ]
        //  迭代器位置： |

        // 迭代器后是否有元素。
        System.out.println(iterator.hasNext());

        // 将指针往后挪动，并返回刚刚经过的元素
        String next = iterator.next();
        System.out.println(next);
        
        // 现在的迭代器和数据 示意图：
        //  数据：   [     zs           ls           wu   ]
        //  迭代器位置： ------- |
    }

```

<font color=red>**怎么解决会出现并发修改异常问题？**</font>`ConcurrentModificationException`

不要在迭代器迭代过程中，去修改原集合。修改动作要不就是在迭代器生成之前，要不就在迭代器使用完成之后。

```JAVA
    Collection<String> collection = new ArrayList<>();

    collection.add("zs");
    collection.add("ls");
    collection.add("wu");

	// ========================= 这个位置之前叫做迭代器生成之前 =========================
    Iterator<String> iterator = collection.iterator();

    while (iterator.hasNext()) {
       // 不能边使用，边修改原有集合。
      // collection.remove("zs");

      String next = iterator.next();
      System.out.println(next);
    }

	// ========================= 这个位置之前叫做迭代器生成之后 =========================
```

## `foreach`

工作中一般使用`foreach`居多。底层也是`iterator`，所以需要注意，在`foreach`中，不要去改变`Collection`的结构。

```JAVA
Collection<String> collection = new ArrayList<>();

collection.add("zs");
collection.add("ls");
for (String s : collection) {
    System.out.println(s);
}
```

<font color=red>**案例1**</font>

```JAVA
// 1. 存储一组学生。包括 姓名 年龄，总分，入学日期
// 2. 找出总分最高的学生？
// 3. 找出总分最低的学生
// 4. 求平均分
// 5. 删除低于平均分的学生
// 6. 找出2年内入学的学生。
// 7. 需要删除叫张三的学生
// 8. 删除年龄小于18的学生
```

<font color=red>**案例2**</font>

```JAVA
// 存储一组订单数据。订单的信息包括，订单号，订单金额，订单时间，订单状态(未付款、已付款、已发货、已评价)，订单更新时间
// 1. 新建5条订单放入 
// 2. 找出下单时间最早的订单，并打印
// 3. 找出订单状态是已付款的
// 4. 找出订单金额超过200的，并且订单状态是已发货

// 思考一下，这些条件怎么传？
```

获取到一段描述后，需要掌握以下能力。将描述转化为代码的能力。

<span style=color:red;background:yellow>**总结**</span>

🟡 怎样去遍历`Collection`接口

```JAVA
// 使用 iterator  
Collection<String> collection = new ArrayList<>();

collection.add("zs");
collection.add("ls");
collection.add("wu");

// 使用的时候，先生成一个迭代器
Iterator<String> iterator = collection.iterator();

while (iterator.hasNext()) {
    String next = iterator.next();
    System.out.println(next);
}


// 使用foreach
for (String next : collection) {
    System.out.println(next);
}

// 三种 迭代器，foreach，toArray
```

 🟡如何删除`Collection`中所有的zs和ls数据？

```JAVA
// 遍历，删除
// 1.方式1  
// 创建一个新的集合；
// 遍历原有集合。
//		判断。是否 zs  ls ; 是的话，添加到新集合
// removeAll()
// 遍历新集合 --》  remove()

// 2.方式2
// 迭代器
// 创建一个迭代器。遍历这个迭代器(while hasNext() next() )
// 判断， 是不是zs  或者 ls 。 是的话，remove  iterator.remove()
// 切记，不能通过原有集合的remove()


// 使用一个集合类，把所有的zs 和ls 都存起来。然后遍历集合类，再调用原有集合类的remove方法

// 使用一个集合类，存储 zs  ls  调用removeAll方法

// 使用迭代器的删除方法

// Collection<String>  
// Collection<Student> 
```

遍历`Collection`接口的时候，有什么需要注意的事项

<span style=color:yellow;background:red>**注意并发修改异常。出现的原因，以及解决的办法。**</span>

# `List`接口

学习目标

- <span style=color:red;background:yellow>**重点掌握List接口的特点，及其使用场景**</span>
- 掌握List接口特殊的方法（带有下标的方法 add addAll remove get set ）
- 掌握List接口的特有遍历方式（get(index)）
- ArrayList的底层结构。初始化容量，扩容策略。（数组。10。*1.5）
- LinkedList的底层结构(双向链表)
- <span style=color:red;background:yellow>**（面试）Vector和ArrayList的区别？为什么被替换掉**</span>
- Stack是什么？在Java中想使用栈，应该怎么创建

使用的时候，一般的使用方式

```JAVA
// 一般这样用
List<String> list = new ArrayList<>();


// 不会这样用
Collection<String> collection = new ArrayList<>();
ArrayList<String> collection = new ArrayList<>();
```

## 特点(重点)

1. `List`是`Collection`的子接口。（父子继承关系，想对原有接口进行增强。）
2. 数据结构表现为线性表。
3. 存储数据有序。（存储进去的顺序和读取出来的顺序。 完全一致或者完全相反）
4. 可以存储重复元素
5. 可以存储`null`

<font color=red>**线性表**</font>

线性表，全名为线性存储结构。使用线性表存储数据的方式可以这样理解，即“把所有数据用一根线儿串起来，再存储到物理空间中”。

![image-20230830225713246](.\assets\image-20230830225713246.png)

就是一对一的数据结构。一个数据元素，除了第一个元素和最后一个元素，都只有一个前驱一个后继。

<span style=color:yellow;background:red>**一定要掌握。**</span>数组的插入数据，删除数据流程；链表的插入数据，删除数据流程。

## `List`的`API`

`List`是`Collection`的子接口，所以肯定有`Collection`的所有方法。

`Collection`的API我们已经学习过，所以直接学习`List`所特有的。

> 线性表。 和`Collection`里面的API，最大的区别，就是**增加了很多下标操作**。

```java
// 在指定位置添加元素。list添加的位置，只能在[0,length之间]  
	void add(int index, E element);
// 在指定位置添加一个Collection的所有元素    
	boolean addAll(int index, Collection<? extends E> c);
// 删除指定下标的元素，只能删除下标的位置[0, lenth-1]。返回的是删除的元素
// 注意remove方法还可以传参Obeject，所以如果index是Integer需要index.intValue() 🟡
	E remove(int index);
// 设置指定下标的元素为element
// （类似于数组的array[index] = element）
	E set(int index, E element);
// 获取指定下标元素
// (类似于arrary[index])
	E get(int index);
// 获取元素的首个index；如果该元素不存在则返回值是-1.   
	int indexOf(Object o);
// 获取元素的最后一个index；如果该元素不存在则返回值是-1. 
	int lastIndexOf(Object o);
// 截取  
	List<E> subList(int fromIndex, int toIndex);
```

```JAVA
ListIterator<E> listIterator();
ListIterator<E> listIterator();
ListIterator<E> listIterator(int index);
```

<span style=color:red;background:yellow>**需要注意的东西**</span>

- 画图，理清操作的是哪个位置。
  - add（1， “666”）
  - add(5,"888")
  - add(6，“777”)
  
  ![image-20230830230110856](.\assets\image-20230830230110856.png)

### `listIterator()`方法

返回一个`ListIterator`的对象。这个与迭代器类似，只是可以前后移动，可以返回index。

- 有参构造，返回的迭代器对象，调用next返回的是指定下标的元素。<font color=red>**所以传入的index应该在什么范围？**</font>

`[0,length]`

```java
ListIterator<String> listIterator = list.listIterator(index);
```

> 利用这一点可以实现倒序遍历，即先设置光标在`length`位置，然后`previous`向前遍历。
>
> 同样的，还可以使用`get`方法得到下标实现倒序遍历。

 🟡要注意指针的位置

```java
public interface ListIterator<E> extends Iterator<E>

// 判断后面是否还有元素可以遍历
	boolean hasNext；
// 向后遍历
	E next()
// 删除刚刚遍历的数据
	void remove()

// 向前是否可以遍历
	boolean hasPrevious()
// 向前遍历
  E previous()
  
// 向后遍历的数据的下标
  int nextIndex()
// 向前遍历的下标
  int previousIndex()
  
// 添加一个数据到当前遍历位置,并且把指针往后挪一下
// 注意指针会往后挪
  void add(E e)
//修改刚刚遍历过的元素位置
// 该方法和remove一样不能直接用要使用next或者previous遍历一个；但是可以连续set不同于remove的不可以连续.
  void set(E e)
```

### `subList`方法

返回列表中指定的 `fromIndex`（包括 ）和 `toIndex`（不包括）之间的部分**视图**。

<span style=color:red;background:yellow>**视图：**</span>只是原表的一个映射，并没有把数据复制一份。它和`iterator`很相似，只是维护了几个标记。操作`subList`产生的对象，会影响原来的对象。

相当于，只是一个看起来和原有数组一致，可以把它理解为镜子。

🟡 操作`subList`也会影响原本的集合

 📣在使用`subList`的过程中，千万不要认为`subList`里面有多少数据，底层就存储多少数据。

> 注意：它也会存在**并发修改**的问题。当生成了`subList`之后，如果再修改原集合。再访问`subList`的对象，会报错。

注意一些坑：

- 注意`oom`，因为`subList`只是一个视图，它保留了原始的数组。所以如果错误估计，可能会`oom`

  ![image-20230830230301772](.\assets\image-20230830230301772.png)

```JAVA
怎么出现oom，设置小堆内存。切记不要直接跑，可能会导致电脑死机
IDEA中，可以针对当前代码，设置最大的运行内存
Edit Configurations --> Add VM options -->
-Xmx500m -Xms500m
    
  -Xmx500m 最大堆内存 500m
  -Xms500m 初始堆内存 
```

- <span style=color:red;background:yellow>**注意并发修改异常**</span>

## `ArrayList`

`ArrayList`是Java集合框架中的一种，它实现了`List`接口，可以动态地添加、删除和修改元素。<span style=color:red;background:yellow>**与传统的数组不同，ArrayList的大小可以根据需要自动增长和缩小，因此非常适用于需要频繁添加或删除元素的场景。**</span>

<span style=color:yellow;background:red>**ArrayList内部实际上是一个动态数组，它可以存储任意类型的对象。**</span>当创建一个ArrayList时，它的初始容量是10个元素，当元素数量超过容量时，ArrayList会自动增加容量，以便能够容纳更多的元素。

`ArrayList`提供了一系列方法，可以方便地操作其中的元素，例如`add()`方法可以在末尾添加元素，`remove()`方法可以删除指定位置的元素，`get()`方法可以获取指定位置的元素，`set()`方法可以修改指定位置的元素等等。

![image-20230830230329854](.\assets\image-20230830230329854.png)

### 特点

1. `ArrayList`是`List`的实现。
2. `ArrayList`数据结构表现为线性表
3. <span style=color:red;background:yellow>**底层结构是数组**</span>
4. 存储元素，有序
5. 可以存储重复元素
6. 可以存储`null`

### 构造方法

```java
// 构造一个初始容量为 10 的空数组。
	ArrayList();
// 构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。
  ArrayList(Collection<? extends E> c);
// 构造一个具有指定初始容量的空列表。    
  ArrayList(int initialCapacity);

// List接口。 接口没有构造方法
```

### `ArrayList`的API

```java
// 返回此 ArrayList 实例的浅表副本。
	Object clone()
// 如有必要，增加此 ArrayList 实例的容量，以确保它至少能够容纳最小容量参数所指定的元素数。
	void ensureCapacity(int minCapacity)
// 将此 ArrayList 实例的容量调整为列表的当前大小。
	void trimToSize()
```

> 怎么写集合?
>
> 推荐一般情况用`List`引用指向`ArrayList`对象。
>
> 原因在于面向接口编程，这样如果以后发现数组效率不行，可以便于在不改变引用的情况下，改对象`new LinkedList<>()`。
>
> ```JAVA
> List<String> list = new ArrayList<>();
> ```

## `ArrayList`的源码

关心两点：

1. 在哪里进行初始化的
2. 怎么扩容的

### 初始化

```JAVA
class ArrayList{
  //底层存数据的数组
  Object[] elementData;
  //实际存储的数据大小
  int size;
  
      public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }
  
      public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }
  
  		//ensureCapacityInternal方法
      private void ensureCapacityInternal(int minCapacity) {
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    }
  
		// ensureExplicitCapacity方法
    private void ensureExplicitCapacity(int minCapacity) {
        modCount++;

        // overflow-conscious code
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
    }
  
  		//grow方法
      private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
  
}
```

### 扩容

```JAVA
class ArrayList{
    //底层存数据的数组
  Object[] elementData;
  //实际存储的数据大小
  int size;
  
        public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }
  
      public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }
  
}
```

## `LinkedList`

双向链表。

`Queue` 队列

`Deque` 双端队列

`LinkedList`是Java集合框架中的一种，它实现了`List`和`Deque`接口，是一个双向链表。与`ArrayList`不同的是，`LinkedList`在内部并不使用数组来存储元素，<span style=color:red;background:yellow>**而是使用一个链表来存储元素，因此可以高效地进行插入和删除操作。**</span>

<span style=color:red;background:yellow>**LinkedList的每个节点都包含了一个指向前一个节点和后一个节点的指针，因此可以方便地进行双向遍历。**</span>在向`LinkedList`中添加元素时，只需要创建一个新的节点，并将其插入到链表中即可。同样，在删除元素时，只需要将该元素的前后节点的指针重新指向即可，不需要像`ArrayList`一样将其后面的元素全部向前移动。

`LinkedList`提供了一系列方法，可以方便地操作其中的元素。例如`add()`方法可以在指定位置添加元素，`remove()`方法可以删除指定位置的元素，`get()`方法可以获取指定位置的元素，`set()`方法可以修改指定位置的元素等等。除此之外，`LinkedList`还提供了一些特殊的方法，例如`offer()`和`poll()`方法用于在链表的首尾添加和删除元素，`push()`和`pop()`方法用于在链表的首部添加和删除元素等等。

### 特点

1. `LinkedList`是`List`的子实现
2. `LinkedList`数据结构表现为线性表
3. `LinkedList`底层结构是双向链表
4. 存储元素有序
5. 可以存储`null`
6. 可以存储重复元素

### `LinkedList`的构造方法

```JAVA
//构造一个空列表。 
LinkedList();
  
//构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。
LinkedList(Collection<? extends E> c);
```

### `LinkedList`的`API`

队列：先进先出，从队尾进，队头出。

双端队列：队头和队尾都可以进出。

栈：先进后出。

```java
//        来自Collection
//        来自List的

//    ---------来自普通队列
// 将指定元素添加到此列表的末尾（最后一个元素）。
boolean offer (E e)

// 获取但不移除此列表的头（第一个元素）。
E peek () 
// 获取并移除此列表的头（第一个元素）
E poll () 
  
//    -------- 作为Stack的
// 从此列表所表示的堆栈处弹出一个元素。
  E pop(); 
// 将元素推入此列表所表示的堆栈。
  void push(E e);

//    -------- 作为双端队列
//    在此列表的开头插入指定的元素。
	boolean offerFirst (E e)
//    在此列表末尾插入指定的元素。
  boolean offerLast (E e)
//    获取但不移除此列表的第一个元素；如果此列表为空，则返回 null。
  E peekFirst () 
//    获取但不移除此列表的最后一个元素；如果此列表为空，则返回 null。
  E peekLast () 
//    获取并移除此列表的第一个元素；如果此列表为空，则返回 null。
  E pollFirst () 
//    获取并移除此列表的最后一个元素；如果此列表为空，则返回 null。
  E pollLast () 

//    -------以下的API了解即可
// 将指定元素插入此列表的开头。
    void addFirst (E e)
// 将指定元素添加到此列表的结尾。
    void addLast (E e)
// 移除并返回此列表的第一个元素。
    E removeFirst () 
// 移除并返回此列表的最后一个元素
    E removeLast () 
// 返回此列表的第一个元素。
    E getFirst () 
// 返回此列表的最后一个元素。
    E getLast () 
// 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。
    boolean removeFirstOccurrence (Object o) 
// 从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。
    boolean removeLastOccurrence (Object o)
// 返回以逆向顺序在此双端队列的元素上进行迭代的迭代器。
    Iterator<E> descendingIterator () 
// 获取但不移除此列表的头（第一个元素）。
    E element () 
```

<font color=red>**链表特点：**</font>插入和删除快。真的吗？

查找也需要时间，所以算起来和`ArrayList`类似。一般需要使用链表时直接使用`ArrayList`。除非在极个别情况下，才会用`LinkedList`。`List<V>() list = new ArraryList<>();`

## `Vector`

1. `Vector`是`List`的子实现
2. `Vector`的数据结构表现是线性表
3. 底层结构是数组
4. 存储的数据有序，可重复，可存储`null`
5. 线程安全

JDK1.0 的时候出现。底层是数组。

JDK1.2 出现了`ArrayList`。  用它取代`Vector`。

为什么不把它干掉？→  向前兼容。

`Vector`为啥被替代。 效率差，因为它所有的方法为了线程安全都有锁。

<span style=color:yellow;background:red>**在工作中，禁止使用Vector**</span>

**面试专用**

> 了不了解`Vector`？是否了解`ArrayList`和`Vector`的区别？    
>
> 答：不能只说了解，后面要继续讲`Vector`相关点；正确的去引导面试官。先答`Vector`的特点。顺手再说一下`ArrayList`。再答最明显的特征线程安全。
>
> Vector和ArrayList的区别？
>
> 
>
> **什么叫线程安全问题？**
>
> 指的是多线程环境下数据安全的问题。当多个线程同时对一个变量进行操作时，结果的预期与单线程下是一致的。这就是线程安全的。
>
> 比如多个线程对i进行操作，i初始值是0，有5个线程，每个线程累加10000次。最终结果应该是50000。 但真实情况不是这样的，这就是线程安全问题。
>
> ![image-20231031092551477](.\assets\image-20231031092551477.png)
>
> <span style=color:red;background:yellow>**为什么被弃用 **</span>
>
> <span style=color:red;background:yellow>**效率低，**</span>在所有的接口上都加了`synchronized`关键字。线程安全是没问题了，但是效率却有问题。因为绝大部分都不涉及到多线程情况，所以`jdk1.2`采用了`ArrayList`来替代`Vector`。

## `Stack`

1. `Stack`是`Vector`的子实现。继承自`Vector`也是线程安全但效率低。
2. 栈，是先进后出的数据容器。但是不建议使用这个来完成，效率是大问题。使用`Deque`来替代`Stack` --》 见jdk源码

<span style=color:red;background:yellow>在Java中，要用栈，能不能使用Stack？ 不要用。</span>

源码中写到：

```JAVA
/* * <p>A more complete and consistent set of LIFO stack operations is
 * provided by the {@link Deque} interface and its implementations, which
 * should be used in preference to this class.  For example:
 * <pre>   {@code
 *   Deque<Integer> stack = new ArrayDeque<Integer>();}</pre>
*/
```

# `Queue`

学习目标

- 掌握`Queue`的结构，以及`Queue`是什么
  - （操作受限的线性表）

- 了解`Queue`两组增删查API及区别
  - （`add` `remove`  element  |  `offer` `poll` `peek`  极端情况下表现不一致）

- 了解`Deque`的结构
  - （`offerFirst` `offerLast`  `addFirst` `addLast` .使用API成组使用）

- `ArrayDeque`的循环数组，是什么，以及为什么使用这种形式。
  - 底层是一个数组，使用两个`int`值来代表头和尾，避免从队列中获取数据的时候，频繁挪动数据。使用`int`值，就可以只操作`int`值，来模拟头和尾，提高了效率。

- 了解`ArrayDeque`的初始化容量及扩容策略。 如果传入一个非2的幂次方，它是怎么把它变成2的幂次方的
- 了解`BlockingQueue`是什么

<span style=color:red;background:yellow>**Queue：**</span>在Java中，队列（`Queue`）是一种数据结构，用于存储元素并支持在队列的末尾添加元素和从队列的头部移除元素。队列的工作方式类似于排队等待服务的过程。

Java中的队列通常是先进先出（FIFO）的数据结构，这意味着最先添加的元素将最先被移除。Java中的队列接口（`java.util.Queue`）定义了队列的基本操作，如添加元素、移除元素、获取队列头部元素等。

只能从队头出队列，从队尾进队列。

## 特点

1. `Queue`是`Collection`的子接口
2. 数据结构表现为：队列
3. 存储元素有序
4. 存储元素可重复
5. 不能存储`null`（除了`LinkedList`子实现）

## API

```java
// 将指定的元素插入此队列（如果立即可行且不会违反容量限制），在成功时返回 true，如果当前没有可用的空间，则抛出 IllegalStateException。
	boolean add(E e)；
//获取并移除此队列的头。NoSuchElementExecption
  E remove()；
//获取，但是不移除此队列的头。
  E element()；

// 将指定的元素插入此队列（如果立即可行且不会违反容量限制），当使用有容量限制的队列时，此方法通常要优于 add(E)，后者可能无法插入元素，而只是抛出一个异常。
    boolean offer(E e)
// 获取并移除此队列的头，如果此队列为空，则返回 null。
    E poll()
// 获取但不移除此队列的头；如果此队列为空，则返回 null。
    E peek()
```

极端情况下两组`API`的表现不一致

|          | *抛出异常*                                          | *返回特殊值*                                      |
| -------- | --------------------------------------------------- | ------------------------------------------------- |
| **插入** | [`add(e)`](../../java/util/Queue.html#add(E))       | [`offer(e)`](../../java/util/Queue.html#offer(E)) |
| **移除** | [`remove()`](../../java/util/Queue.html#remove())   | [`poll()`](../../java/util/Queue.html#poll())     |
| **检查** | [`element()`](../../java/util/Queue.html#element()) | [`peek()`](../../java/util/Queue.html#peek())     |

Queue不允许存储null的原因：<u>**使用null作为特殊标识**</u>，标识没有元素了，使用poll peek方法会返回null。

只有使用`LinkedBlockingQueue`才会出现队列满

## `Deque`

双端队列（`Deque`），是一种可以在队列的两端添加或删除元素的数据结构。

双端队列支持在队列的头部和尾部进行插入、删除和获取元素的操作，因此它可以同时用作栈和队列，是一种比较灵活的数据结构。在Java中，`Deque`接口提供了双端队列的实现，具有以下特点：

1. 可以在队列的头部或尾部添加或删除元素。
2. 可以获取队列头部或尾部的元素。
3. 可以用作栈或队列来进行数据操作。

<span style=color:red;background:yellow>**从队头可以进出，从队尾也可以进出。**</span>

### 特点

1. `Deque`是`Queue`的子接口
2. 数据结构表现：队列，栈，双端队列
3. 存储元素有序
4. 可存储重复元素
5. 不能存储`null`（`LinkedList`除外）

### API

注意API不要混用

```JAVA
// ------------- 作为Queue的
//获取队头元素，但不移除它
	E peek()
//从队头移除元素
  E poll()
//        boolean offer(E e)： 添加一个元素到队尾

// ------------- 作为Stack的
//        E pop()： 从此列表所表示的堆栈处弹出一个元素。
//        void push(E e): 将元素推入此列表所表示的堆栈。

// ------------- 作为双端队列
//        boolean offerFirst(E e)：  从第一个位置插入指定元素
//        boolean offerLast(E e)： 从最后一个位置插入指定元素
//        E peekFirst()： 获取但是不移除第一个元素，如果列表为空，返回null
//        E peekLast()： 获取但是不移除最后一个元素，如果列表为空，返回null
//        E pollFirst()： 从第一个位置移除元素
//        E pollLast()： 从最后一个位置移除元素，如果列表为空，返回null

// -------------- 作为普通List的
//将指定元素添加到此列表的结尾。
	boolean add(E e);
//获取并移除此列表的头（第一个元素）。
	E remove();

//将指定元素插入此列表的开头。
	void addFirst(E e);
//将指定元素添加到此列表的结尾。
	void addLast(E e);
//返回此列表的第一个元素。
	E getFirst();
//返回此列表的最后一个元素。
	E getLast()
//移除并返回此列表的第一个元素。
	E removeFirst()
//移除并返回此列表的最后一个元素。
	E removeLast()
     🟡注意下面两个方法不符合Deque定义
//从此列表中移除第一次出现的指定元素
	boolean removeFirstOccurrence(Object o)
//从列表中移除最后一次出现的指定元素
  boolean removeLastOccurrence(Object o)
    
//获取一个倒序的迭代器
  Iterator<E> descendingIterator();
//获取元素
	E element();
```

|          | **第一个元素（头部）**                                      | **第一个元素（头部）**                                      | **最后一个元素（尾部）**                                  | **最后一个元素（尾部）**                                  |
| -------- | ----------------------------------------------------------- | ----------------------------------------------------------- | --------------------------------------------------------- | --------------------------------------------------------- |
|          | *抛出异常*                                                  | *特殊值*                                                    | *抛出异常*                                                | *特殊值*                                                  |
| **插入** | [`addFirst(e)`](../../java/util/Deque.html#addFirst(E))     | [`offerFirst(e)`](../../java/util/Deque.html#offerFirst(E)) | [`addLast(e)`](../../java/util/Deque.html#addLast(E))     | [`offerLast(e)`](../../java/util/Deque.html#offerLast(E)) |
| **移除** | [`removeFirst()`](../../java/util/Deque.html#removeFirst()) | [`pollFirst()`](../../java/util/Deque.html#pollFirst())     | [`removeLast()`](../../java/util/Deque.html#removeLast()) | [`pollLast()`](../../java/util/Deque.html#pollLast())     |
| **获取** | [`getFirst()`](../../java/util/Deque.html#getFirst())       | [`peekFirst()`](../../java/util/Deque.html#peekFirst())     | [`getLast()`](../../java/util/Deque.html#getLast())       | [`peekLast()`](../../java/util/Deque.html#peekLast())     |

## `ArrayDeque`

循环数组（Cyclic Array），也称为环形数组，是一种数据结构，是数组的一种特殊形式。在循环数组中，数组的最后一个元素与第一个元素相邻，形成了一个环，因此可以通过数组下标进行循环遍历。

在循环数组中，每次增加数组下标时，需要考虑到下标越界的情况。一般来说，可以将下标对数组长度取模，实现在下标增加到数组最后一个元素时，返回到数组的第一个元素。同样地，当下标减小到数组的第一个元素时，可以通过将下标加上数组长度来返回到最后一个元素。

循环数组在实际应用中具有一定的优势，例如在*循环队列*、*循环缓冲区*等场景中，循环数组可以有效地实现元素的循环存储和遍历。同时，循环数组的空间利用率也相对较高，因为数组的最后一个元素可以直接连接到第一个元素，不需要额外的空间进行维护。

$tail = (tail + 1) \% length;$

二进制中，当length是2的整数幂时，计算等式有

$tail = (tail + 1) \% length = (tail + 1) \& (length -1);$

### 特点

1. `ArrayDeque`是`Deque`的子实现
2. 数据结构表现：队列，栈，双端队列
3. 底层实现： <font color=red>**循环数组**</font>。要理解一下循环数组的好处。
4. 存储元素有序
5. 存储元素可重复
6. 不可存储`null`

### 构造方法

```JAVA
//构造一个初始容量能够容纳 16 个元素的空数组双端队列。  扩容机制 *2 
ArrayDeque(); 

//构造一个包含指定 collection 的元素的双端队列，这些元素按 collection 的迭代器返回的顺序排列。    
ArrayDeque(Collection<? extends E> c); 

//构造一个初始容量能够容纳指定数量的元素的空数组双端队列。          
ArrayDeque(int numElements); 
```

>容量问题。如果传入的初始化容量小于8，则直接分配8个空间，如果传入的数字大于等于8，则直接找到(大于)数字的最近一个2的幂次方。
>24 --> 32
>32 --> 64
>为什么要分配2的幂次方？方便进行取模操作。

<font color=red>**注意**</font>：即使是整数幂，会找大于该整数幂的下一个整数幂。输入8会变为16，输入64会变为128.

```JAVA
初始容量：16  2的幂次方。扩容策略是2倍
int tail=(tail + 1) % length
    tail = （tail + 1） & (length - 1)
    
ArrayDeque里面有一个构造方法，允许你传入int大小的值，  但是我们通过推算得知，只有2的幂次方，才满足上述公式。
    所以JDK里面有把非2的幂次方，转成2的幂次方的方式。
```

> JAVA中的移位运算有三种：左移（`<<`）、右移（`>>`）和无符号右移（`>>>`）。
>
> 1. 左移（`<<`）：将操作数的所有位向左移动指定的位数，右边的空位用0填充。例如，对于表达式`a << b`，a的二进制表示向左移动b位。
> 2. 右移（`>>`）：将操作数的所有位向右移动指定的位数，并根据最左边的位（即符号位）进行填充。对于正数，用0填充；对于负数，用1填充。例如，对于表达式`a >> b`，a的二进制表示向右移动b位。
> 3. 无符号右移（`>>>`）：将操作数的所有位向右移动指定的位数，并用0填充空位，不考虑符号位。无符号右移运算符在操作无符号值时非常有用。例如，对于表达式`a >>> b`，a的二进制表示向右移动b位。

```JAVA
// 经过看源码得知，传入一个numElements(10)。最终是通过这个方法，得到一个int值，作为数组长度的。
// numElements = 10
// 1010
// 只要记得，它会把非2的幂次方的值，转成2的幂次方。
private static int calculateSize(int numElements) {
    // initialCapacity = 8
    // private static final int MIN_INITIAL_CAPACITY = 8;
    int initialCapacity = MIN_INITIAL_CAPACITY;
    // 如果你传入的初始容量，小于8，直接返回8
    // 如果传入的初始容量，大于等于8，进 代码块
    
    if (numElements >= initialCapacity) {
        initialCapacity = numElements;
        initialCapacity |= (initialCapacity >>>  1);
        
        initialCapacity |= (initialCapacity >>>  2);
        initialCapacity |= (initialCapacity >>>  4);
        initialCapacity |= (initialCapacity >>>  8);
        initialCapacity |= (initialCapacity >>> 16);
        
        // 1 0000
        initialCapacity++;

        if (initialCapacity < 0)   // Too many elements, must back off
            initialCapacity >>>= 1;// Good luck allocating 2 ^ 30 elements
    }
    return initialCapacity;
}
```

其中的核心代码段是通过对二进制取或运算将每一位都变成1，最后增一运算成为2的整次幂

```JAVA
    if (numElements >= initialCapacity) {
        initialCapacity = numElements;
        initialCapacity |= (initialCapacity >>>  1);
        
        initialCapacity |= (initialCapacity >>>  2);
        initialCapacity |= (initialCapacity >>>  4);
        initialCapacity |= (initialCapacity >>>  8);
        initialCapacity |= (initialCapacity >>> 16);
        
        // 1 0000
        initialCapacity++;
```

<font color=red>**准备知识：**</font>

<font color=red>**当除数为2的幂次方，可以用& 运算代替取余,即 **</font>

```JAVA
   b是2的幂次方。 a % b = a & (b-1)
```

<span style=color:red;background:yellow>**比如：**</span>

24=0001 1000

32=0010 0000

```JAVA
24  --》 32（0010 0000）
32  --》64（0100 0000）

if (numElements >= initialCapacity) {
    // initialCapacity = 24
    //                 11000
    initialCapacity = numElements;
    
    // initialCapacity >>>  1   01100
    // initialCapacity 			11000   -->11100
    
    initialCapacity |= (initialCapacity >>>  1);
    
    
    // initialCapacity        11100
    // initialCapacity >>> 2  00111
    // initialCapacity = 11111
    
    initialCapacity |= (initialCapacity >>>  2);
    initialCapacity |= (initialCapacity >>>  4);
    initialCapacity |= (initialCapacity >>>  8);
    initialCapacity |= (initialCapacity >>> 16);
    
    // 100000
    initialCapacity++;

    if (initialCapacity < 0)   // Too many elements, must back off
        initialCapacity >>>= 1;// Good luck allocating 2 ^ 30 elements
}
```

## `BlockingQueue`

阻塞队列

什么叫阻塞队列。一个<span style=color:red;background:yellow>**大小有限**</span>的队列。

- 插入时，<font color=red>**当队列满了，插入线程阻塞住**</font>。

- 从队列中获取元素时，<font color=red>**当队列空了，获取线程阻塞住**</font>

|          | *抛出异常*                                          | *返回特殊值*                                      | 阻塞     | 超时                 |
| -------- | --------------------------------------------------- | ------------------------------------------------- | -------- | -------------------- |
| **插入** | [`add(e)`](../../java/util/Queue.html#add(E))       | [`offer(e)`](../../java/util/Queue.html#offer(E)) | `put(e)` | `offer(e,time,unit)` |
| **移除** | [`remove()`](../../java/util/Queue.html#remove())   | [`poll()`](../../java/util/Queue.html#poll())     | `take()` | `poll(time,unit)`    |
| **检查** | [`element()`](../../java/util/Queue.html#element()) | [`peek()`](../../java/util/Queue.html#peek())     | 不可用   | 不可用               |

> 注意多线程是很重要的，虽然实际开发时不会去写该方法，但是许多框架内部会封装使用多线程。入职后再多学学 多线程 JVM JUC。

> 实际应用：
>
> 生产者消费者共用一个`BlockingQueue`。

# `Map` 前置准备

学习目标：

- 会使用`Map`的增删改查API，遍历`Map`的方式
- ==学会HashMap存储数据的特点==
- ==熟练掌握对常见的场景进行Map的使用==

## `Map`是什么

什么是`Map`呢？*`Map`就是用来存储键值对的接口*，注意，它与`Collection`的区别。`Collection`存储的是单列数据，`Map`存储的键值对。

> **键值对的特点：自描述性**
>
> 普通的`bean`（普通对象）其实也是存储的键值对数据，但是它存储的数据特点是键是固定的。但在Map中没有固定。

> 学后记：
>
> ​	1. `servletContext` `applicationContext`这样的context有个特点是共享一些东西，存储结构是`key-value`形式，本质上也是`Map`。

# `Map`

## 特点

1. `Map` 是Map体系的顶级接口，用来存储键值对数据
2. `Map` 存储的数据，有一些子接口有序，有一些无序
3. `Map `存储的数据，不能重复（指的是key）
4. `Map` 存储的数据，有一些允许为`null`，有一些不允许。（指的key）（TreeMap不允许存）

## API

```JAVA
//------新增，删除，查找数据接口
//添加键值对。如果键存在，是更新数据
	V put(K key, V value);
//将一个map的所有键值对都放入这个map
  void putAll(Map<? extends K,? extends V> m);
//根据一个key，获取value，如果key不存在，返回null
  V get(Object key);
//删除map中所包含的这个key
  V remove(Object key);
//判断map中是否包含这个key
  boolean containsKey(Object key);
//判断map中是否包含这个value
  boolean containsValue(Object value);

//------辅助接口
// 清空map
  void clear(); 
// 判断两个map是否相等
  boolean equals(Object o);
// 返回此映射的哈希值。
  int hashCode();
// map中是否有元素
  boolean isEmpty();
// 返回键-值映射关系数。
  int size();
```

>  🏷️什么是视图方法？
>
> 操作获取出来的 `key` 或者值会影响原本的 `Map`。

```JAVA
//--------视图方法
// 在Map里面 Entry 代表存储了key和value的一个接口体
// 返回此映射中包含的映射关系的 Set 视图。
	Set<Map.Entry<K,V>> entrySet();
// 返回此映射中包含的键的 Set 视图。
  Set<K> keySet();
// 返回此映射中包含的值的 Collection 视图。
  Collection<V> values();
```

> **如何遍历一个`Map`** ⚡
>
> 方式一：先获取`keySet`，遍历`keySet` ， `map.get(key)`拿到`value`。
>
> 方式二：直接获取`entrySet`。从 `entry` 获取 `key ` 获取 `value。`

> 使用`Map`完成存储
>
> 关键在于明确键值对中的键是什么，值是什么。

# `HashMap`

> 学后记：使用`HashMap`的过程中需要注意什么？
>
> [【Java 基础篇】深入理解Java HashMap：使用注意事项和性能优化-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/2339231)

## 准备知识

### 什么是Hash

映射（函数）的概念：

> 设A和B是两个非空集合，并存在某种对应关系f。
>
> 按照这种对应关系f，对于集合A中的任何一个元素a，在集合B中都存在<font color=red>**唯一的**</font>一个元素b与之对应，
>
> 那么，这样的对应（包括集合A，B，以及集合A到集合B的对应关系f）叫做集合A到集合B的映射。
>

<img src="https://hixiaodong123.oss-cn-hangzhou.aliyuncs.com/typora/202201121211877.png?align=center" alt="映射图解" style="zoom:33%;" />

注意：

1. <span style=color:red;background:yellow>**映射不要求元素一一对应，允许出现多对一，但绝不允许一对多。**</span>

---

明白映射的概念后，哈希映射(hash)就不难理解了。哈希映射也是一种特殊的映射，要求：

1. 集合A必须是一个无限大小，具有无穷多元素的集合。
2. 集合B必须是一个元素有限的集合。

<span style=color:red>化无限为有限</span>，这就是哈希映射。将**任意长度的输入**通过散列算法变换成**固定长度的输出**。

在哈希映射当中，集合A和B之间的对应关系f，就是一种映射的规则，称之为哈希函数、哈希方法或者哈希算法等。

而通过哈希算法，求得的集合B中的元素，称之为**哈希值**。

将无限，映射为有限。一定会存在一个问题？

冲突。  y=f(x) 不同的x。可能会得到相同的y。

### 好的Hash算法希望的特点

因为输入是无限数目的。而hash算法的结果(hash值)是有限的。所以肯定会遇到碰撞(hash值相同)。

<span style="font-size:20px;color:red;">好的hash算法希望对于不同的输入，得到不同的输出结果。</span>

### 2的幂取余问题

```JAVA
// 先说一个结论 
 1.当 b 是2的幂次。则  a % b =  a & (b-1)

 2.当 b 是2的幂次， a%b 相当于是取a的低位。
```

## `HashMap`的底层结构

`HashMap`底层结构是数组+链表+红黑树。

**`HashMap`的底层结构是一个数组。** 

 🏷️向`HashMap`中添加一个键值对。要经过哪些流程呢？

- 首先，会对键，计算得到一个int类型的值<font color=red>**(其实就是hash的过程)**</font>

- 然后与数组长度取余，得到键在数组上的位置

- 如果数组位置上没有元素，则直接插入

- 如果数组位置上有元素，<font color=red>**这个时候怎么操作呢？**</font>我们采用的链表，存储落在同一个位置上的元素。挨个比较，比较完成后，如果没有就插入到链表的最后一个位置。

  - ![HashMap底层结构](.\assets\HashMap底层结构.png)

<span style="font-size:20px;color:red;">链表太长了有什么问题？</span>

效率太低，因为比如链表有1w个节点，那就要比较1w次。效率差。所以链表太长了时会转化为<span style="font-size:20px;color:red;">红黑树。</span>

## 特点

1. `HashMap` 是`Map`接口的子实现。用来存储`key-value` 数据
2. 底层结构，是数组+链表+红黑树
3. 数组默认长度16，扩容机制是2倍。
4. 存储元素是无序的。（对于`key`来说的）
5. 不允许存储重复元素， <span style=color:red;background:yellow>**重复是指的它的键**</span>
6. 允许存储`null`。（对于`key` 来说的）

> 怎么计算得到 `int` 值的？利用hashcode
>
> 存储的元素是什么类型的？一个map

>  面试⭐为什么HashMap的底层是数组+链表+红黑树。
>
>  错误答法：不知道。写JDK那帮人写得。
>
>  把添加的流程答出来，然后分析，链表是必不可少的（因为存在多个key落在同一个数组位置）。如果链表长度太长，这时候效率太差，采用红黑树提高效率

红黑树的查找效率`O(logn)`

## `HashMap`的一些注意事项(面试题)

### ==初始化容量及扩容==

 数组默认长度是16。 扩容机制2倍

这样就保证了：数组长度一直都是2的幂次。计算可以简化  `a%b=a&(b-1)`

### 加载因子

`HashMap` 底层是数组+链表+红黑树。如果不限制，其实可以存无限的数据，但是这样**效率较低**。
 🟡在HashMap底层维护的了一个***加载因子***（`loadFactor`），用来表示存储到多少就会扩容。
// 比如默认的数组长度是16。 加载因子是`0.75f`
// 阈值 = 16 * 0.75 = 12
// `HashMap`存储的`key-value`数据数目超过阈值, 就要引发数组扩容。

> 加载因子是控制什么事情？
>
> 主要是控制数组上存储的数据。加载因子，是结合工程实践对很多场景进行测试得到的，所以不要改。

```JAVA
 if (++size > threshold){resize();}

															// 0.75*16
  threshold = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);

// 思考一下，添加数据的效率，查找数据的效率，删除数据的效率。 大概是多少？
```

### HashMap底层数组结构

```JAVA
// HashMap底层数组存储的key-value 是以Node结点存储的
// 里面存储了四个东西， key值 value值 hash 下一个节点
class Node{
    K key,
    V value,
    int hash,
    Node next
}

Node[] 
```

### hash 的计算

⚡ 为什么计算 `hash`的时候这么麻烦，直接计算`hashCode` 不可以吗？

> 为了让计算得到下标的时候，**高位和地位同时生效**。

```JAVA
// hash() 就是为了计算给定的key的int值
static final int hash(Object key) {
    int h;
    // key == null
    // 如果key为null的时候，返回0
    // 如果key不为null。 (h = key.hashCode()) ^ (h >>> 16)
    
    // 计算hashCode. h=hashCode 
    // (h) ^ (h >>> 16)
    // 就是为了让计算 得到下标的时候。高位和低位同时生效。
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

// a % b = a & (b-1)
//  0010 0111 0110 0110(10086)
//& 0000 0000 0000 1111 
// a和b取余的时候。 谁生效  低位生效

(hashCode) ^ (hashCode >>> 8)
// 0010 0111 0110 0110
// 0000 0000 0010 0111
// 0010 0111 0100 0001 
// 让hashCode的高位和低位都参与了  计算得到index这个过程

// 现在我们假设 hashCode 是以下的两种情况
// 1001 0101   --》 对zhangsan
// 0110 0101   --> 对lisi计算
    
// hashCode ^ (hashCode >>> 4)
// 1001 0101   --》 对zhangsan
// 0000 1001 
// 1001 1100   --> zhangsan
    
// 0110 0101   --> 对lisi计算
// 0000 0110
// 0110 0011  --> lisi 
```

```JAVA
// (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16)

// 对于任意一个输入，我们需要得到一个数字与之对应
// 如果key为null，则直接返回0
// 如果key不为null。首先计算hashCode。然后hashCode无符号右移动16位，然后与原数取异或。

// 是为了充分混合，让key落得位置更加均匀。
//  数组长度是2的幂次。   对这个2的幂次取余，最终起效果的就是数字的 后面位置。

// 例如，计算得到的hash值是77。 
// 当数组底层长度是n的时候。计算得到的下标： 
// 16:  77(0100 1101) % 16(0001 0000) 
//      77(0100 1101) & (0000 1111)
// 	=  0100 1101 & 0000 1111 = 1101    (就是最后四位，取的低位)

// 这时候，高位和低位取个异或，会让高位和低位对在数组上的下标起作用
```


### ==（重要）<span style="color:red;">HashMap对重复的key的定义</span>==

```JAVA
// p指的是原本存在的元素
// hash 是我们传入的hash值（int）  key
(p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))))

// 1.hash值相同，才往下判断
// 2.如果地址相同 或者 如果equals返回相同。也就是：如果传入的key和我数组上的key 是同一个(地址相同)；或者equals返回true，也认为是相同的。
```

-  这就要求我们，**使用一些类作为key时**，<span style=color:red;background:yellow>**必须同时重写hashCode和equals方法。**</span>
-  <span style=color:red;background:yellow>**不建议大家使用自定义的类当做key。一般使用字符串或者Integer。**</span>

### 存储重复元素

`HashMap` 不允许存储重复的`key`, 当我们存储一份重复的key-value数据时,   是直接用新value是替代旧value，**然后，返回了旧值。**

### 链表什么时候转化为红黑树

 当某个下标位置, 链表长度, **超过8达到9**个时候(算上新加的结点), 就要由链表转化为红黑树

> 面试官问⭐ 当链表数目从8达到9，一定会转化为红黑树吗？
>
> 因为数组长度太小时，长度小于64（数组长度不能是63而是2的幂次方就是32），会直接扩容数组。

### 当链表数目从8到达9，一定会转化为红黑树吗？

不一定会。

 如果数组长度, 小于64,  即使某个下标位置,链表长度已经超过8, 达到9了, 不会转化为红黑树, 而是扩容, **扩容会导致原本存在于这个位置的数据, 拆成两部分。**

<span style="font-size:20px;color:red;">思考一下，为什么这么设计？</span>

当链表的长度，到达9的时候，会转化为红黑树。

数组长度是32，是最大的情况。

当前位置，有9个元素，其它31个位置，假设已经有12个元素，阈值是`32*0.75 = 24`.当前元素有 `9+12=21`个。所以再来3个元素就会自动扩容

### 扩容后位置问题 

扩容后原来位置的元素去向有两种情况

- 原来的位置
- 原来的位置+旧数组的长度。

```JAVA
// 现在，假设位置在x位置上的元素，会落到新数组的什么位置
// 旧数组长度: 16
// 新数组长度： 16 * 2 = 32

// x = hash % Oldlen = hash % 16
// 用x把hash表示出来。    hash = x + 16 * n
// 现在落在新数组什么位置： hash % 32 = (x + 16 * n) % 32 = x + 16 ; x 
// 所以说，就只能落在两种位置： 要么原index位置，要么index + oldCapacity

// 在HashMap中, 存储的数据量大于HashMap的阈值(加载因子*数组长度), 会产生扩容,  当扩容之后一个原本在旧数组x位置的key-value数据,   要和新数组长度取模,得到一个新的下标, 这个新的下标只有两个选择:  x位置, 旧数组长度+x的位置

// 扩2倍。

// 数组长度16.
// x --> hash=16*n + x
// 32    --> hash % 32  = (16 * n + x) % 32  = x,16+x
```

### 红黑树转化为链表

 有两个情况:

- 第一个情况：删除数据的时候。要删除的数据在红黑树上,  删除数据导致红黑树上数据量变少,  由红黑树转化为链表

- 第二个情况：扩容的时候。 一个红黑树再扩容之后，被拆成两部分, 任一部分数据量过少, 也会由红黑树转化为链表。
  红黑树拆成低位(旧位置)和高位(旧位置+旧数组长度: 新位置)两部分，这两部分任何一部分分配的数据量**小于等于6个**，就要由红黑树转化为链表。

### 如果我们在`HashMap`已经添加了一份`key-value`数据,  建议尽量不要再通过`key`的引用直接修改`key`,  有可能会无法 再操作这个数据 (了解)

 重写了 `hashCode`和`equals`。则两个对象的`hashCode` 是一样的。落在了数组上的同一个位置。

如果这时候通过原对象的引用去修改了变量值。则会导致一个现象：`hashCode` 会改变，不会落在同一个位置，则操作不会生效，比如`remove`。

建议： `Map` 里面的`key`，直接用`String`。

### ==（重要）<span style="color:red;">HashMap的添加流程</span>==

```JAVA
// 1.当我们想往一个HashMap中添加一个数据。 key=zs,value=20
// 2.对key计算它的hash。 也就是对zs取hash。
// 		计算hash的方法：(key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16)
// 3.使用计算得到的hash。与数组长度取余，得到这个key在数组上的位置
// 		a%b=a&(b-1)
// 4.检查数组位置上是否有键值对。
//   4.1 如果数组上没有元素，则直接新建节点，然后插入到数组。
//  				Node   key,value,hash,next(Node)
//   4.2 如果数组位置有元素，比较是否相等。
//  			怎么判断相等：p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))
//    1)如果相等，则直接使用新的value替代旧的value。结束
//	  2)如果不相等，则挨个进行比较。   链表直接调用next，树就是左小右大。一直比较到没有元素。
//	  		一直到最后一个。
// 5.如果是链表，插入后的长度超过阈值(8)。则会转化为红黑树
//		如果数组长度小于64。不会转化为红黑树，会直接进行扩容。
// 6.如果没有重复，插入后，map中节点数超过阈值。 默认为数组长度的0.75。则会进行扩容，扩容2倍。
// 		扩容后的位置： x或x+len 。len为数组的长度。  
// 7.上述所有的扩容, 都有可能导致原本数组某个位置如果有红黑树, 红黑树被拆成两部分(低位和高位), 任一位置结点数变少, 又有可能导致红黑树转化为链表
```

> 如何判断相等？
>
> hashCode相等 && (key的引用相等 || key equals()为true)

`HashMap`的添加流程：

```JAVA
1.我们要添加一个键值对进入 HashMap   zs,18
2.对key计算得到一个int值。  --》 hash  
    (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16)
2.使用int值对数组长度进行取余。  a%b=a&(b-1)  得到在数组上的下标位置 index
      hash & (length) - 1  
3.判断数组指定位置是否有元素。
    3.1如果没元素。 直接把键值对添加到数组位置 
     K key, V value,int hash,Node next
    3.2如果有元素。 进行挨个比较
        3.2.1 key 如果相等。(p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))))
            （hash相同） && （（地址相同） || equals(内容)）
            使用新值替换旧值； 返回旧值
        3.2.2 接着往下比较。链表就一个一个往下走；红黑树按照左小右大的顺序走。

4.比较完成。没有相同的，相等的。
    把元素插入到末尾、
5.如果是链表，插入元素可能会导致 链表转换为红黑树
长度超过8到达9的时候，转为红黑树
       是不是长度超过8到达9，一定会由链表转成红黑树 --》 不一定，如果数组的长度 小于64

6.如果插入之后，可能会导致扩容。HashMap上的键值对，超过阈值(0.75 * 数组长度)，会扩容。扩容按照2倍扩的，扩容之后： x , x+oldCapacity 
```

## `HashMap` 的构造方法

在空构造里没有看到对底层数组的赋值，所以在添加方法中，一定有这个过程。

**单参构造器**：会自动转为2的幂次方。

和`ArrayDeque`的区别是传入16时，`HashMap` 会是16，`ArrayDeque` 会是32.

```JAVA
// 构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。 
HashMap(); 
// 构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。 会找到大于等于当前值的一个2的幂次方
HashMap(int initialCapacity);
// 构造一个带指定初始容量和加载因子的空 HashMap。        
HashMap(int initialCapacity, float loadFactor) 
// 构造一个映射关系与指定 Map 相同的新 HashMap。         
HashMap(Map<? extends K,? extends V> m) 
```

## `HashMap`的API

```JAVA
//-------新增，删除，查找数据接口
//添加键值对
	V put(K key, V value);
//将一个map的所有键值对都放入这个map
  void putAll(Map<? extends K,? extends V> m);
//根据一个key，获取value，如果key不存在，返回null
  V get(Object key);
//删除map中所包含的这个key
  V remove(Object key);

//判断map中是否包含这个key
  boolean containsKey(Object key);
//判断map中是否包含这个value
  boolean containsValue(Object value);

//---------辅助接口
//清空map
    void clear();
//判断两个map是否相等
    boolean equals(Object o);
//返回此映射的哈希码值。
    int hashCode();
//map中是否有元素
    boolean isEmpty();
//返回键-值映射关系数。
    int size();

//--------视图方法
//返回此映射中包含的映射关系的 Set 视图。
    Set<Map.Entry<K,V>> entrySet();
//返回此映射中包含的键的 Set 视图。
    Set<K> keySet();
//返回此映射中包含的值的 Collection 视图。
    Collection<V> values();
```

##  ⚡组装数据

集合的操作非常重要，基本上业务代码都是完成各种各样数据的组装。

有三个类，其中一个存着学生的一些信息

```JAVA
// 一组学生数据，学生信息里有以下信息。
// (id, name, age, teacher_id)

// 一组班主任数据，有以下信息
// (id, name, age)

// 我们这样认为：一个老师对应n个学生，一个学生只对应一个老师。
// 现在需求方需要一个数据，需要返回班主任的信息，然后和对应班级同学的信息。
// 提供两份数据：
List<Teacher> teachers = new ArrayList<>();
List<Student> students = new ArrayList<>();

class Grade{
   Teacher teacher;  
   List<Student> students;
}
```

# `HashMap`的源码

如果实在听不懂建议把琢磨源码的时间放给刷Leetcode.

看源码的方向

- 初始化
  - 长度是16
  
  ```JAVA
  class HashMap{
      
      // 加载因子
      final float loadFactor;
      
      // 阈值
      int threshold;
      
      // 底层数组
      Node<K,V>[] table;
      
      static final float DEFAULT_LOAD_FACTOR = 0.75f;
     
      public HashMap() {
          // this.loadFactor = DEFAULT_LOAD_FACTOR（0.75）
          // 在空构造方法里面，没有对table（底层数组）进行初始化， 那么在添加方法的时候，一定会进行初始化。所以我们需要看put
          this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
      }
      
      public V put(K key, V value) {
          return putVal(hash(key), key, value, false, true);
      }
      
      static final int hash(Object key) {
          int h;
          return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
      }
      
      //                 hash值
      final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) {
          // 
          Node<K,V>[] tab; Node<K,V> p; int n, i;
          
          // 因为在空构造中，没有对table进行初始化，所以目前 是 null。 所以tab 为null
          if ((tab = table) == null || (n = tab.length) == 0)
              // 
              n = (tab = resize()).length;
          if ((p = tab[i = (n - 1) & hash]) == null)
              tab[i] = newNode(hash, key, value, null);
          else {
              Node<K,V> e; K k;
              if (p.hash == hash &&
                  ((k = p.key) == key || (key != null && key.equals(k))))
                  e = p;
              else if (p instanceof TreeNode)
                  e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
              else {
                  for (int binCount = 0; ; ++binCount) {
                      if ((e = p.next) == null) {
                          p.next = newNode(hash, key, value, null);
                          if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                              treeifyBin(tab, hash);
                          break;
                      }
                      if (e.hash == hash &&
                          ((k = e.key) == key || (key != null && key.equals(k))))
                          break;
                      p = e;
                  }
              }
              if (e != null) { // existing mapping for key
                  V oldValue = e.value;
                  if (!onlyIfAbsent || oldValue == null)
                      e.value = value;
                  afterNodeAccess(e);
                  return oldValue;
              }
          }
          ++modCount;
          if (++size > threshold)
              resize();
          afterNodeInsertion(evict);
          return null;
      }
      
      // 
      final Node<K,V>[] resize() {
          // table 为null
          // oldTab = table = null
          Node<K,V>[] oldTab = table;
          // oldCap = 0
          int oldCap = (oldTab == null) ? 0 : oldTab.length;
          // oldThr = threshold = 0
          int oldThr = threshold;
          // newCap, newThr = 0
          int newCap, newThr = 0;
          // oldCap 为0. 不会进入这个if
          if (oldCap > 0) {
              if (oldCap >= MAXIMUM_CAPACITY) {
                  threshold = Integer.MAX_VALUE;
                  return oldTab;
              }
              else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                       oldCap >= DEFAULT_INITIAL_CAPACITY)
                  newThr = oldThr << 1; // double threshold
          }
          // oldThr 也为0.不会进入
          else if (oldThr > 0) // initial capacity was placed in threshold
              newCap = oldThr;
          else {               // zero initial threshold signifies using defaults
              // if没进去，else if 没进去。  进else
              // newCap = DEFAULT_INITIAL_CAPACITY( 16 )
              // newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY) = (0.75 * 16) = 12
              newCap = DEFAULT_INITIAL_CAPACITY;
              newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
          }
          if (newThr == 0) {
              float ft = (float)newCap * loadFactor;
              newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                        (int)ft : Integer.MAX_VALUE);
          }
          // threshold 全局变量。   
          // threshold = 12
          threshold = newThr;
          // new Node[newCap] ==》   new Node[16]
          Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
          // table就是  长度是16的数组、
          table = newTab;
          if (oldTab != null) {
          	// 目前为null。    
          }
          return newTab;
      }
  }
  ```
  
- 扩容策略
  - 2倍
  
  - ```JAVA
    class HashMap{
        
        // 加载因子
        final float loadFactor;
        
        // 阈值
        int threshold;
        
        // 底层数组
        Node<K,V>[] table;
    
    	// 只有在不断的添加数据的过程中，才会出现 扩容。
        // 所以要看扩容方法，我们需要看添加方法。
        
        public V put(K key, V value) {
            return putVal(hash(key), key, value, false, true);
        }
        
        final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                       boolean evict) {
            Node<K,V>[] tab; Node<K,V> p; int n, i;
            if ((tab = table) == null || (n = tab.length) == 0)
                n = (tab = resize()).length;
            if ((p = tab[i = (n - 1) & hash]) == null)
                tab[i] = newNode(hash, key, value, null);
            else {
                // else是有元素的时候。
                Node<K,V> e; K k;
                if (p.hash == hash &&
                    ((k = p.key) == key || (key != null && key.equals(k))))
                    e = p;
                else if (p instanceof TreeNode)
                    e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
                else {
                    for (int binCount = 0; ; ++binCount) {
                        if ((e = p.next) == null) {
                            p.next = newNode(hash, key, value, null);
                            if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                                treeifyBin(tab, hash);
                            break;
                        }
                        if (e.hash == hash &&
                            ((k = e.key) == key || (key != null && key.equals(k))))
                            break;
                        p = e;
                    }
                }
                if (e != null) { // existing mapping for key
                    V oldValue = e.value;
                    if (!onlyIfAbsent || oldValue == null)
                        e.value = value;
                    afterNodeAccess(e);
                    return oldValue;
                }
            }
            ++modCount;
            
            if (++size > threshold)
                // 如果键值对数目 大于 阈值（loadFactor * 数组长度）
                // 进行扩容
                resize();
            afterNodeInsertion(evict);
            return null;
        }
        
        
        // 扩容方法
        final Node<K,V>[] resize() {
            // oldTab = table    new Node[16]
            Node<K,V>[] oldTab = table;
            // oldCap = 16
            int oldCap = (oldTab == null) ? 0 : oldTab.length;
            // oldThr = 12
            int oldThr = threshold;
            //  newCap, newThr = 0
            int newCap, newThr = 0;
            
            // 目前oldCap 为16. 大于0
            if (oldCap > 0) {
                if (oldCap >= MAXIMUM_CAPACITY) {
                    threshold = Integer.MAX_VALUE;
                    return oldTab;
                }
                // newCap = oldCap << 1 = oldCap * 2 = 32
                // oldCap >= 16 为真
                else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                         oldCap >= DEFAULT_INITIAL_CAPACITY)
                    // 条件满足，进入这个条件
                    // newThr = oldThr * 2 = 24
                    newThr = oldThr << 1; // double threshold
            }
            else if (oldThr > 0) // initial capacity was placed in threshold
                newCap = oldThr;
            else {               // zero initial threshold signifies using defaults
                newCap = DEFAULT_INITIAL_CAPACITY;
                newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
            }
            
            
            if (newThr == 0) {
                float ft = (float)newCap * loadFactor;
                newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                          (int)ft : Integer.MAX_VALUE);
            }
            
            // threshold = newThr = 24
            threshold = newThr;
            // newCap = 32 
            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
            table = newTab;
            if (oldTab != null) {
                for (int j = 0; j < oldCap; ++j) {
                    Node<K,V> e;
                    if ((e = oldTab[j]) != null) {
                        oldTab[j] = null;
                        if (e.next == null)
                            newTab[e.hash & (newCap - 1)] = e;
                        else if (e instanceof TreeNode)
                            ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                        else { // preserve order
                            Node<K,V> loHead = null, loTail = null;
                            Node<K,V> hiHead = null, hiTail = null;
                            Node<K,V> next;
                            do {
                                next = e.next;
                                if ((e.hash & oldCap) == 0) {
                                    if (loTail == null)
                                        loHead = e;
                                    else
                                        loTail.next = e;
                                    loTail = e;
                                }
                                else {
                                    if (hiTail == null)
                                        hiHead = e;
                                    else
                                        hiTail.next = e;
                                    hiTail = e;
                                }
                            } while ((e = next) != null);
                            if (loTail != null) {
                                loTail.next = null;
                                newTab[j] = loHead;
                            }
                            if (hiTail != null) {
                                hiTail.next = null;
                                newTab[j + oldCap] = hiHead;
                            }
                        }
                    }
                }
            }
            return newTab;
        }
    
    }
    ```
  
- 添加数据和查找数据的流程

  - ```java
    class HashMap{
        
        // 加载因子
        final float loadFactor;
        
        // 阈值
        int threshold;
        
        // 底层数组
        Node<K,V>[] table;
    
    	// 只有在不断的添加数据的过程中，才会出现 扩容。
        // 所以要看扩容方法，我们需要看添加方法。
        
        public V put(K key, V value) {
            return putVal(hash(key), key, value, false, true);
        }
        
        final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                       boolean evict) {
            Node<K,V>[] tab; Node<K,V> p; int n, i;
            // 第一次进来的时候，没有初始化，初始化的代码
            if ((tab = table) == null || (n = tab.length) == 0)
                n = (tab = resize()).length;
            // 对hash值进行取余。得到在数组上的位置
            // tab[i = (n - 1) & hash] 得到数组上指定位置的元素
            if ((p = tab[i = (n - 1) & hash]) == null)
                // 如果数组位置没有元素。直接新建节点。 放到 tab[i]位置
                tab[i] = newNode(hash, key, value, null);
            else {
                // else是有元素的时候。  说明数组该位置有元素
                Node<K,V> e; K k;
                
                // 如果传入的key和当前拿到的这个元素相等。 
                if (p.hash == hash &&
                    ((k = p.key) == key || (key != null && key.equals(k))))
                    // e 就是找到的相同的元素。 相同key的元素。
                    e = p;
                else if (p instanceof TreeNode)
                    // 说明下面挂着的是红黑树。
                    e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
                else {
                    // 链表。也就是底下挂载的是链表
                    for (int binCount = 0; ; ++binCount) {
                        if ((e = p.next) == null) {
                            p.next = newNode(hash, key, value, null);
                            if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                                treeifyBin(tab, hash);
                            break;
                        }
                        if (e.hash == hash &&
                            ((k = e.key) == key || (key != null && key.equals(k))))
                            break;
                        p = e;
                    }
                }
                if (e != null) { // existing mapping for key
                    V oldValue = e.value;
                    if (!onlyIfAbsent || oldValue == null)
                        e.value = value;
                    afterNodeAccess(e);
                    return oldValue;
                }
            }
            ++modCount;
            
            if (++size > threshold)
                // 如果键值对数目 大于 阈值（loadFactor * 数组长度）
                // 进行扩容
                resize();
            afterNodeInsertion(evict);
            return null;
        }
        
        
        // 扩容方法
        final Node<K,V>[] resize() {
            // oldTab = table    new Node[16]
            Node<K,V>[] oldTab = table;
            // oldCap = 16
            int oldCap = (oldTab == null) ? 0 : oldTab.length;
            // oldThr = 12
            int oldThr = threshold;
            //  newCap, newThr = 0
            int newCap, newThr = 0;
            
            // 目前oldCap 为16. 大于0
            if (oldCap > 0) {
                if (oldCap >= MAXIMUM_CAPACITY) {
                    threshold = Integer.MAX_VALUE;
                    return oldTab;
                }
                // newCap = oldCap << 1 = oldCap * 2 = 32
                // oldCap >= 16 为真
                else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                         oldCap >= DEFAULT_INITIAL_CAPACITY)
                    // 条件满足，进入这个条件
                    // newThr = oldThr * 2 = 24
                    newThr = oldThr << 1; // double threshold
            }
            else if (oldThr > 0) // initial capacity was placed in threshold
                newCap = oldThr;
            else {               // zero initial threshold signifies using defaults
                newCap = DEFAULT_INITIAL_CAPACITY;
                newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
            }
            
            
            if (newThr == 0) {
                float ft = (float)newCap * loadFactor;
                newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                          (int)ft : Integer.MAX_VALUE);
            }
            
            // threshold = newThr = 24
            threshold = newThr;
            // newCap = 32 
            Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
            table = newTab;
            if (oldTab != null) {
                for (int j = 0; j < oldCap; ++j) {
                    Node<K,V> e;
                    if ((e = oldTab[j]) != null) {
                        oldTab[j] = null;
                        if (e.next == null)
                            newTab[e.hash & (newCap - 1)] = e;
                        else if (e instanceof TreeNode)
                            ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                        else { // preserve order
                            Node<K,V> loHead = null, loTail = null;
                            Node<K,V> hiHead = null, hiTail = null;
                            Node<K,V> next;
                            do {
                                next = e.next;
                                if ((e.hash & oldCap) == 0) {
                                    if (loTail == null)
                                        loHead = e;
                                    else
                                        loTail.next = e;
                                    loTail = e;
                                }
                                else {
                                    if (hiTail == null)
                                        hiHead = e;
                                    else
                                        hiTail.next = e;
                                    hiTail = e;
                                }
                            } while ((e = next) != null);
                            if (loTail != null) {
                                loTail.next = null;
                                newTab[j] = loHead;
                            }
                            if (hiTail != null) {
                                hiTail.next = null;
                                newTab[j + oldCap] = hiHead;
                            }
                        }
                    }
                }
            }
            return newTab;
        }
    
    }
    ```


> 看源码先梳理主流程，然后再仔细看细节。

# Hashtable

## 特点

1. `Hashtable`是Map接口的一个子实现
2. `Hashtable`底层结构是数组+链表 (和HashMap在jdk1.8之前是一样的)
3. 底层数组默认的初始长度11 ; 默认的扩容机制 2倍+1 
4. 存储元素无序
5. 不允许存储重复的key:   (对key的重复的定义和HashMap一样)
6. 不允许存储`null` 作为`key`,   也不允许存储 `null`作为 `value`
7. 线程安全
8. jdk1.0时候出现,  (HashMap是jdk1.2时候出现, HashMap的出现就是为了取代Hashtable的)

`Hashtable` 仅限面试使用。

`HashMap`的红黑树，在1.8的时候才加上去。所以在1.8之前，两个的结构是一致的

一般面试官问，了解`HashMap`和`Hashtable`吗？说一下`HashMap`和`Hashtable`的区别？

> 首先先说一下共同点
>
> 1. 两个都是Map的子实现。都用来存储`key-value`数据
> 2. 在1.8之前，两者底层结构都是**数组+链表**。但在1.8之后，`HashMap`变成了**数组+链表+红黑树**
> 3. 存储元素无序，都不能存储重复元素。`HashMap`允许存储`null`。`Hashtable` 不允许存储 `null`
> 4. `HashMap` 线程不安全，`Hashtable` 线程安全。
> 5. `HashMap` 在1.2出现，就是为了替代`Hashtable` 的。新写代码不使用`Hashtable` 

# LinkedHashMap

## LinkedHashMap的特点

1. `LinkedHashMap`是`HashMap`的一个子类
2. `LinkedHashMap`底层基本上完全复用了父类`HashMap`的结构/参数/方法
3. `LinkedHashMap`在`HashMap`的基础上, <span style=color:red;background:yellow>**额外的维护了一个双向链表, 以保证迭代顺序**</span>
4. `LinkedHashMap`存储<span style=color:red;background:yellow>**元素有序**</span>
5. `LinkedHashMap`不允许存储重复数据
6. `LinkedHashMap`允许存储`null`

## LinkedHashMap的构造方法

```JAVA
// 构造一个带默认初始容量 (16) 和加载因子 (0.75) 的空插入顺序 LinkedHashMap 实例。 
LinkedHashMap();
// 构造一个带指定初始容量和默认加载因子 (0.75) 的空插入顺序 LinkedHashMap 实例。         
LinkedHashMap(int initialCapacity) 
// 构造一个带指定初始容量和加载因子的空插入顺序 LinkedHashMap 实例。           
LinkedHashMap(int initialCapacity, float loadFactor) 
// 构造一个带指定初始容量、加载因子和排序模式的空 LinkedHashMap 实例。           
LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) 
// 构造一个映射关系与指定映射相同的插入顺序 LinkedHashMap 实例。           
LinkedHashMap(Map<? extends K,? extends V> m) 
```

## LinkedHashMap的API

```JAVA
//---------新增，删除，查找数据接口
//添加键值对
		V put(K key, V value);
//将一个map的所有键值对都放入这个map
    void putAll(Map<? extends K,? extends V> m);
//根据一个key，获取value，如果key不存在，返回null
    V get(Object key);
//删除map中所包含的这个key
    V remove(Object key);

//判断map中是否包含这个key
    boolean containsKey(Object key);
//判断map中是否包含这个value
    boolean containsValue(Object value);

//---------辅助接口
//清空map
void clear();
//判断两个map是否相等
boolean equals(Object o);
//返回此映射的哈希码值。
int hashCode();
//map中是否有元素
boolean isEmpty();
//返回键-值映射关系数。
int size();

//----------视图方法
//返回此映射中包含的映射关系的 Set 视图。
Set<Map.Entry<K,V>> entrySet();
//返回此映射中包含的键的 Set 视图。
Set<K> keySet();
//返回此映射中包含的值的 Collection 视图。
Collection<V> values();
```

# TreeMap

## TreeMap的特点

1. `TreeMap`是Map接口的子实现
2. `TreeMap`的数据结构红黑树。
   1. 红黑树特点：（左小右大）

3. `TreeMap`存储数据大小有序。(前面的有序都是存取有序)
4. `TreeMap`不允许存储重复的`key `
   1. 什么叫重复: key的大小一样，compareTo结果返回值是0.
   2. 使用自定义的类作为`TreeMap`的`key`的两种方法：要么实现`Comparable`接口，要么在构造方法传入`Comparator`

5. `TreeMap`不允许存储`null`作为`key`:   null没有办法比较大小

## TreeMap的构造方法

```JAVA
// 使用键的自然顺序构造一个新的、空的树映射
TreeMap();
// 构造一个新的、空的树映射，该映射根据给定比较器进行排序 
TreeMap(Comparator<? super K> comparator); 
// 构造一个与给定映射具有相同映射关系的新的树映射，该映射根据其键的自然顺序 进行排序      
TreeMap(Map<? extends K,? extends V> m) 
// 构造一个与指定有序映射具有相同映射关系和相同排序顺序的新的树映射
TreeMap(SortedMap<K,? extends V> m) 
```

> Comparable接口：在JAVA中要实现两个对象的比较，该类需要实现Comparable接口。

## TreeMap的API

```JAVA
// -------从Map接口继承来的--------
//如果此映射包含指定键的映射关系，则返回true。
	boolean containsKey(Object key)
//如果此映射为指定值映射一个或多个键，则返回 true。
  boolean containsValue(Object value)
//将指定值与此映射中的指定键进行关联。
  V put(K key, V value)
// 将指定映射中的所有映射关系复制到此映射中。
  void putAll(Map<? extends K,? extends V> map)
// 如果此 TreeMap 中存在该键的映射关系，则将其删除。
  V remove(Object key)  
//返回指定键所映射的值，如果对于该键而言，此映射不包含任何映射关系，则返回 null。
  V get(Object key)
// 从此映射中移除所有映射关系。
  void clear()
// 返回此 TreeMap 实例的浅表副本。       
	Object clone()
// 返回此映射中的键-值映射关系数。
	int size()
// 返回此映射包含的值的 Collection 视图。
	Collection<V> values()
// 返回此映射包含的键的 Set 视图。
	Set<K> keySet()
// 返回此映射中包含的映射关系的 Set 视图。
	Set<Map.Entry<K,V>> entrySet()

// ------TreeMap定义大小操作相关的api-------
//大于等于给定key的最小键值对
  Map.Entry<K,V> ceilingEntry(K key)
//大于等于给定key的最小key
  K ceilingKey(K key)
//小于等于key的最大的键值对
  Map.Entry<K,V> floorEntry(K key)
//小于等于key最大的key
  K floorKey(K key)
//大于给定key的最小键值对
  Map.Entry<K,V> higherEntry(K key)
//大于给定key的最小key
  K higherKey(K key)
//小于key的最大的键值对
  Map.Entry<K,V> lowerEntry(K key)
//小于key最大的key
  K lowerKey(K key)
//返回最小的键值对
  Map.Entry<K,V> firstEntry()
//返回最小的key
  K firstKey()
//返回最大的键值对
  Map.Entry<K,V> lastEntry()
//返回最大的key
  K lastKey()
//删除最小的键值对Map.Entry<K,V>
  pollFirstEntry()
//删除最大的键值对
  Map.Entry<K,V> pollLastEntry()

// ------视图方法-------
//返回此映射的部分视图，其键的范围从 fromKey 到 toKey。
  NavigableMap<K,V> subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)
//返回此映射的部分视图，其键值的范围从 fromKey（包括）到 toKey（不包括）。
  SortedMap<K,V> subMap(K fromKey, K toKey)
//返回此映射的部分视图，其键大于等于 fromKey。
  SortedMap<K,V> tailMap(K fromKey)
//返回此映射的部分视图，其键大于（或等于，如果 inclusive 为 true）fromKey。
  NavigableMap<K,V> tailMap(K fromKey, boolean inclusive)
//返回此映射的部分视图，其键值严格小于 toKey。
  SortedMap<K,V> headMap(K toKey)
//返回此映射的部分视图，其键小于（或等于，如果 inclusive 为 true）toKey。
  NavigableMap<K,V> headMap(K toKey, boolean inclusive)

// ----------一些特殊的api: 了解--------------
//返回此映射中所包含键的逆序 NavigableSet 视图。
  NavigableSet<K> descendingKeySet()

//返回此映射中所包含映射关系的逆序视图。
  NavigableMap<K,V> descendingMap()

// 返回此映射中所包含键的 NavigableSet 视图。
  NavigableSet<K> navigableKeySet()
   
//返回对此映射中的键进行排序的比较器；如果此映射使用键的自然顺序，则返回 null。
  Comparator<? super K> comparator()   
```

`TreeMap`的应用：

假设我们需要实现一个功能，即存储某个城市的天气预报，并且需要按照时间排序。在这种情况下，我们可以使用TreeMap来存储天气预报信息。

具体来说，我们可以将预报时间作为key，将天气预报信息（如温度[temperature](javascript:;)、湿度[humidity](javascript:;)、气压[air_pressure](javascript:;)等）作为value存储在TreeMap中。由于TreeMap是有序的，因此我们可以方便地按照时间顺序遍历元素，从而实现预报信息的展示和查询功能。

想获取2023-04-24这天的天气。

想获取  17~23号一周的天气。

如果需要Map中的key，有序的时候，可以使用这个TreeMap。

```java
map.subMap(new Date("2023-04-17"), true,new Date("2023-04-24"), false)
```

// HashMap   + ArrayList  

# Properties

> 一般都是使用它来从`properties`配置文件中读写。
>
> 继承自`HashTable`。

注意：当做配置文件使用，只能存入`String`类型的`key-value`。否则在存储为properties文件的时候，会报错。

```JAVA
// 新增key,value 使用的方法
setProperty()
    
// 根据key查询value的方法，使用
getProperty()
```

`properties`文件(`1.properties`)

```properties
# key=value 格式去写
username=zhangsan
password=admin
```

读取`properties`文件

```JAVA
Properties properties1 = new Properties();
properties1.load(new FileInputStream("1.properties"));
```

为什么一般把配置放在配置文件里，它和我们直接写在代码里，有什么区别？

> 情况一：修改了代码之后，上线前需要测试。写在配置文件上之后，修改配置文件这时候不需要测试。
>
> 情况二：有很多环境，如果配置在代码里就需要维护很多套代码，开发环境、测试环境、联调环境、模拟上线环境

# Set

学习目标：

- 掌握`Set`接口存储数据的特点
- 掌握`Set`的子类：`HashSet`，`LinkedHashSet`，`TreeSet`存储数据的特点
  - 是否有序
  - 对重复的定义
  - 是否允许存储`null`
- 了解`Set`子类的实现方式
- <span style=color:yellow;background:red>**熟练掌握`Set`的使用场景**</span>

## 特点

1.  `Set`是`Collection`的子接口
2.  `Set`数据结构是: 集合（不能存储重复元素）
3.  有些子实现无序(`HashSet`),  有些子实现是有序的(`LinkedHashSet`存储有序, `TreeSet`大小有序)
4.  所有子实现都不允许存储重复元素（什么叫重复？在HashSet或者LinkedHashSet中：hashCode相同& equals 为true   在TreeSet中：Comparable接口返回0，叫重复。）
5.  有些子实现允许存储`null`(HashSet, LinkedHashSet), 有些子实现不允许存储`null`(TreeSet)

## Set的API

```JAVA
// ----set接口, 没有在Collection的基础上额外定义什么api----

//    -------增删改查方法-------
//添加一个元素进入Collection
	boolean add(E e);
//添加一个Collection进指定的Collection
  boolean addAll(Collection<? extends E> c);
//删除元素， 只删除第一个出现的(如果存在多个)
    boolean remove(Object o);
//删除Collection中的所有存在的元素,会全部删除，如果存在多个
    boolean removeAll(Collection<?> c);
//判断是否存在指定元素
    boolean contains(Object o);
//判断给定的collection中是否全部存在于目标Collection
    boolean containsAll(Collection<?> c);
//将原有collection只保留传入的collection。
    boolean retainAll(Collection<?> c);

// -------特殊方法--------
//清空collection
    void clear();
//判断是否相等
    boolean equals(Object o);
//计算hashCode
    int hashCode();
//是否为空
    boolean isEmpty();
//collection里面的元素个数
    int size();
//
//    ----------方便遍历方法------------
//将collection转成一个数组，方便遍历，
Object[] toArray();
//类似，只是传入了一个数组
<T> T[] toArray(T[] a);
//返回一个迭代器
Iterator<E> iterator();
```

## HashSet

### HashSet的特点

1.  HashSet是Set接口的子实现
2.  HashSet底层持有了一个HashMap对象
    1. 我们存储到HashSet中的数据, 实际上都存储到底层持有的HashMap的key上
    2. HashSet的特点和HashMap对key的特点保持一致
3.  HashSet存储数据无序
4.  HashSet不允许存储重复数据。<span style=color:red;background:yellow>**注意这个重复的定义。**</span>
5.  HashSet允许存储null元素

### HashSet的构造方法

```java
HashSet() 
          构造一个新的空 set，其底层 HashMap 实例的默认初始容量是 16，加载因子是 0.75。 
HashSet(Collection<? extends E> c) 
          构造一个包含指定 collection 中的元素的新 set。 
HashSet(int initialCapacity) 
          构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和默认的加载因子（0.75）。 
HashSet(int initialCapacity, float loadFactor) 
          构造一个新的空 set，其底层 HashMap 实例具有指定的初始容量和指定的加载因子。 
```

### HashSet的API

```JAVA
// ----------HashSet ,    set接口, 没有在Collection的基础上额外定义什么api---------
```

## LinkedHashSet

### LinkedHashSet的特点

1.  LinkedHashSet是HashSet一个子类
2.  LinkedHashSet底层持有一个LinkedHashMap对象
    1. LinkedHashSet的特点和LinkedHashMap的key保持一致
3.  LinkedHashSet存储数据有序
4.  LinkedHashSet 不允许存储重复数据
5.  LinekdHashSet允许存储null
6.  线程不安全

与HashSet唯一的不同：

<span style=color:red;background:yellow>**存储数据有序**</span>

线程安全的Vector,HashTable已经不再使用。

### LinkedHashSet的构造方法

```java
LinkedHashSet() 
  构造一个带默认初始容量 (16) 和加载因子 (0.75) 的新空链接哈希 set。 
LinkedHashSet(Collection<? extends E> c) 
  构造一个与指定 collection 中的元素相同的新链接哈希 set。 
LinkedHashSet(int initialCapacity) 
  构造一个带指定初始容量和默认加载因子 (0.75) 的新空链接哈希 set。 
LinkedHashSet(int initialCapacity, float loadFactor) 
  构造一个带有指定初始容量和加载因子的新空链接哈希 set。 
```

### LinkedHashSet的api

```java
// --LinkedHashSet, HashSet ,    set接口, 没有在Collection的基础上额外定义什么api---------
```

## TreeSet

### TreeSet的特点

1. TreeSet是Set接口的子实现
2. TreeSet底层持有了一个TreeMap对象
   1. TreeSet存储数据的特点和TreeMap的key保持一致
3. TreeSet存储数据大小有序（大小有序  不是存储的顺序）
4. TreeSet不允许存储重复数据: (重复指的是 Comparable接口返回的 是0 ；大小重复)
5. TreeSet不允许存储null
6. 线程不安全

### TreeSet的构造方法

```java
TreeSet();
  构造一个新的空 set，该 set 根据其元素的自然顺序进行排序。 
TreeSet(Collection<? extends E> c);
  构造一个包含指定 collection 元素的新 TreeSet，它按照其元素的自然顺序进行排序。 
TreeSet(Comparator<? super E> comparator); 
  构造一个新的空 TreeSet，它根据指定比较器进行排序。 
TreeSet(SortedSet<E> s); 
  构造一个与指定有序 set 具有相同映射关系和相同排序的新 TreeSet。 
```

### TreeSet的API

```java
// --TreeSet，set接口, 没有在Collection的基础上额外定义什么api---------

NavigableSet<E> subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) 
  返回此 set 的部分视图，其元素范围从 fromElement 到 toElement。
  
SortedSet<E> subSet(E fromElement, E toElement) 
  返回此 set 的部分视图，其元素从 fromElement（包括）到 toElement（不包括）。 
  
SortedSet<E> tailSet(E fromElement) 
  返回此 set 的部分视图，其元素大于等于 fromElement。 
  
NavigableSet<E> tailSet(E fromElement, boolean inclusive) 
  返回此 set 的部分视图，其元素大于（或等于，如果 inclusive 为 true）fromElement。 
```

<span style=color:red;background:yellow>**有序 **</span>

LinkedHashSet （有序的）--》 它的有序，指的是  add 顺序。添加进去的顺序

TreeSet (有序的)-->是根据 Comparable  返回的结果。

<span style=color:red;background:yellow>**重复**</span>

LinkedHashSet  HashSet ：  hashCode  && （equals）

TreeSet：   Comparable 返回0

# 集合类的总结

老师的那个思维导图

允许存储`null`： List HashSet LinkedHashSet

不允许存储`null`: Queue(除了LinkedList)

API ：增删改查 /其他API /遍历API
