> 时间安排
>
> 3个前后端代码
>
> 2/26号晚上把第一个写完
>
> 3/1完成三个开发
>
> 后端要写测试
>
> 3/2写test 准备演示

# UserStory功能设计





### 前后端交互

前端发起JSON请求

```json
{
    "username": "xxx",
    "password": "xxx"
}
```

后端接收请求，给予相应

​	

```json
{
    "code": ,
    "message": "",
    "data": <T>
}
Int String Object
Map<>
var m = new Map<String, Object>();
m.put("id", );
mp
//泛型 把类型当作变量

<T>
```



- 成功

  ```json
  {
      "code": 201,
      "message": "add user",
      "data": {
          "id": 0001,
          "username": "xxx",
          "password": "xxx",
          "creation_date": 2025/2/24,
          "status": "ONLINE",
          "birthday": 2000/07/27
      }
  }
  ```

- 失败

  ```json
  
  {
      "code": 409,
      "message": "Error: add User failed because username already exists",
      "data": null
  }
  ```
  
  

### 前端设计

1. 发送请求
2. 处理响应
   1. 当code为201时成功跳转，取data数据为user对象
   2. 当code为409时给予提示报错，弹窗内容是message

### 后端设计

1. 统一响应报文格式

   1. 封装响应为Result类，该类用来后端响应报文JSON的格式
   2. 成功的时code给201

2. 使用Lombok简化写法

   1. 因为代码中经常出现需要构造函数 getter setter方法的地方 不想手动添加所有方法 通过工具的方式简化后端写法

   2. 引入Lombok依赖

      > ### **1. 在`build.gradle`中添加Lombok依赖**
      >
      > 打开项目的`build.gradle`文件，并在`dependencies`块中添加Lombok的依赖。
      >
      > 以下是一个示例配置：
      >
      > groovy复制
      >
      > ```groovy
      > plugins {
      >     id 'java'
      > }
      > 
      > repositories {
      >     mavenCentral()  // 确保使用Maven Central仓库
      > }
      > 
      > dependencies {
      >     // 添加Lombok依赖
      >     compileOnly 'org.projectlombok:lombok:1.18.28'  // 使用最新版本
      >     annotationProcessor 'org.projectlombok:lombok:1.18.28'
      >     testCompileOnly 'org.projectlombok:lombok:1.18.28'
      >     testAnnotationProcessor 'org.projectlombok:lombok:1.18.28'
      > }
      > ```
      >
      > ### **2. 配置Gradle插件（可选）**
      >
      > 如果你使用的是Gradle 7.x或更高版本，建议使用`java-annotation-processor`插件来支持注解处理器。这可以确保Lombok在构建过程中正确工作。
      >
      > 在`build.gradle`文件中添加以下内容：
      >
      > groovy复制
      >
      > ```groovy
      > plugins {
      >     id 'java'
      >     id 'java-annotation-processor'  // 添加注解处理器插件
      > }
      > ```
      >

   3. 简化相关写法

      > - **`@Data`**
      >   - **功能**：组合注解，包含`@Getter`、`@Setter`、`@ToString`、`@EqualsAndHashCode`和`@RequiredArgsConstructor`。**
      >   - **使用场景**：适用于需要快速生成常用方法的POJO类。
      >
      > - **`@NoArgsConstructor`、`@AllArgsConstructor` 和 `@RequiredArgsConstructor`**
      >   - **功能**：自动生成构造函数。
      >   - `@NoArgsConstructor`：生成无参构造函数。
      >   - `@AllArgsConstructor`：生成包含所有字段的全参构造函数。

​		

## 登录功能

​	路由：`/login`

请求报文

```json
{
    "username": "",
    "password": "",
    "name": ""
}
```

后端处理满足的需求：

1. 区分成功和失败
2. 成功之后要干嘛 
   1. 当前用户状态由 不在线 -》 在线
   2. 返回所有用户信息列表 前端需要这个数据

成功的响应报文

```json
{
    "code": 201,
    "message": ""
    "data":[]
}
```

 失败的报文

1. 失败用409来告诉前端
2. 前端弹出注册页面 提示用户注册（后续需要注册的`/register`）

```json
{
    "code": 409,
    "message": "",
    "data":null
}
```

# S1 注册

### 任务需求

**Story:** As an unregistered user, I want to be able to register as a user with my chosen credentials

(i.e., username and password that are both not empty words) to leverage/use services and

information that are exclusively available to registered users.

**Acceptance Criteria:**

*•* Upon successful user registration, the *users overview* screen (see below) is shown, and the

user is automatically logged in.

*•* Upon failure, an error is displayed, and the user is redirected (back) to the register screen.A register error can be that a user name is already taken.

*•* The creation date of a user is saved to the database record.

*•* Logged-in users can log out and log back into their registered profile.

**Priority:** critical

**Author:** SoPra Assistants

**Estimate:** 4h

> 需求分析：实现注册功能



# S2

# S3

前端提供编辑功能，具体如下：

1. **编辑模式切换**：通过一个按钮切换查看模式和编辑模式。
2. **表单输入**：在编辑模式下，显示表单以允许用户修改 `username` 和 `birthday`。
3. **保存更新**：调用后端的 `PUT /users/{userId}` 接口，更新用户信息。
4. **权限控制**：确保用户只能编辑自己的信息。
5. **重定向和刷新**：更新成功后，重定向到用户详情页面并显示更新后的数据。

更改点：

1. **添加编辑模式和表单**：
   - 添加一个 `isEditing` 状态，用于切换查看模式和编辑模式。
   - 使用 `Form` 组件显示可编辑的表单。
2. **处理编辑和保存逻辑**：
   - 添加 `handleEdit` 函数，用于进入编辑模式并填充表单数据。
   - 添加 `handleSave` 函数，用于调用后端 API 更新用户信息。
3. **权限控制**：
   - 检查当前登录用户的 ID 是否与页面中的用户 ID 一致，确保用户只能编辑自己的信息。
4. **日期格式化**：
   - 使用 `dayjs` 库处理日期格式。
