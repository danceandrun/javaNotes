[TOC]

# 前言

## 学习目标

1. 理解SpringMVC和Servlet之间的关系
2. **熟悉**Controller组件中的Handler方法和URL之间的映射关系的建立
3. **熟悉**Handler方法的返回值响应JSON数据
4. **熟悉**Handler方法接收key-value和JSON数据的方式
5. 理解SpringMVC的核心流程（面试拔高） 😶‍🌫️难点
6. 理解SpringMVC的静态资源处理
7. 理解SpringMVC使用过程中的拦截器
8. 掌握SpringMVC的异常处理

> Spring核心是容器
>
> MVC是开发web应用的架构，怎么将这两个联系起来。

## 前置知识准备

- 抽象类
- ApplicationContext
  - 是容器，可以加载配置类
  - 提供配置类的方式
    - new AnnotationConfigAppllicationContext()

- Servlet阶段URI和Servlet中的方法之间的关系
  - 一个URI只能对应一个Servlet方法
  - 一个Servlet方法可以对应多个URI

- Servlet中如何通过Request获得请求参数
  - QueryString和请求体中的key=value请求参数
  - 请求体中的JSON请求参数
  - 文件：request.getPart
- Servlet中如何通过Response响应JSON字符串
- 注解
- 反射执行方法 method.invoke(instance,args)
- Filter和Listener的执行时机

# SpringMVC介绍

## MVC概念

MVC设计模式的任务是将包含业务数据的模块与显示模块的视图**解耦**。
SpringMVC是在Spring框架的基础上做的，MVC每一层怎样通过Spring处理的，每一层当中怎样注册和管理组件。哪些组件要注册，要取出。

## SpringMVC和JavaEE的比较

SpringMVC出现就是为了解决JavaEE开发的复杂性而提出的。（Rod Johnson）

SpringMVC对请求动作的解耦更加的简单，更加直接。

![image-20230907091721401](.\assets\image-20230907091721401.png)

从而只需要关注方法上的URI就可以处理请求

SpringMVC是通过一个Servlet（DispatcherServlet）来接收全部请求，然后分发到不同的方法上

![Day17-SpringMVC架构](.\assets\Day17-SpringMVC架构.jpg)

## SpringMVC的核心流程

全部的请求都通过`DispatcherServlet`来接收，然后根据请求url分发到不同的`Handler`，`Handler`处理之后响应`ModelAndView`或者`Json`数据

![image-20230907091757237](.\assets\image-20230907091757237.png)

![Day17-AACDSI](.\assets\Day17-AACDSI.jpg)

# SpringMVC的入门案例

1. 引入依赖`spring-webmvc` (spring-web,Spring阶段的依赖也会引入进来)
2. 配置`DispatcherServlet`以及映射（`url-pattern = /`）
   1. 继承AACDSI
   2. 重写方法：`getServletMappings()`
3. 提供配置类初始化 `ApplicationContext` → `WebApplicationContext(getServletContext())` → `AnnotationConfigWebApplicationContext`

`@Controller`增加servlet和其他组件间的联系

三个`congfig`

`ApplicationInitializer`

```JAVA
public class ApplicationInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
    // 提供配置类，初始化容器会加载你提供的配置类
    @Override
    protected Class<?>[] getRootConfigClasses() {
        return new Class[]{RootConfiguration.class};
    }

    @Override
    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{WebConfiguration.class};
    }

    /**
     * DispatcherServlet是通过ServletContext配置的，配置Servlet已经对应的URL-Pattern
     * 这个过程 AACDSI做的，而这个方法就是提供一个url-pattern
     *
     * 配置DispatcherServlet的url-pattern
     * @return
     */
    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }
}
```

`RootConfiguration`

```JAVA
@Configuration
//@ComponentScan(value = "com.cskaoyan.demo2",excludeFilters = @ComponentScan.Filter({Controller.class, EnableWebMvc.class}))
@ComponentScan(value = "com.cskaoyan.demo2",excludeFilters = {@ComponentScan.Filter(type = FilterType.ANNOTATION,value = {Controller.class,EnableWebMvc.class})})
@EnableTransactionManagement
public class RootConfiguration {

    @Bean
    public DataSource dataSource() {
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setDriverClassName("com.mysql.jdbc.Driver");
        dataSource.setUrl("jdbc:mysql://localhost:3306/cskaoyan_market?useUnicode=true&characterEncoding=utf-8");
        dataSource.setUsername("root");
        dataSource.setPassword("123456");
        return dataSource;
    }

    @Bean
    public SqlSessionFactoryBean sqlSessionFactory(DataSource dataSource) {
        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource);
        sqlSessionFactoryBean.setTypeHandlersPackage("com.cskaoyan.demo2.typehandler");
        PageInterceptor pageInterceptor = new PageInterceptor();

        Properties properties = new Properties();
        properties.setProperty("helperDialect", "mysql");
        properties.setProperty("reasonable", "true");
        pageInterceptor.setProperties(properties);
        sqlSessionFactoryBean.setPlugins(pageInterceptor);
        return sqlSessionFactoryBean;
    }

    @Bean
    public MapperScannerConfigurer mapperScannerConfigurer() {
        MapperScannerConfigurer configurer = new MapperScannerConfigurer();
        configurer.setBasePackage("com.cskaoyan.demo2.mapper");
        configurer.setSqlSessionFactoryBeanName("sqlSessionFactory");
        return configurer;
    }

    @Bean
    public PlatformTransactionManager platformTransactionManager(DataSource dataSource) {
        return new DataSourceTransactionManager(dataSource);
    }
}
```

`WebConfiguration`

```JAVA
@EnableWebMvc
@ComponentScan("com.cskaoyan.demo2.controller")
public class WebConfiguration implements WebMvcConfigurer {
}
```

## JavaConfig

> AACDSI → 抽象类 AbstractAnnotationConfigDispatcherServletInitializer

AACDSI实现了接口`WebApplicationInitializer`，这是一个特殊的接口，Tomcat默认使用，它的实现类会在应用程序启动的时候执行对应的`onStartup`方法

1. `onStartup` 就是起点，同时包含了`ServletContext`，也就是可以配置`ApplicationContext`
2. `onStartup` 里做了什么事情？
   1. 创建了一个`WebApplicationContext` 对象，加载了配置类，加载的是 `getRootConfigClasses()`返回的配置类
   2. 获得了`ServletContext`，在`ServletContext`中把`WebApplicationContext`对象放进去了，key为xxx_Root
   3. ![Day17-AACDSI](.\assets\Day17-AACDSI-1694785162346-1.jpg)
   
   4. `@Contrroller` `@EnableWebMvc` 也有组件注册的功能

​		

需要我们在抽象类的子类中去写这两个抽象方法的实现 → 提供自定义的配置类

实现

```java
/**
 * 应用程序启动的入口
 */
public class ApplicationInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
    @Override
    protected Class<?>[] getRootConfigClasses() {
	// 初始化Listener的WebApplicationContext读取的配置类
	// 实际上做的就是这样的事情 new AnnotationConfigWebApplicationContext(RootConfiguration.class);
        return new Class[]{RootConfiguration.class};
    }

    @Override
    protected Class<?>[] getServletConfigClasses() {
      // 初始化DispatcherServlet的WebApplicationContext读取的配置类
      // 实际上做的就是这样的事情 new AnnotationConfigWebApplicationContext(ServletConfiguration.class);
        return new Class[]{ServletConfiguration.class};
    }

    @Override
    protected String[] getServletMappings() {
      // 配置DispatcherServlet的url-pattern → /
        return new String[]{"/"};
    }
}
```

 **配置类初始化**

Spring配置类初始化的`ApplicationContext` 做了什么事情？

- 扫描`com.cskaoyan` 这个包目录，并且排除掉`Controller`

SpringMVC配置类初始化的`ApplicationContext` 做了什么事情？

- 扫描`com.cskaoyan.controller` 这个包目录
- `@EnableWebMvc`

```java
//@Configuration
@ComponentScan("com.cskaoyan.controller")
@EnableWebMvc // mvc:annotation-driven  
// 后面还会做一些和SpringMVC相关的配置 需要实现接口 WebMvcConfigurer，实现接口里的方法就是提供一些额外的配置信息
public class ServletConfiguration implements WebMvcConfigurer {
}
```

```java
@Configuration
@ComponentScan(value = "com.cskaoyan",
        //excludeFilters = {@ComponentScan.Filter(type = FilterType.ANNOTATION,classes = {Controller.class, EnableWebMvc.class})})
        //excludeFilters = {@ComponentScan.Filter(type = FilterType.ANNOTATION,value = {Controller.class, EnableWebMvc.class})}) //classes和value互相替代
        //excludeFilters = {@ComponentScan.Filter(value = {Controller.class, EnableWebMvc.class})})//省略掉了type属性值，其默认值就是FilterType.ANNOTATION
        //excludeFilters = {@ComponentScan.Filter({Controller.class, EnableWebMvc.class})})//省略掉了value= 只有value属性了
        excludeFilters = @ComponentScan.Filter({Controller.class, EnableWebMvc.class}))//省略掉了{} 数组中只有一个值
public class RootConfiguration {
}
```

## 使用

```java
//controller组件中放handler方法，handler方法处理请求
@Controller
public class HelloController {

    @RequestMapping("hello")
    public ModelAndView hello(){
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.setViewName("/jsp/hello.jsp");
        modelAndView.addObject("content", "mvc2");
        return modelAndView;
    }
}
```

## 问题

```JAVA
Q：@EnableWebMvc和WebMvcConfigurer接口能够起到什么功能
A：@EnableWebMvc帮助我们注册了一些组件，WebMvcConfigurer接口提供对数据绑定、json数据、conversion-service、validator等支持，最重要的就是RequestMappingHandlerMapping和RequestMappingHandlerAdapter。
```

```JAVA
Q：我们初始化容器构造Spring环境，Spring容器在Web环境下的具体存在是什么？
A：具体存在仍然是ApplicationContext作为容器，只不过当前是WebApplicationContext
我们在ServletContext下共享WebApplicationContext
```

![Day18-容器中的组件](.\assets\Day18-容器中的组件.jpg)

>为了避免重复的包，需要把RootConfiguration 中的`@Controller` `@EnableWebMvc`两个注解排除掉。如何排除的？
>
>使用`@ComponentScan`的`excludeFilters`属性：
>
>```java
>@ComponentScan(value = "com.cskaoyan",excludeFilters = {@ComponentScan.Filter(classes = {Controller.class, EnableWebMvc.class})})
>```

要理清架构图：

1. Servlet和容器之间的关系是什么
2. 怎么维护这些关系的

# `@RequestMapping`注解的使用

- 请求URL限定
- 窄化请求
- 请求方法限定
- 请求参数限定
- 请求头限定

通过`@RequestMapping`注解的不同属性，实现不同功能上的限定

## `@RequestMapping` 注解的定义

```java
@Target({ElementType.TYPE, ElementType.METHOD})//该注解可以写在类上或方法上
@Retention(RetentionPolicy.RUNTIME)
public @interface RequestMapping {
    // 没用
    String name() default "";
	 // value属性：映射的URL是什么
    @AliasFor("path")
    String[] value() default {};
    @AliasFor("value")
    String[] path() default {};
	 // 请求方法限定
    RequestMethod[] method() default {};
	 // 请求参数限定
    String[] params() default {};
	 // 请求头限定
    String[] headers() default {};
	 // 特定请求头的值的限定：Content-Type
    String[] consumes() default {};
	 // 特定请求头的值的限定：Accept
    String[] produces() default {};
}
```

## URL路径映射 `value`🌟🌟🌟 

<span style='color:yellow;background:red;font-size:文字大小;font-family:字体;'>**SpringMVC这个框架的灵魂是@RequestMapping，@RequestMapping它的灵魂是value属性**</span>

🍃 `value`属性使用注意：

1. 写多个值
2. 写通配符`*`
3. 窄化请求

> `value`属性的特点：如果只用到`value`属性，可以省略不写
>
> 数组：如果数组中只有一个值，可以省略掉`{}`

```java
//映射URL → localhost:8080/hello
@RequestMapping(value={"hello"})
@ResponseBody
// 形参 → 通过形参接收了请求参数
public String hello(String username) {
    String result = "hello " + username;
    // 要响应的值直接返回
    return result; 
}

@RequestMapping("goodbye")
@ResponseBody
public String goodbye(String username) {
    return "goodbye " + username;
}
```

`value`属性的作用：在URL和处理这个URL请求的方法之间**建立映射关系**

```java
String[] value() default {};
```

值的类型是String数组

如果我们通过`value`属性提供了**数组类型的值**：这个数组对应url就可以通过这个方法来处理

写`value`属性的时候，可以使用**通配符`*`**

```java
@Controller
public class UrlMappingController {

    //localhost:8080/hello
    //localhost:8080/hi
    //localhost:8080/nihao
    //@RequestMapping(value = {"hello","hi","nihao"})
    @RequestMapping({"hello","hi","nihao"})
    @ResponseBody
    public String hello() {
        return "hello demo5";
    }
    //localhost:8080/goodbye
    //localhost:8080/goodbyesong
    //localhost:8080/goodbyeligenli
    //localhost:8080/goodbye/ligenli
    //localhost:8080/goodbye/xuejia
    // 可以使用通配符*
    @RequestMapping({"goodbye*","goodbye/*"})
    @ResponseBody
    public String goodbye() {
        return "byebye";
    }
}
```

利用其`value`属性还可以做窄化请求

`/user/create`

`/user/modify`

`/user/remove`

`/user/query`

上面的值都是以`/user`开头的

```java
@Controller
public class UserController {
    
    @RequestMapping("user/query")
    @ResponseBody
    public String query() {
        return "user/query";
    }
    @RequestMapping("user/create")
    @ResponseBody
    public String create() {
        return "user/create";
    }
    @RequestMapping("user/remove")
    @ResponseBody
    public String remove() {
        return "user/remove";
    }
    @RequestMapping("user/modify")
    @ResponseBody
    public String modify() {
        return "user/modify";
    }
}
```

**窄化请求**：**在类上加`@RequestMapping`**

> 该 `Controller`组件中的方法映射的URL＝ 类上的`@RequestMapping` 的value属性值 + 方法上的`@RequestMapping`的value属性值

```java
@Controller
@RequestMapping("user")
public class UserController {

    //@RequestMapping("user/query")
    @RequestMapping("query")
    @ResponseBody
    public String query() {
        return "user/query";
    }
    //@RequestMapping("user/create")
    @RequestMapping("create")
    @ResponseBody
    public String create() {
        return "user/create";
    }
    //@RequestMapping("user/remove")
    @RequestMapping("remove")
    @ResponseBody
    public String remove() {
        return "user/remove";
    }
    //@RequestMapping("user/modify")
    @RequestMapping("modify")
    @ResponseBody
    public String modify() {
        return "user/modify";
    }
}
```

两者之间的`/ `写不写都行，写URL的时候，也不必以` / `开头。

> 但是`servlet`中的`/` 不可以省略

 🏷️开发规范：

通过窄化请求，我们可以去做**解耦**，如果请求做的是某一方面的业务的话，配置其URL的时候给其相同的前缀，并且将其写到同一个`Controller`类（组件）中，在这个类上就可以使用`@RequestMapping`注解做窄化请求。

比如订单相关的业务，我们的方法，处理的url分别是`order/create`、`order/remove`、`order/query`，我们就可以写到同一个`Controller`组件中，比如`OrderController`，在上面增加窄化请求`@RequestMapping("order")`

```java
@Controller
@RequestMapping("order")
public class OrderController{}
```

## 请求方法限定` method`

请求方法限定

> 在Servlet阶段处理`get` 请求，使用Servlet中的`doGet`方法；处理`post` 请求使用Servlet中的`doPost`方法；

如果我们在SpringMVC中处理特定的请求方法的请求，在这里就是用到了`method属性`

```JAVA
RequestMethod[] method() default {};
```

`RequestMethod数组`

⭐ : 可以写单个值，也可以写多个值，如果写多个值的话，多个值之间的关系是`OR`。

比如，下面的代码表示可以处理请求是`GET`或者`POST`。因为一个请求方法不可能同时是多个，所以这里是或的关系。

```JAVA
method = {RequestMethod.GET,RequestMethod.POST}
```

```java
@Controller
@RequestMapping("method")
public class RequestMethodLimitController {
    
    @RequestMapping(value = "get",method = RequestMethod.GET)
    @ResponseBody
    public String methodGet() {
        return "Method GET";
    }
    @RequestMapping(value = "post",method = RequestMethod.POST)
    @ResponseBody
    public String methodPost() {
        return "Method POST";
    }
    @RequestMapping(value = "double",method = {RequestMethod.GET,RequestMethod.POST})
    @ResponseBody
    public String methodDouble() {
        return "Method GET OR Method POST";
    }
}
```

**引申注解**：⭐ 

+ `@GetMapping`
+ `@PostMapping`

这两个注解就是限定了请求方法的`@RequestMapping`

```java
@RequestMapping(
    method = {RequestMethod.GET}
)
public @interface GetMapping {}

@RequestMapping(
    method = {RequestMethod.POST}
)
public @interface PostMapping {}
```

我们可以改造一下我们前面的方法

```java
//@RequestMapping(value = "get",method = RequestMethod.GET)
@GetMapping("get")
@ResponseBody
public String methodGet() {
    return "Method GET";
}
//@RequestMapping(value = "post",method = RequestMethod.POST)
@PostMapping("post")
@ResponseBody
public String methodPost() {
    return "Method POST";
}
```

## 请求参数限定 `params`

这里的请求参数指的是：`key=value&key=value&key=value`这种请求参数，使用`request.getParameter`方法能够获得的这种参数。

出现位置：

1. `queryString`
1. 请求体里

含义：**必须**要携带这里指定的请求参数，如果没有携带则会报错。

```JAVA
String[] params() default {};
```

⭐：值是字符串数组，意味着可以写多个值，写多个值的情况，多个值之间的关系是`and` 

```java
@RequestMapping("params") // @RequestMapping注解的value属性才是窄化请求
@Controller//("params")// Controller注解是组件注册功能的注解，value属性指定的是组件的id
public class ParameterLimitController {

    //localhost:8080/params/login?username=songge&password=niupi
    //params = {"username","password"} 含义：既要携带username这个请求参数，也要携带password
    @RequestMapping(value = "login",params = {"username","password"})
    @ResponseBody
    public String login() {
        return "ok";
    }
}
```

## 请求头限定 `headers`

限定的是请求头的`key`

![image-20230907091955415](.\assets\image-20230907091955415.png)

冒号左侧的部分就是请求头的`key`

> 请求报文有哪些组成部分： 
>
> - 请求行 → URI 协议 方法
> - 请求头
> - （空行）
> - 请求体

仍然使用Postman来构造请求

![image-20230907092020380](.\assets\image-20230907092020380.png)

```JAVA
String[] headers() default {};
```

也是字符串数组，多个值之间的关系也是`and`

```java
@Controller
@RequestMapping("header")
public class HeaderLimitController {

    // 既要携带abc这个请求头，也要携带def这个请求头
    @RequestMapping(value = "limit",headers = {"abc","def"})
    @ResponseBody
    public String headerLimit() {
        return "ok";
    }
}
```

## <span style='color:yellow;background:red;font-size:文字大小;font-family:字体;'>**Con**</span>tent-Type请求头值限定 <span style='color:yellow;background:red;font-size:文字大小;font-family:字体;'>**con**</span>sumes

> consumes：消费者
>
> produces：生产者

限定的是`Content-Type` 这个请求头的值

> 1. 这个请求头的含义：请求携带的正文的类型（请求体）
>
> 2. 语法的格式：`Mime-Type` 也就是 `xxx/xxx`
>
>    比如一个jpg文件：`image/jpeg`
>
>    比如文本：`text/html`
>
>    比如json：`application/json`

```java
@RequestMapping(value = "consumes",consumes = "abc/def")
@ResponseBody
public String contentTypeLimit() {
    return "ok";
}
```

## Ac<span style='color:yellow;background:red;font-size:文字大小;font-family:字体;'>**ce**</span>pt请求头值限定 produ<span style='color:yellow;background:red;font-size:文字大小;font-family:字体;'>**ce**</span>s属性

限定的是`Accept`这个请求头的值 

> 1. 这个请求的含义：客户端希望接收到的服务端响应的正文类型
>
> 2. 语法的格式：`Mime-Type` 也就是 `xxx/xxx`
>
>    比如一个jpg文件：`image/jpeg`
>
>    比如文本：`text/html`
>
>    比如json：`application/json`



![image-20230907092059016](.\assets\image-20230907092059016.png)

```java
@RequestMapping(value = "produces",produces = "application/json")
@ResponseBody
public String acceptLimit(){
    return "ok";
}
```

```java
// 希望接收到正文的charset为utf-8
@RequestMapping(value = "chinese",produces = "text/html;charset=utf-8")
@ResponseBody
public String chinese() {
    return "这是中文";
    //响应这个字符串的是SpringMVC给我们去响应这个字符串，
    // 默认的值，响应头中的Content-Type的值变为了text/html;charset-iso-8859-1
}
```

![image-20230907092123094](.\assets\image-20230907092123094.png)

> 中文乱码问题的解决方案一：
>
> Handler这里如果直接返回字符串，会用到`StringHttpMessageConverter`，默认的charset是ISO-8859-1，会出现中文乱码；
>
> 设置`produces=“application/json”`后会使用`JsonHttpMessageConverter`，默认的字符集是`utf-8`，从而解决乱码问题。
>

拦截器解决不了这个问题，SpringMVC的字符串消息处理里面的默认的charset为iso-8859-1，Filter就算通过response做了设置，但是消息处理器仍然用的还是默认的iso-8859-1。

⭐ `BeanPostProcessor`去修改其默认的字符集

> 一个知识点：
>
> **别人帮你注册了组件，注册的组件里设置了一些默认值，我们还能修改吗？**🏷️ 
>
> 留意`BeanPostProcessor`（通常使用`postProcessAfterInitialization`为了完成一些初始化）
>
> ![image-20230914111842458](.\assets\image-20230914111842458.png)
>
> 这可以作为一个亮点。

## 小结

`@RequestMapping` 注解属性其实就是提供了不同信息，我们获得这些不同的信息，完成了不同的功能

> 通常一个注解最核心（重要）的属性就是其`value`属性，对于`@RequestMapping`注解也是一样的，它的最重要的属性也是`value`属性，我们后续在开发过程中，主要使用的就是其`value`属性
>
> 其他的属性，基本上很少使用，但是呢，你只要是在做SpringMVC的开发，一定会用到`@RequestMapping`注解和其`value`属性

# `Handler`方法的返回值

前面的案例中我们返回值写的都是`String`，我们在这里还有一些其他的返回值

## `ModelAndView`（了解）

比较过时了

主流开发技术：前后端分离，使用`Json`做交互

`ModelAndView`主要是为单体应用服务的，单体应用的话，前端和后端都整合在一个应用程序中

`ModelAndView`主要是给访问前端的视图和数据的，当服务器的这个方法返回了一个`ModelAndView`的话，会访问到前端的内容

举个例子：`hello.jsp`

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>

</body>
</html>
```

长相类似于`html`

现象：在`webapp`目录下放了一个`banner.png`和一个`hello.jsp` 两个文件，访问`banner.png`产生了`404`报错，访问`hello.jsp`是可以正常访问

分析：

- 是否是`DispatcherServlet`作为缺省的`Servlet`处理了`hello.jsp`这个请求呢？ 并不是
- 有没有可能有其他的原因呢？ Tomcat提供了专门处理`jsp`的`Servlet`，`jsp` 本身就是一种`Servlet`
- Tomcat对`jsp`处理本身就是特殊的处理 → `jsp` 文件会被编译`Servlet`

现在想要做一件事情：` localhost:8080/hello?username=xxx` ,发送这个请求能够访问到上面的`hello.jsp`，并且在里面能够输出`hello xxx`

这时候我们就需要使用到`ModelAndView`，`ModelAndView`的使用类似于完形填空，`View`提供的是题干，`Model`提供的题目的序号和答案

```java
@Controller
public class ModelAndViewController {

  @RequestMapping("hello")
  public ModelAndView hello(String username) {// 接收参数的这个方式大家先不用关注
    ModelAndView modelAndView = new ModelAndView();
    // 在ModelAndView中设置它的View，让这个view能够指向hello.jsp这个文件
    modelAndView.setViewName("/hello.jsp");
    // 如果希望在视图文件中显示一些值，通过Model来提供，Model封装的键值对（Map<String,Object>）
    modelAndView.addObject("username", username);
    return modelAndView;
  }
}
```

和前面写的方法的**差别**：

- 返回值写为了 `ModelAndView`
- 在方法上并<span style='color:yellow;background:red;font-size:文字大小;font-family:字体;'>**没有增加@ResponseBody**</span>

还有一种方式也可以返回`ModelAndView`，可以返回`String`，这个`String`字符串作为`ModelAndView`中的`viewName`来使用

```java
@RequestMapping("hello2")
public String hello2(String username, Model model) {// 接收参数的这个方式大家先不用关注
    model.addAttribute("username", username);
    return "/hello.jsp";
}
```

和我们前面返回值为`String`的含义不一样：在方法上并<span style='color:yellow;background:red;font-size:文字大小;font-family:字体;'>**没有增加@ResponseBody**</span>

## `Json`🌟 

核心注解就是`@ResponseBody`

需要做一些准备：

- jackson相关依赖（`jackson-databind`）
- `@EnableWebMvc`
- 方法上（或类上）增加注解`@ResponseBody`

### String（并不建议继续使用了）

后续我们并不直接返回String了，因为这样子写比较繁琐，大家还需要处理字符集问题。返回值为`String`的话，它的字符集默认是`ISO-8859-1`。

### Object（你写啥类型都行）

直接返回集合或引用类型对象就可以了

现在有一个需求：想要返回一个User实例对应的Json字符串的方法

```java
@RequestMapping("json")
@Controller
public class JsonController {

    @RequestMapping("user")
    @ResponseBody
    public User user() {
        User user = new User("张松", "远志", 30);
        return user;
    }
}
```

注解返回User对象就可以了，Jackson会自动的帮我们进行转换， 并且也不需要设置字符集，返回值的中文没有乱码。

### 进一步使用

看一下`@ResponseBody`注解

```java
@Target({ElementType.TYPE, ElementType.METHOD})// 这个注解可以写在类上，也可以写在方法上
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ResponseBody {
}
```

我们前面学过的什么注解，也是可以写在类上，也可以写在方法上：

+ `@RequestMapping`
+ `@Transactional`

<span style='color:yellow;background:red;font-size:文字大小;font-family:字体;'>**@ResponseBody如果写在类上，意味着当前类下所有的方法响应的都是字符串或Json字符串**</span>

```java
@RequestMapping("json")
@Controller
@ResponseBody
public class JsonController {

    @RequestMapping("user")
    //@ResponseBody
    public User user() {
        User user = new User("张松", "远志", 30);
        return user;
    }
}
```

**引申注解：**

 ⭐**`@RestController `= `@Controller `+ `@ResponseBody`**

```java
@RequestMapping("json")
//@Controller
//@ResponseBody
@RestController
public class JsonController {

    @RequestMapping("user")
    //@ResponseBody
    public User user() {
        User user = new User("张松", "远志", 30);

        return user;
    }
}
```

`@RestController`注解在后续的开发过程中非常常用，基本上我们所有的方法响应的都是`Json`。

### 注意事项

不仅仅是这里响应`JSON`，而是在使用任意一个`Json`工具的时候都需要注意的一个点，不管用的是`Jackson`还是`Gson`还是`fastJson`等工具，都需要注意：

<span style='color:yellow;background:red;font-size:文字大小;font-family:字体;'>**引用数据类型类型这个类需要提供：无参构造方法和Getter/Setter方法**</span>

如果没有提供，`Json`转换过程会报错。`vo`的封装是开发过程中非常常规的使用。

```java
@Data
public class BaseRespVo <T>{
    T data;
    String msg;
    int status;
    
    // 可以在vo中增加一些静态方法，方便我们完成一些封装
    public static BaseRespVo ok() {
        BaseRespVo baseRespVo = new BaseRespVo();
        baseRespVo.setMsg("成功");
        baseRespVo.setStatus(200);
        return baseRespVo;
    }
    public static <T> BaseRespVo ok(T data) {
        BaseRespVo<T> baseRespVo = new BaseRespVo();
        baseRespVo.setData(data);
        baseRespVo.setMsg("成功");
        baseRespVo.setStatus(200);
        return baseRespVo;
    }
}
```

```java
@RequestMapping("vo")
public BaseRespVo vo() {
		// "hello vo" 作为BaseRespVo对象中的data的，也可以写其他的Object类型的值
    return BaseRespVo.ok("hello vo");
}
```

> 在使用任何实体类的时候，如果增加了有参构造方法，一定要增加无参构造方法。因为默认生成的无参构造方法在有有参构造时不会提供。

# 形参

形参的接收要归功于 `HandlerAdapter`。

方法的形参：主要做的事情是**接收请求参数** 以及一些其他的信息

- `key=value`形式的请求参数
- `Json`形式的请求参数
- `multipart/form-data`提交文件

繁琐的点：

+ `key = value`如果参数比较多，要依次封装或使用`BeanUtils`这样的工具类，还要做类型处理。

+ `Json`需要手动调用`Jackson`将字符串转换成对象

+ `multipart/form-data`需要获得`inputStream`，手动创建`outputStream`来写入

优化

+ `key = value`：在`Handler`方法的形参上，直接写请求参数
+ `Json`：在`Handler`方法的形参上加一个注解`@RequestBody`,可以使用`String`，也可以使用`Map`
+ `multipart/form-data`：在`Handler`方法的形参上，直接写请求参数

## `key=value`形式的请求参数

1. 基本类型以及对应的包装类、`String`，可以直接接收。条件是：**请求参数名和形参名一致**。SpringMVC提供了类型处理器。

2. 请求参数有数组（相同的`key`等于多个值也就是数组）。形参可以使用对应包装类的数组接收。

3. 日期格式：

   1. 可以用String接收，然后进行日期转换

      ```JAVA
      SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd")
      Date startDate = sdf.parse(start); 
      ```

   2. 可以使用`Date`来接收

      1. 要求：请求参数名和形参名一致。

      2. 默认格式：`yyyy/MM/dd`

      3. 非默认格式需要注解指定

         ```JAVA
         @DateTimeFormat(patttern = "yyyy-MM-dd")
         ```
   
4. `multipart/form-data`：本质也是一种`key = value`。`key`是name。

   1. 引入依赖：`commons-fileupLoad`(会自动引入`commons-io`） 

   2. 注册一个组件  🏷️`mutipartResolver` 🏷️，在`WebConfiguration`配置类中。该组件的名字不可以改成别的。

      ```JAVA
      @EnableWebMvc
      @ComponentScan("com.cskaoyan.demo5.controller")
      public class WebConfiguration implements WebMvcConfigurer {
      
          /**
           * 引入commons-fileupload(io)
           * @return
           */
          @Bean
          public CommonsMultipartResolver multipartResolver() {
              CommonsMultipartResolver resolver = new CommonsMultipartResolver();
              return resolver;
          }
      }
      ```

   3. 直接在参数中写 `MultipartFile file`

      ```JAVA
      @RestController
      @RequestMapping("admin/storage")
      public class AdminStorageController {
      
          @Autowired
          StorageService storageService;
      
          @SneakyThrows
          @RequestMapping("create")
          public BaseRespVo create(MultipartFile file) { 
              // 在Part里能够拿到的信息，通过这个对象也能拿到
              // 提供了一个方法，能够直接保存到指定位置
      
              MarketStorage storage = MarketStorage.builder()
                      .key(randomFileName)
                      .size((int) size)
                      .type(contentType)
                      .name(originalFilename)
                      .url("http://localhost:8080/demo5/storage/fetch/" + randomFileName)
                      .addTime(new Date())
                      .updateTime(new Date())
                      .build();
              storageService.save(storage);
      
              return BaseRespVo.ok(storage);
          }
      }
      ```
      
   
1. （在`Part`可以获得的信息，该对象也可以获得）
   
   ```JAVA
   	String contentType = file.getContentType();//类型
   	long size = file.getSize();//文件大小
   	String originalFilename = file.getOriginalFilename();//文件的原始名
   ```
   
2.  ⭐ 提供了一个方法，能够直接保存到指定位置：`transferTo(File)`
    
   ```JAVA
   	file.transferTo(File file);
   ```
   
   > 如何得到文件的后缀？🏷️ 
   >
   > ```java
   > String suffix = originalFilename.substring(originalFilename.lastIndexOf("."));
   > ```
   
   > 如何随机生成一个名字？🏷️ 
         >
         > ```JAVA
         > String randomName = UUID.randomUUID().toString().replaceAll("-", "");
         > ```
   

接收方式：

形参上使用引用类型对象来接收：将形参作为引用类型的成员变量，要通过`set`方法赋值（自动进行）。

混合接收：封装为两个对象。

例如：

> ```html
> localhost:8080/user/register1?username=songge&password=niupi&age=40
> ```

请求体

```html
username=songge&password=niupi&age=40
```

我们通过形参来接收这些请求参数，创建一个新的工程来做这件事

```java
@RequestMapping("user")
@RestController// = @Controller + @ResponseBody
public class UserController {

    //localhost:8080/user/register1?username=songge&password=niupi&age=40
    @RequestMapping("register1")
    public BaseRespVo register1(String username,String password,String age) {
        System.out.println("username = " + username);
        System.out.println("password = " + password);
        System.out.println("age = " + age);
        return BaseRespVo.ok();
    }
}
```

控制台里打印了对应的内容

```java
username = songge
password = niupi
age = 40
```

说明我们已经接收到了这些请求参数所对应的值，这个过程中我们做的事情：<span style='color:yellow;background:red;font-size:文字大小;font-family:字体;'>**请求参数名和方法的形参名一致**</span>。

SpringMVC给我们去接收这些参数，它帮我们使用`request.getParameter`来接收了，而`request.getParameter`这个方法的返回值，它的类型的是什么？ `String`。

所以我们在这里使用`String`来进行接收，就直接接收到了。

SpringMVC就这？不仅仅就这

### ⭐ `String`、基本类型以及对应的包装类

直接接收：<span style='color:yellow;background:red;font-size:文字大小;font-family:字体;'>**请求参数名和方法的形参名一致**</span>

> 可以使用基本类型或其包装类接收的时候，建议使用包装类来接收：健壮性
>
> 包装类可以为`null`，但是基本类型不能为`null`。

```java
// localhost:8080/user/register2?username=songge&password=niupi&age=40
@RequestMapping("register2")
// public BaseRespVo register2(String username,String password,int age) {}
public BaseRespVo register2(String username,String password,Integer age) {
    System.out.println("username = " + username);
    System.out.println("password = " + password);
    System.out.println("age = " + age);
    return BaseRespVo.ok();
}
```

> 为什么我们在这里可以使用基本类型或对应的包装类来进行接收，`request.getParameter`这个方法的返回值不是`String` 吗？
>
> 上面这个案例我们用`Integer`类型的`age`来接收这个请求参数的过程中发生了这样的事情
>
> - ```java
>   String result = request.getParameter("age");
>   ```
> - SpringMVC给我们提供了类型转换器`converter`，转换器能够将`String`类型的值转换为我们需要`Integer`类型的值
> - SpringMVC不仅仅提供了  `String` → `Integer`这样的类型转换器，这些基本类型以及对应的包装类都有与之对应的类型转换器 （124个）

### Date

我们自己写的日期转换的代码

```java
String string = "2022/12/23";
// 将这个String转换为Date的代码如何写
String pattern = "yyyy/MM/dd"; // 日期的格式
SimpleDateFormat simpleDateFormat = new SimpleDateFormat(pattern);
Date date = simpleDateFormat.parse(string);
```

通过上面到了代码：`String → Date` 的过程中需要`pattern`信息（格式信息）

SpringMVC提供的`String → Date` 的转换器，执行转换的过程中也是需要`pattern` 信息的

- 一种是：采用默认的`pattern` 信息 →` yyyy/MM/dd`
- 另一种：使用`@DateTimeFormat`注解的`pattern`属性指定

> localhost:8080/user/register3?username=songge&password=niupi&age=30&birthday=2022/06/21
>
> - 期望用的是默认的`pattern` → `yyyy/MM/dd`
>
> localhost:8080/user/register4?username=songge&password=niupi&age=30&birthday=2022-06-21
>
> - 期望按照`@DateTimeFormat`注解的`pattern`属性值的格式做转换

注意：<span style='color:yellow;background:red;font-size:文字大小;font-family:字体;'>**请求参数名和方法的形参名一致**</span>

```java
//localhost:8080/user/register3?username=songge&password=niupi&age=30&birthday=2022/06/21
@RequestMapping("register3")
public BaseRespVo register3(String username, String password, Integer age,
                            Date birthday) {
    System.out.println("birthday = " + birthday);
    return BaseRespVo.ok();
}
//localhost:8080/user/register4?username=songge&password=niupi&age=30&birthday=2022-06-21
@RequestMapping("register4")
public BaseRespVo register4(String username,String password,Integer age,
                            @DateTimeFormat(pattern = "yyyy-MM-dd") Date birthday) {
    System.out.println("birthday = " + birthday);
    return BaseRespVo.ok();
}
```

### 数组

可以直接在形参中使用数组来接收

前面能够接收到的这个类型的值，也可以使用对应类型的数组来接收

同一个`key`有多个`value`时就需要数组接收。如下面例子中的`hobbies`&`ids`

```java
//localhost:8080/user/register5?username=songge&password=niupi&age=30
// &hobbies=sing&hobbies=dance&hobbies=rap&ids=1&ids=2&ids=3
@RequestMapping("register5")
public BaseRespVo register5(String username,String password,Integer age,
                            String[] hobbies,Integer[] ids) {
    //String[] hobbies = request.getParameterValues("hobbies");
    System.out.println("hobbies = " + Arrays.asList(hobbies));
    System.out.println("ids = " + Arrays.asList(ids));
    return BaseRespVo.ok();
}
```

> 思考：开发过程中什么场景使用数组？ 多选题
>
> 比如你要查询订单信息：查询未收货 101、已付款201状态的订单信息
>
> 这样的sql语句应该如何写？

```sql
--- 这样写并不好
select * from cskaoyan_order where order_status = 101 or order_status = 201
--- 应该使用的是in语句
select * from cskaoyan_order where order_status in (101,201)
--- 使用mybatis的foreach标签来做拼接
```

### 文件 `MultipartFile`

> localhost:8080/upload/file
>
> localhost:8080/upload/files

这两个请求会提交文件，可以接收到 → 对应JavaEE阶段的`fileupload`

可以接收到文件，并且保存到本地

如果我们要做文件上传，我们的请求如何构造？

通过`form`表单来构造请求，注意：`input`标签的`name`属性就是请求参数名

```html
<form action="/upload/file" enctype="multipart/form-data" method="post">
    <input type="file" name="myfile"/><br>
    <input type="submit"/>
</form>
如果要上传多个文件，input标签中增加一个multiple属性
<form action="/upload/files" enctype="multipart/form-data" method="post">
    <input type="file" multiple name="myfiles"/><br>
    <input type="submit"/>
</form>
```

使用Postman来做请求的构造

![image-20230907092218238](.\assets\image-20230907092218238.png)

需要做的事情

- `commons-io`和`commons-fileupload`依赖

  - ```xml
    <!--引入commons-fileupload时候也会将commons-io引入-->
    <dependency>
        <groupId>commons-fileupload</groupId>
        <artifactId>commons-fileupload</artifactId>
        <version>1.4</version>
    </dependency>
    ```

- 需要向容器中注册一个组件，`multipartResolver`这个组件`id`必须为`multipartResolver`，不能为其他值，SpringMVC在使用这个组件的时候`applicationContext.getBean("multipartResolver")`

  - 可以在`xml`中注册，也可以在配置类中注册

  - ```JAVA
    @Configuration
    public class MvcConfiguration {
        // 组件id一定要是multipartResolver
        @Bean("multipartResolver")
        public CommonsMultipartResolver multipartResolver() {
            CommonsMultipartResolver commonsMultipartResolver = new CommonsMultipartResolver();
            // commonsMultipartResolver.set 可以使用其set方法做一些设置
            return commonsMultipartResolver;
        }
    }
    ```

- 方法的形参中使用`MultipartFile`来接收

注意：<span style='color:yellow;background:red;font-size:文字大小;font-family:字体;'>**请求参数名和方法的形参名一致**</span>

```java
@RestController
@RequestMapping("upload")
public class UploadController {

    @RequestMapping("file")
    public BaseRespVo file(MultipartFile myfile) {
        return BaseRespVo.ok();
    }
}
```

接收到`MultipartFile`，我们能够做什么事情，取决于`MultipartFile` 给我们提供了什么方法？

| 方法名                                                       | 描述                                                         | 返回值   |
| ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| `getOriginFileName()`                                        | 获得上传时的文件名                                           | `String` |
| `getContentType()`                                           | 获得上传的文件的正文类型，比如上传`banner.png`，正文类型就是`image/png` | `String` |
| `getName()`                                                  | 获得是请求参数名（没啥用）                                   | `String` |
| `getSize()`                                                  | 获得文件大小                                                 | `long`   |
| <span style='color:yellow;background:red;font-size:文字大小;font-family:字体;'>**transferTo(File)**</span> | 提供的参数是`File`类型的值，`File`提供的保存位置及文件名，就可以保存这个文件 | `void`   |

```java
@RequestMapping("file")
public BaseRespVo file(MultipartFile myfile) {
    String name = myfile.getName(); // myfile
    String originalFilename = myfile.getOriginalFilename(); //如果上传的是banner.png → banner.png
    String contentType = myfile.getContentType(); // image/png
    long size = myfile.getSize();
    // 比如我们要保存到D:\tmp路径下，保存的文件名叫banner.png ，我们就要提供一个这样的File
    //File file = new File("D:\\tmp\\banner.png");
    //File file = new File("D:\\tmp\\","banner.png");
    // 保存时以原始的文件名保存，如果上传同名文件会覆盖 → JavaEE  hashcode和uuid
    File file = new File("D:\\tmp\\",originalFilename);
    try {
        myfile.transferTo(file);
    } catch (IOException e) {
        e.printStackTrace();
    }
    return BaseRespVo.ok();
}
```

也可以上传多个文件，使用数组来接收

```java
private void uploadSingleFile(MultipartFile myfile) {
    String name = myfile.getName(); // myfile
    String originalFilename = myfile.getOriginalFilename(); //如果上传的是banner.png → banner.png
    String contentType = myfile.getContentType(); // image/png
    long size = myfile.getSize();
    // 比如我们要保存到D:\tmp路径下，保存的文件名叫banner.png ，我们就要提供一个这样的File
    //File file = new File("D:\\tmp\\banner.png");
    //File file = new File("D:\\tmp\\","banner.png");
    // 保存时以原始的文件名保存，如果上传同名文件会覆盖 → JavaEE  hashcode和uuid
    File file = new File("D:\\tmp\\",originalFilename);
    try {
        myfile.transferTo(file);
    } catch (IOException e) {
        e.printStackTrace();
    }
}

@RequestMapping("files")
public BaseRespVo files(MultipartFile[] myfiles) {
    for (MultipartFile myfile : myfiles) {
        uploadSingleFile(myfile);
    }
    return BaseRespVo.ok();
}
```

###  ⭐ 使用引用类型接收

仍然是上面的这些请求，上面这些请求，它的请求参数，是放在方法的形参中。

使用引用类型的话，将接收到的形参，封装为一个引用类型对象，这个引用类型的对象的成员变量封装的就是这些形参的值。

> localhost:8080/user/register6?username=abc&password=niupi&age=30&hobbies=sing&hobbies=dance&hobbies=rap&ids=1&ids=2&ids=3&birthday=2022-06-21

上面这个请求如果要使用形参来接收，我们的方法如何来写？

```java
//localhost:8080/user/register6?username=abc&password=niupi&age=30
// &hobbies=sing&hobbies=dance&hobbies=rap&ids=1&ids=2&ids=3
// &birthday=2022-06-21
@RequestMapping("register6")
public BaseRespVo register6(String username,String password,Integer age,
                            String[] hobbies,Integer[] ids,
                            @DateTimeFormat(pattern = "yyyy-MM-dd") Date birthday) {
    return BaseRespVo.ok();
}
```

将这个形参变为一个实体类的成员变量，形参这里写这个实体类的实例

```java
@Data
public class User {
    String username;
    String password;
    Integer age;

    String[] hobbies;
    Integer[] ids;

    @DateTimeFormat(pattern = "yyyy-MM-dd")
    Date birthday;

}
```

```java
@RequestMapping("register6")
public BaseRespVo register6(User user) {
    return BaseRespVo.ok();
}
```

SpringMVC帮助我们做的封装，当它发现方法的形参是一个引用类型的实例的时候，会根据这个类中的成员变量的名称和类型去接收请求参数的值，根据名称获得值，**根据类型来做格式转换，通过`set`方法做的封装**。

### 思考

我们在后续的开发中，使用哪些形式来接收：

- 使用形参直接接收：如果参数比较少，直接使用形参
- 使用引用类型的对象来接收：参数比较多；在多个请求中都使用了相同的请求参数
- 混合接收：有些参数就用一次或者用的次数比较少（直接接收），有的参数用了多次（封装为实体类）

比如我们要做一个查询

> localhost:8080/user/query?username=song&sort=add_time&order=asc&page=1&limit=10
>
> 请求参数username：根据这个值做username的模糊查询
>
> 请求参数page、limit：根据这两个值做分页，page是页码，limit是这一页的数据量
>
> 请求参数sort、order：做结果排序，根据添加时间做升序排序

page、limit、sort、order在做其他的查询时也是会使用的，为了这些参数的复用，我们就可以封装为实体类

```java
//localhost:8080/user/query?username=song&sort=add_time&order=asc&page=1&limit=10
@RequestMapping("query")
public BaseRespVo query(String username, CommonParameter commonParameter) {
    return BaseRespVo.ok();
}

@Data
public class CommonParameter {
    String sort;
	String order;
	Integer page;
	Integer limit;
	
}
```

## `Json`请求参数

🏷️ 如果说一个请求携带`Json`请求参数，这个请求具有什么样的特点？

- 请求方法：`POST`
- 正文类型`Content-Type`：`application/json`
- 数据是`Json`字符串

如果构造请求是`Json`请求参数：ajax、axios

可以使用Postman来构造请求

![image-20230907092255235](.\assets\image-20230907092255235.png)

`Json`请求参数仍然是在形参中进行接收，可以使用以下几种类型来接收

- `String`
- 引用类型对象
- `Map`

形参前需要增加一个注解`@RequestBody`

> `@RequestBody`和`@ResponseBody`这两个注解都是和`Json`打交道的时候使用的注解
>
> 接收的时候用的是`@RequestBody`
>
> 响应的时候用的是`@ResponseBody`

为什么我们可以使用引用类型对象、`Map`来进行接收？

我们本身接收到的值是 `String`，`Jackson` 识别了我们方法的形参类型，将字符串转换为对应的类型的形参。

```java
@RestController
@RequestMapping("user")
public class UserController {
    /**
     * String
     * {"username":"songge","password":"niupi","birthday":"2022-07-12"}
     * @return
     */
    @RequestMapping("login")
    public BaseRespVo login(@RequestBody String result) {
        System.out.println(result);
        return BaseRespVo.ok();
    }

    /**
     * 引用类型对象
     * {"username":"songge","password":"niupi","age":50,"birthday":"1995-03-19"}
     * @return
     */
    @RequestMapping("login2")
    public BaseRespVo login2(@RequestBody User user) {
        System.out.println(user);
        return BaseRespVo.ok();
    }

    /**
     * Map → LinkedHashMap
     * {"username":"songge","password":"niupi","age":50,"birthday":"1995-03-19"}
     * @return
     */
    @RequestMapping("login3")
    public BaseRespVo login3(@RequestBody Map map) {
        System.out.println(map);
        return BaseRespVo.ok();
    }
}
```

如果要指定日期格式：`@JsonFormat(pattern = "yyyy-MM-dd")`

1. 接收`Json`字符串的时候，将其变量的类型定义为`Date`
2. ` @DateTimeFormat(pattern = "yyyy-MM-dd")` → 这个是不行，这个注解是给`Key-value`这种请求参数使用的
3.  我们接收`Json`数据的过程中` String → user`对象，这个过程完全是靠`Json`工具类 → 可以做`Date`格式的指定

```java
@NoArgsConstructor
@Data
public class User {

    private String username;
    private String password;
    private Integer age;
    // 提供的Json数据birthday这个key对应的值就是String
    // 这个字符串有点像Date的一个pattern → yyyy-MM-dd
    //private String birthday;
    // 接收Json字符串的时候，将其变量的类型定义为Date
    //@DateTimeFormat(pattern = "yyyy-MM-dd") → 这个是不行，这个注解是给Key-value这种请求参数使用的
    // 我们接收Json数据的过程中 String → user对象，这个过程完全是靠Json工具类 → 可以做Date格式的指定
    @JsonFormat(pattern = "yyyy-MM-dd")// 影响接收过程中的日期指定；也影响响应过程中的日期格式
    private Date birthday;
}
```

思考：我们在开发的过程中我们采用上面3种方式中的哪种方式？

- `String` 不使用，因为接收到`String`类型的值，你还需要额外处理，过程就繁琐了
- 引用类型对象：可以使用。参数比较多，封装比较复杂，你需要确切的参数类型的时候，使用的场景比较多
- `Map`：可以使用。如果你的参数比较少，也比较简单，就直接使用`Map`就行了
  - `{“username”:"songge"}`

## 其他信息

### `HttpServletRequest`、`HttpServletResponse`

可以直接写在形参中， `Controller`组件中的方法上都是可以增加`HttpServletRequest`和`HttpServletResponse`这两个形参的。其他信息通过这两个形参获得，因为Spring本质是对两者的封装。

不太建议，除非万不得已。

```java
// Controller组件中的方法上都是可以增加HttpServletRequest和HttpServletResponse这两个形参的
@RequestMapping("reqAndResp")
public BaseRespVo reqAndResp(HttpServletRequest request, HttpServletResponse response) {
    return BaseRespVo.ok();
}
```

### `Cookie`和`Session`

需要通过`request`来获得

```java
//localhost:8080/cookies
@RequestMapping("cookies")
public BaseRespVo cookies(HttpServletRequest request) {
    Cookie[] cookies = request.getCookies();
    for (Cookie cookie : cookies) {
        System.out.println(cookie.getName() + " = " + cookie.getValue());
    }
    return BaseRespVo.ok();
}
```

通过浏览器构造Cookie

![image-20230912090306142](.\assets\image-20230912090306142.png)

请求头里有`Cookie`

也可以通过Postman构造Cookie → 构造Postman的请求头就可以了

![image-20230912090329018](.\assets\image-20230912090329018.png)

可以通过`request`来获得，也可以直接在形参中写`HttpSession`

http://localhost:8080/session1?username=xuejia

http://localhost:8080/session2

这两个请求，

session1，获得`session`，向`session`中放入数据

session2，获得`session`，从`session`中取出数据

通过两种不同的方式来获得`session`

```java
//http://localhost:8080/session1?username=xuejia
@RequestMapping("session1")
public BaseRespVo session1(HttpServletRequest request,String username) {
    HttpSession session = request.getSession();
    session.setAttribute("username", username);
    return BaseRespVo.ok();
}
//http://localhost:8080/session2
@RequestMapping("session2")
public BaseRespVo session2(HttpSession session) {
    Object username = session.getAttribute("username");
    System.out.println("username = " + username);
    return BaseRespVo.ok(username);
}
```

# `RESTful` 风格接口

`REST`  → ` Representational State Transfer`

 **表述性状态传递**

通过请求（报文）能够提供一些对应的信息，提供给服务器。也就是通过一些方法来获得对应的信息。

**其实就是对`Request`的封装**

> REST（Representational State Transfer）是一种网络应用程序设计风格，它是一种通过HTTP协议进行通信的软件架构风格。RESTful风格接口是符合REST原则的应用程序接口设计，它使用标准的HTTP方法（如GET、POST、PUT、DELETE）进行操作资源，而不需要额外的操作或协议。
>
> 以下是一些RESTful接口的主要特征：
>
> 1. **基于资源（Resource-Based）：** RESTful接口将每个数据或服务都视为一个资源，每个资源都有一个唯一的标识符（通常是URL）。
>
> 2. **使用标准的HTTP方法：** RESTful接口使用标准的HTTP方法来执行操作。例如，GET用于获取资源，POST用于创建新资源，PUT用于更新资源，DELETE用于删除资源。
>
> 3. **状态无关（Stateless）：** 每个请求从客户端到服务器都必须包含所有信息，服务器不应存储关于客户端状态的任何信息。每个请求都应是独立的，服务器不应依赖于之前的请求。
>
> 4. **表示层状态转化（Representation State Transfer）：** 资源的状态以及资源之间的转换通过表示（通常是JSON或XML）传递。客户端通过获取、修改和传递资源的表示来实现状态转化。
>
> 5. **统一接口：** RESTful接口的设计应该是统一的，以简化系统架构，并使不同部分之间的交互更加可预测和可理解。
>
> 6. **可缓存性：** 对于可缓存的资源，服务器可以标记响应为可缓存，以提高性能。
>
> 使用RESTful风格的接口有助于实现分布式系统的松耦合性，提高系统的可伸缩性和可维护性。这种设计风格已经成为许多现代Web应用程序的标准。

过去使用RESTful风格接口的时候，比如在做user的增删改查场景下，请求URL都是`/user`

> - `/user` 查询 `GET`
> - `/user` 删除 `DELETE`
> - `/user` 新增 `PUT`
> - `/user` 修改 `POST`
>
> 请求URL都是user，我们可以知道做的是user的相关业务，我们还需要一些信息**辅助我们去判断**到底做的新增还是查询还是删除还是修改，通过请求方法的不同，可以做出不同操作的判断

当前的主流我们并不这样做了，主流的请求方法其实就是`GET/POST`，当前我们说`RESTful`的时候，通过包含一个信息，你能够使用`JSON`做数据交互：`@RequestBody`、`@ResponseBody`。

而我们当前定义接口的URL，**通过URL的不同区分不同的操作**

> -  `/user/query` 查询 
> - `/user/remove` 删除 
> -  `/user/create` 新增 
> -  `/user/modify` 修改 

另外我们还可以获得一些其他的信息

- 请求URL的信息 → `@PathVariable` ⭐ 
- 请求参数信息 → `@RequestParam`
- 请求头信息 → `@RequestHeader`
- `Cookie` 信息 → `@CookieValue`
- `Session`信息 → `@SessionAttribute`

能够获得这样的信息，获得的这些信息是放在方法的形参中，使用不同的注解来区分获得的不同的信息。

## ⭐ `@PathVariable`

`@PathVariable` ：获得请求`URL` 的一部分值 。

在`@RequestMapping` 的`value` 属性写占位符`{}`；获得指定占位符位置的值给到所对应的形参，形参通过注解接收指定占位符位置的值。

> 占位符：placeholder

```java
//localhost:8080/path/songge

// 通过这个注解，就可以把一部分请求参数写到URL中，比如豆瓣、CSDN
@RequestMapping("path/{username}")
public BaseRespVo path(@PathVariable("username")String name) {
    System.out.println("name = " + name);
    return BaseRespVo.ok();
}
```

## `@RequestParam`

不写这个注解也可以获得参数，写了该注解，如果请求参数没有对应的值会报错。

//`@RequestParam` → 开发过程中基本不用，直接使用形参名
// 形参通过这个注解获得指定请求参数，如果使用了这个注解，就**一定要携带**对应的请求参数

```java
// localhost:8080/param?username=songge&password=niupi

@RequestMapping("param")
public BaseRespVo param(@RequestParam("username")String usernamea,
                        @RequestParam("password")String passwordb) {
    return BaseRespVo.ok();
}
```

## `@RequestHeader`

比如要获得`Accept`这个请求和`Host`这个请求头的值，可以使用字符串或字符串数组来接收 。

```JAVA
Accept :text/html,application/json;q=0.9
```

 如果使用数组来接收，其实就是将字符串通过逗号分隔为数组(split)， 形参通过这个注解获得指定请求头的值。

```java
@RequestMapping("header")
public BaseRespVo header(@RequestHeader("Accept")String[] accept,
                         @RequestHeader("Host")String host) {
    System.out.println(Arrays.asList(accept));
    System.out.println(host);
    return BaseRespVo.ok();
}
```

## `@CookieValue`

`@CookieValue`
形参通过这个注解获得指定`Cookie`的值，根据`key`获得`value`
比如构造的`Cookie`是这样的 

```JAVA
Cookie:songge=yuanzhi;ligenli=tianming;xuejia=qiezi
```

相较于前面使用Cookie的话（要通过request获得Cookies数组，然后通过遍历获得key对应的值），要方便的多

```java
@RequestMapping("cookie")
public BaseRespVo cookie(@CookieValue("songge")String value) {
    System.out.println(value);
    return BaseRespVo.ok();
}
```

## `@SessionAttribute`

// 形参通过这个注解获得指定`Session`的值，根据`key`获得`value`
// 比如我向`session`中放入一个`key=username`的值，我们可以直接取出`username`对应的值

```java
@RequestMapping("session")
public BaseRespVo session(@SessionAttribute("username")String username) {
    return BaseRespVo.ok();
}
//localhost:8080/put/xuejia
@RequestMapping("put/{username}")
public BaseRespVo sessionPut(@PathVariable("username")String username, HttpSession session) {
    session.setAttribute("username",username);
    return BaseRespVo.ok();
}
```

# SpringMVC使用小结

是对JavaEE繁琐过程的封装

![Day18-SpringMVC使用梳理](.\assets\Day18-SpringMVC使用梳理.jpg)

# SpringMVC核心流程（难）

> 阅读参考：
>
> + [饿了么二面：说说Spring MVC的处理流程？ (qq.com)](https://mp.weixin.qq.com/s/6n6whvAvBeHEsaq3eARVOg)

前面的学习过程中，我们产生一些共识：

- `DispatcherServlet` 处理几乎全部请求
  - jsp有自身的servlet所以不会找缺省的servlet
  - 查看tomcat的web.xml

- `Controller` 组件中的方法处理请求，这也是我们主要开发的内容

应用程序启动的时候发生了什么？

需要设置ROOT的原因，为了启动的时候初始化一些东西。比如DataSource。

发送请求的时候发生了什么？

## `DispatcherServlet`和 `ApplicationContext` 的关系

是包含关系：`DispatcherServlet`包含 `ApplicationContext` 

![image-20230915095236855](E:\0.王道训练营\3.我的Daily笔记\3.JavaEE&SpringFramework\Part2\assets\image-20230915095236855.png)

为什么我们去开发`Controller` 组件中的方法就可以了？

> 😶‍🌫️ 方法是哪里的？
>
> 存在于`Controller`组件中。`Controller`是Handler的一种实现方式。
>
>  😶‍🌫️`Controller` 组件放在哪里？从哪里能够获得`Controller` 组件？
>
> 容器中 ，容器就是`ApplicationContext`。
>
> 😶‍🌫️ 在哪里执行到这些方法？
>
> 当我们发送请求的时候，会执行到这些方法；当我们发送请求的时候，`DispatcherServlet` 处理几乎全部的请求， `DispatcherServlet `→ 方法。

![image-20230912090421675](.\assets\image-20230912090421675.png)

如何找到这些方法，找到这些方法的过程中发生了什么？

<span style='color:yellow;background:red;font-size:文字大小;font-family:字体;'>**Handler**</span>：处理器，method1、method2、method3其实就是处理器，处理我们的请求，也称之为<font color='red'>**HandlerMethod**</font>（Handler方法）

小结论：`DispatcherServlet` 如果能够找到`ApplicationContext`（容器），就可以执行到容器中的`Controller`组件中`Handler`方法。

![image-20230912090506024](.\assets\image-20230912090506024.png)

接下来考虑的问题，**`DispatcherServlet`如何和`ApplicationContext`建立联系？**

可否在`DispatcherServlet`中增加成员变量叫做`ApplicationContext`可以不？可以。

SpringMVC是这样子做：`DispatcherServlet`的父类（`FrameworkServlet`）中增加了成员变量`（Web）ApplicationContext`，如果这个父类中提供了`getWebApplicationContext`这个方法的话，`DispatcherServlet`可以获得`ApplicationContext`。

```java
public abstract class FrameworkServlet {
    private WebApplicationContext webApplicationContext;
    @Nullable
    public final WebApplicationContext getWebApplicationContext() {
        return this.webApplicationContext;
    }
}
public class DispatcherServlet extends FrameworkServlet {}
```

`WebApplicationContext`是SpringMVC阶段我们使用的容器，也是`ApplicationContext`的子接口，`ApplicationContext` 提供的功能，`WebApplicationContext` 全部都有。里面还有一个额外的方法`getServletContext`；通过`ServletContext`可以和`Servlet` 共享数据，而我们这里的`Servlet`只有 `DispatcherServlet`。

也就是：<span style='color:yellow;background:red;font-size:文字大小;font-family:字体;'>**WebApplicationContext和DispatcherServlet可以通过ServletContext共享数据**</span>

```java
public interface WebApplicationContext extends ApplicationContext {

    @Nullable
    ServletContext getServletContext();
}
```

![image-20230912090533085](.\assets\image-20230912090533085.png)

![image-20230915100249085](.\assets\image-20230915100249085.png)

`DispatcherServlet`使用的`WebApplicationContext`是**什么时候初始化的？**

> 查看“onStartup”方法

容器何时初始化的，也就`WebApplicationContext`的实例是何时生成的，作为`DispatcherServlet`的成员变量？

> Servlet工作的方法是service方法，WebApplicationContext要在service方法执行之前完成初始化
>
> - Listener → contextInitialized
> - Servlet的生命周期的init方法
>
> SpringMVC是采用上面的哪种方式？
>
> 我们前面：2。也可以1,2都用

如果既使用Listener，又使用Servlet的init方法，这个过程如何维护的？

SpringMVC给我们提供了一个Listener → `ContextLoaderListener` 。初始化了一个`WebApplicationContext`，并且给它放到了`ServletContext` 中

```java
public class ContextLoaderListener extends ContextLoader implements ServletContextListener {
    public void contextInitialized(ServletContextEvent event) {
        this.initWebApplicationContext(event.getServletContext());
    }
}
```

执行完Listener

![image-20230912090556042](.\assets\image-20230912090556042.png)

接下来 要执行 `DispatcherServlet` 的生命周期的`init` 方法

`DispatcherServlet` 自己会初始化一个`WebApplicationContext`

`DispatcherServlet`在执行`init`方法的过程中，从`ServletContext`里根据`xxx_ROOT`这个`key`获得`WebApplicationContext`，作为`DispatcherServlet`初始化的`WebApplicationContext`的成员变量

![image-20230912090620549](.\assets\image-20230912090620549.png)

结论：`DispatcherServlet`它总是和黄色（大）的这`WebApplicationContext`做交互，`DispatcherServlet`可以使用到橙色（小）的`WebApplicationContext`，只是要通过黄色（大）的`WebApplicationContext` 。我们可以粗暴的认为只有一个`WebApplicationContext`（黄色大）

## Handler的分发

发送请求的时候如何执行到对应的方法？

大家可以找指定位置的原图查看更清晰一些

![image-20230912090645589](.\assets\image-20230912090645589.png)

通过`DispatcherServlet`的`doGet/doPost`方法作为入口，最终执行到`doDispatch`方法，这个方法是最核心的方法。

> 找方法的快捷键：CTRL + F12

 🏷️在`doDispatch`方法中，执行`getHandlerMapping`方法，根据`URL`和方法之间的关系（`@RequestMapping`注解维护的），通过当前请求的`URL`找到对应的`HandlerMethod`（也就是执行反射的一个依据）。

 🏷️接着在`doDispatch`方法中，执行`getHandlerAdapter`，这个是根据上面`getHandlerMapping`找到与之对应的适配器，
找到适配器之后，执行适配器的`handle`方法，执行该方法的话会封装`Object[] args`(执行反射时提供的参数)，并且会通过反射的方式（`method.invoke`）执行到对应的`Handler`方法。

![image-20230912090704463](.\assets\image-20230912090704463.png)

## 配置的分析

> 抽象类的特点是啥，如果里面有抽象方法我们需要是实现其抽象方法
>
> 使用抽象类的时候，通常是这样的一个场景
>
> - 使用过程中会使用到其非抽象方法
> - 非抽象方法里会调用到抽象方法
> - 我们提供其抽象方法的具体的实现
>

这个抽象类中有一个核心的方法，这个抽象类实现了一个接口

```java
public interface WebApplicationInitializer {
    void onStartup(ServletContext var1) throws ServletException;
}
```

这个`onStartup` 方法是`AbstractAnnotationConfigDispatcherServletInitializer`中的核心方法

Tomcat在启动的过程中会做一件事情，扫描你所有的类，检查是否有实现`WebApplicationInitializer`接口的类，如果有实现这个接口的类，就会执行其`onStartup`方法

这个`onStartup`方法就是应用程序的启动方法

`onStartup`方法是一个非抽象的方法

- 初始化`Listener`，初始化一个`WebApplicationContext` 放在 `ServletContext` 中
  - 这个`WebApplicationContext` 加载的不是xml文件，而是配置类
  - 配置类的信息通过方法提供 → `getRootConfigClasses` 方法
  - `getRootConfigClasses` 方法是一个抽象方法
- 初始化 `DispatcherServlet` ，初始化一个 `WebApplicationContext`
  - 这个 `WebApplicationContext` 加载的不是xml文件，而是配置类
  - 配置类的信息通过方法提供 → `getServletConfigClasses` 方法
  - `getServletConfigClasses` 这个方法也是一个抽象方法

需要我们在抽象类的子类中去写这两个抽象方法的实现 → 提供自定义的配置类

```java
public void onStartup(ServletContext servletContext) throws ServletException {
    super.onStartup(servletContext);// 初始化Listener → 初始化一个WebApplicationContext放在ServletContext中
    this.registerDispatcherServlet(servletContext);// 注册DispatcherServlet
}
```

```xml
public void onStartup(ServletContext servletContext) throws ServletException {
    this.registerContextLoaderListener(servletContext);
}
```

```java
protected void registerDispatcherServlet(ServletContext servletContext) {
    
    WebApplicationContext servletAppContext = this.createServletApplicationContext();
}
```

# 静态资源处理

我们为什么需要做静态资源处理

JavaEE阶段如果将图片放在`webapp`目录，它会编译到web资源根目录，图片能访问到；应用程序整合SpringMVC之后，放在web资源根目录的图片访问不到了，原因是什么？

- JavaEE阶段，缺省的servlet是`default` → 这个缺省的servlet做的事情就是根据请求找目录下的静态资源

  ![image-20230915141816199](.\assets\image-20230915141816199.png)

- SpringMVC这里，缺省的`Servlet`是`DispatcherServlet` → `localhost:8080/banner.png`找的是`DispatcherServlet`而不是default

如果我们提供了能够处理`banner.png`这样的`Handler`，我们就能够处理静态资源。

- SpringMVC有提供对应的类，需要我们自己来配置
  - 自己写的Handler代码可以复用，主要提供的特殊点是静态资源路径和映射

  - 如下代码：注意如何获得文件名字的
  
  - ```JAVA
        @RequestMapping("fetch/*")
        public void fetch(HttpServletRequest request, HttpServletResponse response) throws IOException {
            String requestURI = request.getRequestURI();
            String image = requestURI.substring(requestURI.lastIndexOf("/") + 1);
            File file = new File(IMAGE_DIR, image);
            FileInputStream inputStream = new FileInputStream(file);
            ServletOutputStream outputStream = response.getOutputStream();
            byte[] bytes = new byte[1024];
            int len = 0;
            while ((len = inputStream.read(bytes)) != -1){
                outputStream.write(bytes,0,len);
            }
            inputStream.close();
        }
    ```
  
- 提供的是`ResourceHandler `(接口`WebMvcConfigurer`提供)
  
  - 做的事情
  
    - 处理静态资源
    - 配置其映射范围
  
  - 语法：
  
    - `** `代表多级任意url
    - 文件路径的语法
  
    + ⭐ 本地文件路径 `file : 文件路径` 
  
    + 类加载路径 `classpath：文件路径`
  
    + web资源根路径 `/ 文件路径`
  

```java
@Override
public void addResourceHandlers(ResourceHandlerRegistry registry) {
    // 注册ResourceHandler使用ResourceHandlerRegistry
    // addResourceHandler配置ResourceHandler的映射范围
    // addResourceLocations告知当前ResourceHandler你的资源文件处于什么位置
    // ** 代表多级任意url
    // localhost:8080/pic/banner.png
    // localhost:8080/pic/dlrb.jpg
    // location:
    // 1. / web资源路径
    // 2. classpath:/  类加载路径
    // 3. file:文件路径/  文件路径 → 建议（要求）使用的路径
    registry.addResourceHandler("/pic/**").addResourceLocations("/");
    registry.addResourceHandler("/pic2/**").addResourceLocations("classpath:/");
    registry.addResourceHandler("/pic3/**").addResourceLocations("file:D:/tmp/");
}
```

该方法来源于`WebMvcConfigurer`接口，如果你实现里面的方法，它就会自动生效。

 🏷️`location`写的时候注意：最后的位置`/`不要漏掉

**访问静态资源需要构造的URL**： mapping映射的url这部分值 + 静态资源相对于location的位置

![image-20230912090758002](.\assets\image-20230912090758002.png)

根据上面的配置能否访问到logo.png ？ 可以

> localhost:8080/pic3/a/e/logo.png

建议大家使用**文件路径**：后面我们使用SpringBoot应用 → 应用程序打包的时候是jar包

# Filter和HandlerInterceptor

起到拦截器功能的

## `Filter`

Filter就是JavaEE阶段的Filter → 实现Filter接口 → `doFilter`。

Filter在SpringMVC阶段仍然是可以使用的，Filter和SpringMVC之间的关系是什么样的关系？

本质上就是Filter和Servlet之间的关系，执行SpringMVC的核心`DispatcherServlet`的`doDispatch`方法之前先去执行的是`Filter`的`doFilter`方法。

在SpringMVC的过程中使用`Filter`，并不是直接使用`Filter`接口，因为直接使用有可能导致`Filter`里的`doFilter`方法执行多次，这是由于JAVAEE容器，比如Tomcat存在的问题导致的。

SpringMVC给我们提供了一个抽象类`OncePerRequestFilter` 对`doFilter`进行了封装。

该类实现了Filter接口里面包含了`doFilter`方法的实现（非抽象方法），它在里面调用了一个抽象方法`doFilterInternal`，它实现的这个`doFilter`保证了`doFilterInternal`这个方法只会执行一次。

如果要提供拦截器，做一些业务的话，业务代码写在`OncePerRequestFilter`的`doFilterInternal`

```java
public class CustomFilter extends OncePerRequestFilter {
    // 能够保证doFilterInternal这个方法在这次请求中只会执行一次
    @Override
    protected void doFilterInternal(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, FilterChain filterChain) throws ServletException, IOException {
        System.out.println("custom filter");
        filterChain.doFilter(httpServletRequest,httpServletResponse);
    }
}
```

```java
//AACDSI里的
@Override
protected Filter[] getServletFilters() {
    return new Filter[]{new CustomFilter()};
}
```

配置的这个Filter它的作用范围是`/* `  (JavaEE阶段讲的 → 所有)

## `HandlerInterceptor`

`Handler`的拦截器，在`doDispatch`这个方法中，在`Handler`执行之前做的拦截。

一个`Handler`有可能有多个`HandlerInterceptor`，如何知晓当前这个请求对应的`HandlerInterceptor`是哪一个或哪一些呢？

`HandlerMapping` 帮我们做映射

![image-20230912090832459](.\assets\image-20230912090832459.png)

分析发送不同请求的时候找到的`Handler` 和`HandlerInterceptor`

![image-20230912090847862](.\assets\image-20230912090847862.png)

`HandlerMapping` 起作用 → `HandlerExecutionChain`实例

每次发送请求：都会生成新的`HandlerExecutionChain`的实例

- 封装了`Handler`
- 封装了多个`HandlerInterceptor`

```java
HandlerExecutionChain mappedHandler = this.getHandler(processedRequest);
```

```java
public class HandlerExecutionChain {
    
    private final Object handler;
    @Nullable
    private HandlerInterceptor[] interceptors;
    @Nullable
    private List<HandlerInterceptor> interceptorList;
}
```

1. `HandlerInterceptor`是谁
2. 作用范围是什么
   1. 如果没有`Handler`匹配成功，那么就不会有`HandlerInterceptor`匹配成功
3. 多个`HandlerInterceptor`之间的顺序是什么

配置`HandlerInterceptor`

- 实现`HandlerInterceptor`接口
  - `preHandle` → 在`Handler`执行之前执行的，返回值为`boolean`
    - 如果返回值为`true`则继续流程
    - 如果返回值为`false`则中断流程；会去执行返回值为`true`的部分的`afterCompletion`
    - 如果有多个`HandlerInterceptor`，`preHandle`方法是正序遍历
  - `Handler` → 通常就是`Controller`组件中的`Handler`方法
  - `postHandle` → 在`Handler`之后执行的
    -  ⭐如果执行不到`Handler`（前面的`preHandle`返回值为`false`），那么一个`postHandle`都执行不到
    - 如果能够执行到`Handler`就能够执行到全部的`postHandle`
    - 如果有多个`HandlerInterceptor`，`postHandle`方法是倒序遍历
  - `afterCompletion` → 执行完`postHandle`、`preHandle` 返回值为`false`
    - 执行完`postHandle`之后执行`afterCompletion`，能够执行到全部的`afterCompletion`
    - `preHandle` 返回值为`false`的时候执行`afterCompletion` 的话，**执行的是`preHandle`返回值为`true`的部分`afterCompletion`**
    - 如果有多个`HandlerInterceptor`，`afterCompletion`方法是倒序遍历
- 配置`HandlerInterceptor`以及其作用范围
  - `WebMvcConfigurer` 接口中的方法：`getInterceptors`

开发，和上面的示意图是一致的

```java
@RequestMapping("hello")
public String handler1() {
    System.out.println("Handler1");
    return "handler1";
}
@RequestMapping("hello/songge")
public String handler2() {
    System.out.println("Handler2");
    return "handler2";
}
@RequestMapping("goodbye")
public String handler3() {
    System.out.println("Handler3");
    return "handler3";
}
@RequestMapping("goodbye/xuejia")
public String handler4() {
    System.out.println("Handler4");
    return "handler4";
}
```

提供`HandlerInterceptor`的实现类

```java
public class HandlerInterceptor1 implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("preHandle1");
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("postHandle1");

    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("afterCompletion1");
    }
}
```

配置这5个HandlerInterceptor

```java
@Autowired
HandlerInterceptor handlerInterceptor1;

// HandlerInterceptor的实例，可以直接调用构造方法初始化；也可以从容器中取出
@Override
public void addInterceptors(InterceptorRegistry registry) {
    //registry.addInterceptor(new HandlerInterceptor1()).addPathPatterns("/hello");
    registry.addInterceptor(handlerInterceptor1).addPathPatterns("/hello");
    registry.addInterceptor(new HandlerInterceptor2()).addPathPatterns("/hello/**");
    registry.addInterceptor(new HandlerInterceptor3()).addPathPatterns("/goodbye");
    registry.addInterceptor(new HandlerInterceptor4()).addPathPatterns("/goodbye/**");
    registry.addInterceptor(new HandlerInterceptor5());//.addPathPatterns("/**");
}
```

![image-20230912090909582](.\assets\image-20230912090909582.png)

```
preHandle4
preHandle5
Handler4
postHandle5
postHandle4
afterCompletion5
afterCompletion4
```

如果发送某个请求，能够找到的`HandlerInterceptor`有5个，

如果其中第四个HandlerInterceptor的preHandle返回值为false，那么执行请求如何？ 1234321

如果其中的2和5的preHandle执行可能为false，那么执行情况如何呢？121

如果这5个全为true → 123455432154321

如果说找不到对应的`Handler`，那么`HandlerExecutionChain`的值就为`null`，就执行不到`HandlerInterceptor`；也就是只有有对应的`Handler`的情况下才有可能会执行到`HandlerInterceptor`

看一点点源码

```java
// 正序遍历HandlerInterceptor的数据，遍历过程中执行HandlerInterceptor的preHandle，如果preHandle方法执行的返回值为false，保留一个标记interceptorIndex，中断流程之前执行了afterCompletion方法的调用
if (!mappedHandler.applyPreHandle(processedRequest, response)) {
    return;
}
// preHandle在它前面调用的
// 执行Handler方法
mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
// postHandle在它后面调用的
mappedHandler.applyPostHandle(processedRequest, response, mv);
```

 正序遍历`HandlerInterceptor`的数据，遍历过程中执行`HandlerInterceptor`的`preHandle`，如果`preHandle`方法执行的返回值为`false`，保留一个标记`interceptorIndex`，中断流程之前执行了`afterCompletion`方法的调用

```java
boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception {
    HandlerInterceptor[] interceptors = this.getInterceptors();
    if (!ObjectUtils.isEmpty(interceptors)) {
        for(int i = 0; i < interceptors.length; this.interceptorIndex = i++) {
            HandlerInterceptor interceptor = interceptors[i];
            if (!interceptor.preHandle(request, response, this.handler)) {
                this.triggerAfterCompletion(request, response, (Exception)null);
                return false;
            }
        }
    }

    return true;
}
```

执行`preHandle` 返回值为 `true` 的部分的`afterCompletion` ；如果所有的`preHandle`返回值都为 `true` ，`interceptorIndex=interceptors.length-1 `,遍历的就是全部的 `afterCompletion`

```java
void triggerAfterCompletion(HttpServletRequest request, HttpServletResponse response, @Nullable Exception ex) throws Exception {
    HandlerInterceptor[] interceptors = this.getInterceptors();
    if (!ObjectUtils.isEmpty(interceptors)) {
        for(int i = this.interceptorIndex; i >= 0; --i) {
            HandlerInterceptor interceptor = interceptors[i];

            try {
                interceptor.afterCompletion(request, response, this.handler, ex);
            } catch (Throwable var8) {
                logger.error("HandlerInterceptor.afterCompletion threw exception", var8);
            }
        }
    }

}
```

```java
void applyPostHandle(HttpServletRequest request, HttpServletResponse response, @Nullable ModelAndView mv) throws Exception {
    HandlerInterceptor[] interceptors = this.getInterceptors();
    if (!ObjectUtils.isEmpty(interceptors)) {
        for(int i = interceptors.length - 1; i >= 0; --i) {
            HandlerInterceptor interceptor = interceptors[i];
            interceptor.postHandle(request, response, this.handler, mv);
        }
    }

}
```

`HandlerInterceptor`使用过程中关注的几个问题：

- `HandlerInterceptor`是谁
- `HandlerInterceptor`的作用范围是什么
- 多个`HandlerInterceptor`的顺序是什么
- `preHandle`返回值为`true`或`false`的执行情况

登录案例 → `HandlerInterceptor`来做

- 提供两个Handler方法，/login   和 /hello
- 如果没有登录的情况下访问hello，输出“no login”（并不是在hello方法中输出）
- 如果已经通过login请求执行登录的话，访问hello 输出 hello world
- 限定一个要求，`HandlerInterceptor` 的作用范围是`/** `(采用默认作用范围就行)

# 异常处理

在Handler中制造异常，利用异常处理器响应json数据。

如果不做异常处理：不友好、有可能泄露信息。

## `HandlerExceptionResolver`（了解）

`HandlerExceptionResolver`：全局异常处理器

处理全局的全部异常

返回值为`ModelAndView`

```java
/**
 * 生效：只需要注册到容器中就生效
 */
@Component
public class CustomHandlerExceptionResolver implements HandlerExceptionResolver {
    /**
     *
     * @param handler 抛出异常的Handler
     * @param exception Handler抛出的异常
     * @return
     */
    @Override
    public ModelAndView resolveException(HttpServletRequest httpServletRequest,
                                         HttpServletResponse httpServletResponse,
                                         Object handler, Exception exception) {
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.setViewName("/exception.jsp");
        // 如果想要响应字符串或Json字符串可以不？可以 → 利用response
        return modelAndView;
    }
}
```

## `@ExceptionHandler `(建议)

精准异常处理，处理的特定类型的异常。

返回值可以为`ModelAndView`，也可以为`String`或`Json`字符串

### ModelAndView（了解）

```java
@ControllerAdvice
public class CustomExceptionControllerAdvice {
    
    /*@ExceptionHandler(ArithmeticException.class)
    public ModelAndView resolveArithmeticException(){
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.setViewName("/exception.jsp");
        return modelAndView;
    }*/
    @ExceptionHandler(ArithmeticException.class)
    public String resolveArithmeticException(){
        
        return "/exception.jsp";//返回值作为ModelAndView中的视图名
    }
}
```

### 字符串 或Json字符串

方法上或类上增加注解`@ResponseBody`,`@ControllerAdvice`

```java
//@ControllerAdvice
//@ResponseBody
@RestControllerAdvice //上面两个注解的和，意味着里面的全部方法响应的都是字符串或Json字符串
public class CustomExceptionControllerAdvice {

    /*@ExceptionHandler(ArithmeticException.class)
    public ModelAndView resolveArithmeticException(){
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.setViewName("/exception.jsp");
        return modelAndView;
    }*/
    /*@ExceptionHandler(ArithmeticException.class)
    public String resolveArithmeticException(){

        return "/exception.jsp";//返回值作为ModelAndView中的视图名
    }*/

    @ExceptionHandler(ArithmeticException.class)
    //@ResponseBody
    public BaseRespVo resolveArithmeticException(){
        return BaseRespVo.fail("算术异常！");
    }
}
```

`@ExceptionHandler`注解的`value`属性是数组`Class[] `

```java
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ExceptionHandler {
    Class<? extends Throwable>[] value() default {};
}
```

在方法的形参中可以直接写抛出的异常

```java
@ExceptionHandler(ArithmeticException.class)
//@ResponseBody
public BaseRespVo resolveArithmeticException(ArithmeticException exception){
    String message = exception.getMessage();//by zero
    return BaseRespVo.fail("算术异常！" + message);
}
```

# 总结

`Servlet`中包含`ApplicationContext`：查看SpringMVC架构。

## 入门案例AACDSI

里面有4个方法

+ onStartup方法：通过ServletContextListener初始化容器，并且将容器放在ServletContext中，注册DispatcherServlet，创建容器，并且从ServletContext中取出容器

+ getXxx

## 使用

归根结底都是对JavaEE的封装

## 核心流程

### 初始化

### 请求

请求处理流程

service → doGet/doPost → processRequest → doService → doDispatch → handlerAdapter.handle(request,response,handler) → method.invoke(instance,args)
