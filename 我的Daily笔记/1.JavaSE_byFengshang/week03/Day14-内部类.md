## 内部类

nested class

inner class

> 对于计算机内的cpu如何描述？

需求场景抽象：

1.某个类的对象仅应该存在于某个类的内部；

2.无论私有，某个类应该无条件的访问另一个类

📩🟡

1.内部类是一种比类更加极致的封装思想的体现。内部类的成员不仅被类自身保护，还被包裹着它的类保护。一个内部类可以被设置为仅在某个类内部能够访问。

2.好兄弟原则：内部类和包裹它的类，互相访问成员都不受访问权限限制。

内部类非常独特的使用场景，决定了它在代码中非常常见。

#### 内部类的定义

在Java语言中类可以嵌套定义，广义的内部类指的是定义在另一类中的一个类。

#### 分类

按定义的位置不同，分为：

定义在成员位置：成员内部类，静态内部类

定义在局部位置：局部内部类，匿名内部类和Lambda表达式

5中内部类重要性：

成员内部类，静态内部类：在集合源码中见，一定要能够看懂。

局部内部类，匿名内部类，Lambda表达式是开发中最常用最常见的内部类，要重点掌握。

```Java
/* 但是我们在学习的时候，不按定义位置来学习。我们按照它是一个类，还是一个对象来分类：
	1.语法定义了一个类，包括成员内部类、静态内部类和局部内部类。
	既然是定义了一个类，使用时还需要创建对象才能用。
   2.语法直接创建了一个对象，包括匿名内部类和Lambda表达式。由于已经通过语法创建了对象，可以直接使用。
*/
```

按对象创建的方式，分为：

1.语法创建类之后new对象

2.语法直接创建了一个对象，包括匿名内部类和Lambda表达式，由于已经通过语法创建了对象，可以直接使用对象

“内部类对象”直接把定义类的部分跳过

注意3个名词：

外部类/其他类（outside） 外围类(enclosed) 内部类(inner)



## 成员内部类

#### 成员内部类的基本特点

```java
* 语法:
* //外围类
* [访问权限修饰符] class EnclosedClazz{
* //成员内部类
*   [访问权限修饰符] class InnerClazz{
*  }
* }
```

1.**访问权限修饰符**

> 为什么单独定义的类只有两个权限？
>
> 因为没有私有和受保护的概念。

将成员内部类看成外围类的成员变量，有4种访问权限修饰符。

2.**成员特点**

没有静态声明！

> 成员内部类也是一个类，那么它能够定义的结构和普通类有什么区别？
>
> ==成员内部类完全不能独立存在，完全<u>依赖</u>外围类。==

**（重点）成员内部类的对象，必须在外围类对象的基础上才能得到，要得到成员内部类对象，必须先创建外围类对象。**

推出：（**重点**）成员内部类没有静态声明，没有静态成员方法，没有静态成员变量，其它和普通类一样。

补充/扩展（了解）：

> 成员内部类当中可不可以定义静态成员常量呢？
>
> 允许定义。==字面值赋值的全局常量和位置没有关系，只是为了有个名字方便存取它们。==不会触发类加载。所以允许定义。但是注意不可以new对象建立全局常量。

3.**继承和实现**

可以继承，可以实现

一个成员内部类可以继承,实现内部类或内部接口

也可以继承,实现外部类或者外部的接口

思考题：如何在外部类当中，继承一个成员内部类呢？

#### 成员内部类的访问特点

主要有4点：

1. （🟡）成员内部类内部访问外围类

​		直接访问，因为外围类对象已经存在

1. （🟡）外围类访问成员内部类成员
2. （了解）外部类访问成员内部类成员
3. （了解）成员内部类访问外部类成员



（🟡）**成员内部类内部访问外围类**

因为没有静态声明，访问位置必然是在非静态上下文当中去访问的，

**思考：在成员内部类的非静态上下文当中，有几个对象呢？**

2个对象：成员内部类自身对象用this关键字指向；外围类对象，用“外围类类名.this”指向



（🟡）**外围类访问成员内部类成员**

访问位置有两种

**1.静态上下文，有几个对象呢？**

没有任何对象

>此时访问成员内部类成员，需要创建它的对象
>
>怎么创建？？要在外围类对象的基础上
>
>```Java
>//创建外围类对象，然后才能创建成员内部类对象
>Enclosed ec = new Enclosed();
>Enclosed.Inner in = ec.new Inner();
>```
>
>```Java
>//链式调用
>Enclosed.Inner ic = new Enclosed().new Inner();
>```

**2.非静态上下文，有几个对象呢？**

一个对象，外围类自身对象

>有自身外围类对象了，this指向
>
>所以这里创建内部类对象，可以不创建外围类对象，直接创建成员内部类对象。



（了解）**外部类访问成员内部类成员**

1.权限问题：全程受外围类权限，内部类权限，内部类成员权限的限制

2.外部类的静态上下文和非静态上下文有无区别？没有区别，因为都需要创建外围类对象，然后才能创建成员内部类对象。

```Java
Enclosed.Inner ic = new Enclosed.new Inner();
```

（了解）**成员内部类访问外部类成员**

实际上就是两个普通类访问，全程受访问权限限制。



细节/原理：

为什么成员内部类对象会完全依赖外围类对象呢？这从语法上是如何实现的呢？

debug模式

变量名字里$用来表示内部类（标识符命名规范中_用来命名全局变量）



如何在外部类当中，继承成员内部类？

可以继承，首先要有权限。

没有外围类对象，那就不能 

**在外围类的基础上才可以调用内部类对象**

```Java
new Enclosed().super();
```



## 静态内部类

静态内部类译为：nested class

成员内部类译为:  inner class

也是属于定义在外围类成员位置的内部类

语法

```Java
 //外围（普通）类
[访问权限修饰符] class EnclosedClazz{
// 静态内部类访问权限修饰符，有四个，和普通成员一样
[访问权限修饰符] static class NestedClazz{ }
}
```

**静态内部类的自身特点**：

1.访问权限修饰符，4种皆可；

2.（重点）成员特点/静态内部类当中定义的结构和普通类有什么区别？

静态内部类和外围类就是独立的两个类，只不过静态内部类借用外围类来保护自己。

3.继承和实现

**访问特点**

1. 静态内部类内部访问外围类

2. 外围类访问静态内部类成员

   直接new创建对象访问，不受访问权限限制

3. 外部类访问静态内部类成员

​		需要直接创建静态内部类对象，受访问权限限制

语法要做对比，只有一个new只创建一个对象，但是需要指出外围类

```Java
Enclosed.Nested nc = new Enclosed.Nested();
```

​		4.静态内部类访问外部类成员

​			可以访问，受权限限制

先明确两点：

1.好兄弟原则，静态内部类和外围类之间互相访问

2.没关系，静态内部类和外围类没有任何依赖关系

想要访问各自，创建各自的对象即可

一些问题：

>成员内部类：着说一说下述访问，能否进行，怎么进行，是否受访问权限限制。
>
>1. 成员内部类的成员方法中，去访问外围类的成员。(直接访问无限制)
>2. 外围类的成员方法中，去访问成员内部类的成员。（直接创建内部类对象，访问无限制）
>3. 外围类的静态成员方法中，去访问成员内部类的成员。（创建对象访问无限制）
>4. 外部类的成员方法中，访问成员内部类的成员。（创建对象访问，受访问权限限制）
>5. 外部类的静态成员方法中，访问成员内部类的成员。（创建对象访问，受访问权限限制）

"'Demo.this' cannot be referenced from static context."

>静态成员内部类：试着说一说下述访问，能否进行，怎么进行，是否受访问权限限制。
>
>1. 静态内部类的成员方法中，去访问外围类的成员。（创建对象访问，不受权限限制）
>2. 外围类的成员方法中，去访问静态内部类的成员。（创建对象访问，不受访问权限限制）
>3. 外围类的静态成员方法中，去访问静态内部类的成员。（创建对象访问，不受访问权限限制）
>4. 外部类的成员方法中，访问静态内部类的成员。（创建对象访问，全程权限限制）
>5. 外部类的静态成员方法中，访问静态内部类的成员。（创建对象访问，全程权限限制）

静态内部类和外围内部类的类加载，它们有什么关系？

从设计而言，它们是没有什么关系的。



## 局部内部类

```java
// 局部位置
 class Inner{
 }
 // 局部位置
```

局部内部类的特点:

局部内部类相当于把一个成员内部类放进方法等成员位置，它就类似于局部变量，此时该内部类，就仅在作用域内部生效，离开作用域，就无法直接访问该局部内部类了。

局部内部类是一个更加极致的封装思想体现，将自己隐藏在外围类的成员方法中。

1.**访问权限修饰符**

没有该概念，局部位置不需要访问权限限制

2.**成员特点**

和成员内部类完全一致

没有静态声明

可以定义用字面值常量赋值的全局常量

3.（重点）**继承和实现**

局部内部类在使用时，多数情况就是为了继承，就是为了实现。

局部内部类去继承或者实现外部类或接口，是局部内部类最重要的用途。



#### 局部内部类的访问特点

首先明确两点：

1.“好兄弟原则”

局部内部类访问外围类，随意访问不受权限限制

外围类访问局部内部类，稍微改变了一点，要在作用域内部才能直接访问

2.（最重点）

局部内部类在具体研究它的访问时，要注意该局部内部类定义的位置：

**如果局部内部类定义在外围类当中的静态上下文中，**

​	**此时局部内部类相当于静态内部类**

（ 此时局部内部类和外围类之间没有任何依赖关系,互相访问创建各自对象就可以了!）

**如果局部内部类定义在外围类当中的非静态上下文中**

​	**此时局部内部类相当于成员内部类**

（ 此时局部内部类和外围类之间具有强依赖关系,局部内部类会依赖于外围类
 局部内部类对象会持有外围类对象的引用作为自身成员变量）



**局部内部类的访问特点**，以下几个角度研究：

1. **局部内部类内部访问外围类**
2. 外围类访问局部内部类成员
3. 外部类访问局部内部类成员
4. 局部内部类访问外部类成员



**1.局部内部类访问外围类（要分情况）**

​	1.如果是外围类非静态上下文中的局部内部类,访问外围类:
​		直接访问,不受权限的限制
​		如果有同名
​		还是"外围类类名.this"指向外围类对象
​	2.如果是外围类静态上下文中的局部内部类,访问外围类:
​		要创建外围类对象,然后访问
​		不受权限的限制

2.外围类访问局部内部类成员
在外围类当中,访问局部内部类也要受作用域的限制
必须在作用域内部才能直接访问局部内部类,创建对象
只需要在作用域内部,在局部内部类定义的下方
创建该局部内部类的对象即可
创建对象后访问,不受权限的限制

3.外部类访问局部内部类成员

在外部类当中，是不能直接访问局部内部类的

4.局部内部类访问外部类成员

可以访问，全程受权限的限制

#### 局部内部类实际开发中的应用

配合方法来使用

1.在局部位置，需要传参时，如果传参传入的是一个子类对象。那么完全可以用局部内部类定义它的实现/子类，然后传参，传入该局部内部类的子类对象



2.在局部位置，如果方法的返回值类型是一个父类类型，在具体写返回值时，可以用局部内部类定义它的子类类型，然后创建返回该局部内部类，子类对象。



#### 局部内部类的小细节：

局部内部类离开作用域不能直接访问,但是局部内部类的对象可以离开作用域被使用
因为对象可以作用方法的返回值被返回

但是此时方法的返回值类型如何写呢?
写该局部内部类的父类类型,最好让该局部内部类实现一个接口或者继承一个类
然后父类类型写它实现或继承的接口或者类!

#### 注意事项

在局部内部类的成员方法中，如果想要访问作用域内部的局部变量，那么该变量：

1.要么直接就用final修饰，是一个局部常量

2.要么就是一个事实上的常量，即只能赋值一次，相当于用final修饰它。

第二条是java8的新特性。其实是个语法糖。

注意：匿名内部类以及Lambda表达式都是特殊的局部内部类，也遵守该原则。

原因：由于对象的生命周期和局部变量的生命周期冲突所致，对象可能持续存活，而局部变量随着方法调用完毕就出栈销毁了

编译器会把作用域内部访问的局部变量，变为对象本身的成员变量。

那么这和访问的局部变量是final有什么关系呢？

```
(重点)当然,从代码上而言,局部内部类访问的是局部变量,但实际上,从内存角度上来说,局部内部类访问的是自身的成员变量
*
```

## 简化的局部内部类：匿名内部类

匿名内部类anonymous

匿名内部类是直接创建的局部内部类，是简化的局部内部类。

#### 定义语法:

```java
  // 局部位置
 new 类名或者接口名(){
   // 某类名或接口名的子类的类体
 };
 // 局部位置
```

> 1.语法结构中的"类名/接口名"可以写 普通类，抽象类，接口
>
> 2.（重点）抽象类和接口不能创建对象，new关键字在此的意义在于：创建语法结构中"类名或接口名"的子类对象
>
> 3.（重点）匿名内部类表示创建"类名或接口名"的子类对象，但是该子类的名字是不知道的，所以叫匿名内部类
>
> 4.（重点）语法结构中的"{}"是匿名子类的类体，既然是类体，就可以在该类体中重写父类的方法，还可以定义自己的成员方法，成员变量。



匿名内部类更准确的名字是“匿名的子类内部类对象”/“匿名内部类对象”

#### 使用匿名内部类

1.当成匿名对象，直接"."用即可

a.简单便捷，但是该对象是一次性的

b.可以访问匿名子类独有成员

2.用语法结构中"类名或者接口名"作为父类引用，接收匿名子类对象

a.稍微复杂一点，但是对象可以多次使用

b.不可以访问匿名子类独有成员，因为子类是匿名的，所以没有办法强制类型转换

#### 匿名内部类的使用细节

```java
* 匿名内部类的语法:
* new 类名或者接口名(){
*   // 某类名或接口名的子类的类体
* };
```

匿名内部类是特殊的局部内部类，所以思考一下问题：

1.匿名内部类的结的匿名子类类体中，能定义的结构有哪些？能不能定义构造器呢？

> 答：不能定义构造器，<u>因为匿名，写不出构造器</u>；但是仍然有构造器，有一个编译器默认提供的无参构造器。

2.匿名内部类语法当中的“（）”有没有特殊作用？是固定的语法格式吗？

> 答：当匿名内部类对象创建的是一个类的对象时，那么“（）”可以给这个父类构造器传参。当然接口是没有构造器的，"()"就没有用了

3.匿名内部类访问作用域的局部变量，该变量是常量。

#### 使用场景

和局部内部类是一样的。

1.方法需要返回一个对象时，返回值类型是引用数据类型

> 可以在方法的局部位置写一个基于X类或X接口的匿名内部类对象 ，然后直接作为返回值返回给外界。

2.方法需要传入一个对象时，形参数据类型是引用数据类型

> 方法需要传入一个对象实参时，可以在调用方法的实参位置填入一个基于X类或X接口的匿名内部类对象，就将它作为实参传给方法使用



## Lambda表达式基本

可以取代<u>**接口**</u>的匿名内部类

Lambda表达式本质上也是创建对象



```
*      1.Lambda表达式仍然是局部内部类，是特殊的局部内部类,仍然定义在局部位置。
*          而且局部内部类的注意事项，也一样存在。
*      2.Lambda表达式在取代匿名内部类时，不是全部都取代
*          而是取代接口的匿名内部类，而类的匿名内部类Lambda表达式是不能取代的。
*      3.Lambda表达式是匿名内部类的更进一步
*          Lambda表达式得到的也不是一个类，而是一个对象，并且是接口的子类对象。
*
```

> 接口必须是一个功能接口(FunctionalInterface)

#### （重点）功能接口的概念：

接口当中，**有且只有一个**<u>强制子类实现</u>的抽象方法的接口。

注解："@FunctionalInterface"写在接口定义上面，用来检验该接口是否是功能接口，如果是功能接口，注解不会报错，否则编译报错！

辨析：

1.功能接口只有一个方法吗？

> 答：不是，Java8中接口可以定义不需要子类实现的默认方法和静态方法

2.功能接口就只有一个抽象方法吗？

> 答：不是，因为接口当中有极少部分抽象方法，不会强制子类实现。如果一个抽象方法可以用Object类当中的某个方法作为默认实现，那么该抽象方法就不会强制子类实现了。当然只有接口当中的抽象方法才可以，抽象类中的抽象方法必须全部实现。

#### Lambda表达式语法

```java
(形参列表) -> {
 // 方法体
}
```

1."（形参列表）"就是功能接口中，强制子类实现的抽象方法的形参列表，完全照抄

2."->"读作"goes to"，也就是Lambda表达式运算符

3."{}"是功能接口中，是方法体不是类体

所以Lambda表达式最多重写一个方法，只一套形参列表和方法体，所以Lambda表达式必然要求接口是功能接口。



通过以上语法，单独在代码中使用Lambda表达式创建接口的子类对象，是不行的，必须明确该Lambda表达式创建的对象的具体类型，也就是指出接口的子类对象。

Lambda表达式的类型推断的四种方式：

1.直接用父接口的引用接收，

2.（了解，不建议用）类似强制类型转换。

3.（实际开发最常见）借助方法的形参数据类型，完成Lambda表达式

4.借助方法的返回值类型
