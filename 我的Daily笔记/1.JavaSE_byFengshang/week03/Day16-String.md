# Object类

Object类是没有成员变量定义的，并且由于子类对象的隐式初始化，Object类有且仅有一个默认提供的无参构造方法。

```Java
getClass()
toString()
⭐equals(Object obj):用判断对象相等，String类有对它的重写
⭐hashCode():用于获取对象的哈希码值
finalize():Java9中用"@Deprecated"标记了该方法
clone():克隆对象，开发中很少用；但提供了一种全新不同于new对象的创建对象的方式
    
1.public final Class getClass()    
2.public String toString()
3.public boolean equals(Object obj)    
4.public int hashCode()
5.protected void finalize()   
6.protected Object clone()    
```

## getClass()

##### 方法声明

```Java
public final native Class<?> getClass();
```

> <?>表示泛型：泛型也是传参，是来自C++，而C++是真泛型可以影响程序运行，Java1.5开始引入泛型，但此时已经不能加入真正的泛型，所以是伪泛型，不影响运行。

学习该方法的主要问题：

**1.什么是Class对象**,Class对象是怎么来的？

Class指的是java.lang.Class类

**2.Class对象有啥用**

```Java
在类加载阶段,JVM认识了解了该类型,同时JVM为了能够让程序员也能够在程序的运行期间,了解认识该类型
* 并动态执行一些操作
* 所以JVM在类加载某个类型的过程中(严格来说,是加载的阶段),会在堆上创建该类型的Class对象
* Class对象当中,封装了该类的类型信息
* 然后程序员只需要获取该类型的Class对象,就可以在运行期间获取该类型的类型信息,从而执行一些相关操作!
```

> 解决此问题需要“类加载”
>
> 在运行的过程当中获取类型信息（类的名字，方法，构造器），用来动态地进行操作。
>
> JVM在类加载过程中（严格来说是加载阶段）将类型信息封装成一个对象。
>
> 所以只要有该类型的Class对象就可以动态地访问信息，操作对象。可以在不事先知道该类内容地前提下，直接在程序运行期间，对该类进行一些操作。（Class对象向上推是反射，反射向上是框架）。

**关于getClass方法，要注意下面两点：**

1.getClass方法只不过是获取堆上的class对象，返回它的引用，但实际上Class对象是类加载过程中，JVM创建的，不是getClass方法创建的

2.<u>（重点）类加载只有一次，那么某个类型的Class对象必然也是唯一的。如果用两个同类型的对象，调用getClass方法，</u>然后用“==”连接，返回true.

基于以上特点，getClass方法在实际开发中最重要的用途是：

**判断两个引用指向的对象，是否是同类型的对象。**

```java
public static void judgeClassType(Object o1,Object o2){
if(o1.getClass() == o2.getClass()){
    System.out.println("是同种类型对象");
}else {
    System.out.println("不是同种类型对象");
}
}    
```

3.可以操作Class对象获取类型信息

Class用的API,实际上是反射的基本原理

```java
String getName() 获取全限定类名
String simpleName()  获取简单类名
Class stuClass = new Student().getClass();
stuClass.getName();
stuClass.simpleName();
```

## toString()

Object类当中toString()方法

#### 方法的声明

```java
public String toString();
```

##### 作用，官方文档4点：

1.返回该对象（调用toString方法的对象）的字符串表示。

2.通常，toString()方法会返回一个"以文本方式表示"此对象的字符串。

3.结果应是一个简明但易于读懂的信息表达式。

4.建议所有子类都重写此方法



##### Object类当中的toString默认实现

```java
return this.getClass().getName() + "@" + Integer.toHexString(hashCode());
```

hashCode()也是Object类成员方法，会返回该对象的哈希值，在默认情况下，这个哈希值会根据此对象的内存地址来计算，所以一般可以把该方法的返回值看成该对象的十进制内存地址值（int整数）。

（⭐重点）在Java中，<u>直接打印输出一个引用 或者 该引用参与字符串的拼接运算</u>，会<u>**隐式调用**</u>该对象的toString方法




* 一般来说,全限定类名和地址值没太大用,普遍我们会希望看到对象的属性取值以描述一个对象
* 所以一般来说,应该在子类中重写toString方法
* 重写toString方法,一般都会选择打印属性的取值,作为重写的规则

##### 重写toString方法

一般都会选择打印属性的取值，作为重写的规则。

* 1.不要手写toString方法,没必要,如果就是希望toString简简单单打印属性的取值

  那么就直接alt + insert快捷键生成

* 2.toString方法就是简简单单用于打印属性取值的,不要轻易改变它的实现

  尤其是不要在toString方法中增加业务代码

  容易引起bug

  debug模式下,idea会自动调用该类型的toString方法打印该对象

* 3.如果有引用数据类型的成员变量需要参与toString方法

  那么一般也需要重写这个类型的toString方法

* 4.(重点)

  不要画蛇添足

  不要将隐式调用toString方法写出来

  因为要避免空指针异常

##### 小细节

1.快捷键：alt + insert;

StringBuffer，StringBuilder比起String在做拼接时效率更高，它们是可变的字符串

2.toString方法就是简简单单用于打印属性取值的，不要加上业务代码，容易引起bug

debug模式下，idea会自动调用toString



3.如果有引用数据类型的成员变量需要参与toString方法，那么一般也需要重写这个类型的toString方法

4.(重点)  不要画蛇添足，不要将toString方法写出来，要避免空指针异常。



## equals方法⭐⭐⭐最重要的方法

##### 方法的声明

```Java
public boolean equals(Object obj)
```

注意两点

1.该方法时有参数的，需要传入一个对象（任意一个对象就行）

2.方法是有返回值的，返回一个布尔类型的值，真或假

##### 方法的作用

此对象.equals(其它对象)

<u>用于指示/判读其它某个对象是否与此对象“相等”</u>。

相等返回true,不相等返回false.

##### 比较对象相等！！！⭐比较规则⭐

equals方法体具体实现就是比较规则

默认规则即默认的方法实现

源码：

```Java
return(this == obj);
```

> 这个相等的规则是什么？
>
> 比较的是引用中存储的地址 -->实际上比较的是两个引用是否指向同一个对象

（这种规则只有自己才和自己相等，没有比较的必要性;新的规则应是：1.如果两个对象类型完全不一样，没有可比性，直接就是不相等对象；2.如果两个对象类型是一致的，具有可比性，那么比较它们属性的取值，如果属性取值一致，就是相等的对象）

所以要重写equals方法，JDK文档中有规则：重写协定

##### 重写的常规协定

源码中的类一定符合以下规则

1.自反性

2.排他性

3.对称性：对称性如何写代码实现？

4.传递性

5.一致性

3，4，5三个要求，只需要**<u>通过比较属性的取值</u>**来判断对象相等，就可以直接满足了，不需要额外操作

```Java
//1.自反性
	//判断相等比不等要简洁，因为不再判断是否同类
if(this == obj ){
    return ture;
}
//2.排他性
	//getClass原理是同种类型的对象返回值是同一个对象
	//注意判null，因为obj可能是传过来的null，用短路或
if(obj == null || this.getClass() != obj.getClass()){
    return false;
}
//3.对称性
//传参是Object obj，是父类引用，需要强转
Student stu = (Student) obj;
//先判断age,为了不嵌套，要先判断不等
if(age != stu.age){
    return false;
}
//代码运行到这里只剩下判断最后score是否相等，相等则返回值也相等，所以不需要再写if语句
return score == stu.score;
```

##### 重写的注意事项

1.在重写equals方法时，要实现排他性，关于排他性，有两种方式：

​	a.用getClass方法进行校验方法比较严格，必须两个对象的类型完全一致，才能够继续比较，不会考虑继承父子类之类的关系

​	b.更宽松的一种排他性校验，除了允许传入相同的类型，还允许传入子类类型

需要instanceof

1.如果引用指向的对象，是后面普通类的对象或者它的子类对象，返回true

2.如果引用指向的对象，是后面的抽象类/接口的子类对象，返回true

3.如果左边的引用本身没有指向对象，等于null, 那么该结构固定返回false，该结构没有空指针异常的风险

```Java
//用instanceof做排他性校验，允许传入子类对象
if(!(obj instanceof Teacher)){
    return false;
}
Teacher t = (Teacher) obj;
```

两种排他性校验都应该掌握，但是肯定getClass更常用。

2.自动生成

> 实际开发中无特殊需求，仅用对象属性取值来判断对象相等，就直接用快捷键alt + insert重写此方法，不需要手写实现。equals() and hashCode()要一起写

3.如果类中成员变量存在引用数据类型（暂时避开String），此时做equals判断对象相等，就需要再次调用该引用数据类型的eqauls方法，如果有必要，就再次重写它的equals方法。

#### 扩展（⭐⭐）怎样比较浮点数的大小呢？

> 为什么浮点数判断大小不能用双等号?
>
> `==`连接数值类型就是纯粹<u>比较数值大小</u>，从这一点出发，在开发中，用 `==` 比较浮点数大小，是基本不会出问题的
>
> 但是
>
> ```java
> double d1 = 1/0.0;
> //Infinity
> double d2 = -1/0.0;
> //-Infinity
> double d3 = 0.0/0.0;
> //NaN
> 有三种特殊值，无法比较
> ```
>
> 所以为了更准确，更规范地比较浮点数大小，推荐一律采用以下方式：
>
> int Float.compare(float v1, float v2);
>
> int Double.compare(double v1, double v2)
>
> 上述方法返回值是整数，"v1 - v2"：
>
> 是负数，v1 < v2;是正数,v1>v2;是0，两者相等

> 浮点数具有精度问题，不能用于财务系统等要求高地运算。
>
> 用Java的一个类，是java.math.BigDecimal
>
> 不可变的、任意精度的有符号十进制数。
>
> 简单讲解以下BigDecimal：
>
> 构造方法摘要：使用的时候注意使用String不用double传入

## hashCode()

#### 方法的声明

```java
public native int hashCode(); 
```

是一个本地方法，没有任何参数,返回值是一个int类型整数

#### 方法的作用

1.返回该对象的哈希码值

2.支持此方法是为了提高哈希表的性能

> ⭐面试必考概念⭐哈希表
>
> 哈希的概念：哈希是特殊的映射。可以允许多对一，绝不允许一对多。
>
> 要求集合A是无穷大小的集合；集合B是无限大小的集合。
>
> 化无限为有限，这就是哈希，也叫哈希映射。
>
> 哈希值：集合B上的唯一一个被映射的元素就是哈希值
>
> 哈希算法：映射当中的对应规则就是哈希算法
>
> （重点）哈希冲突：哈希冲突必然存在（因为化无限为有限，一定会出现多对一而且映射本身允许多对一），哈希冲突可以减少不能避免

**Java当中的哈希映射：**

1.Java当中的哈希算法是？集合A和集合B是？

Object类当中的hashCode方法就是java当中的哈希算法；

集合A是一个无限的集合：由于hashCode方法需要对象来调用，<u>所以集合A就是该类型对象的全体集合</u>，理论上是无限大

集合B是一个有限集合：int类型的全体数值集合（正负21亿）

2.哈希值？

调用hashCode方法得到的十进制整数

3.哈希冲突：

两个（相同数据类型的）不同的对象调用hashCode方法，返回相同的整数结果，这就是哈希冲突

> 哈希表
>
> 哈希表这种数据结构是用来存储key-value的，真正存的是value，哈希表的实现有多种方式，在java中基于数组实现。
>
> 哈希表前提：key是唯一的；根据key来计算hash值
>
> Java中，key value都是对象，Entry对象封装key,value
>
> ```Java
> class Entry{
>     Object key
>     Object value
>     int hash
>     ....
> }
> ```
>
> 得到数组下标的办法：用哈希值对数组长度取余。因为哈希值是一个十进制数。hash % 数组的长度 =（0 ~ 数组长度-1）
>
> 一旦出现哈希冲突，就出现链表，此时没有访问数组的按照下标随机存取的便利了，会遍历同一个数组下标下的链表，所以哈希算法越好，链表越少，访问越快。
>
> 由于哈希冲突不可避免，所以链表一定存在。在java8中，链表过长时，链表会解体变为红黑树。

Java中哈希表的实现：

首先哈希表是一个键值对 对象 的数组，由键值对对象中的key对象的哈希值决定键值对在哈希表中的位置，由于哈希冲突一定存在，导致就一定会有键值对对象存储在同一个下标的位置，只是哈希表会选择将这些键值对对象用链表组合起来。所以设计出更好的哈希算法，尽量减少哈希冲突，有利于减少链表的长度，有利于提高哈希表的性能

>hash table hashmap的源码要找时间看看

#### Object中的hashCode方法的默认实现

一般而言，内存中的不同对象，它们的哈希值是不同的，但是哈希冲突是可能的，所以不同对象完全可以有相同的哈希值。



#### 如何重写hashCode方法

涉及到设计哈希算法，一般而言如无特殊需求，不用自己考虑它的实现，自动生成alt + insert



#### 为什么equals 和hashCode要一起重写呢？⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐

肯定还是和哈希表有关系。

从哈希表角度出发，从映射多对一角度出发

在哈希表中，某个键值对节点中的key对象必须是唯一的，哈希表中没有两个相同的key。如何判断key的相等与不相等呢？用key对象类型的equals方法来判断，而key对象的hash值用key对象类型的hashCode方法来计算。

对于一个哈希表来说，如果key对象类型的equals方法，判断两个key返回true，认为两个key相同，那么它们不能同时共存。如果强行插入，新的key会覆盖旧的key，既然是覆盖，那么新的key和旧的key应该插入相同的位置。而位置是通过key对象的哈希值来判断的，所以既然是插入相同的位置，必然要求：此时新的key和旧的key两个对象的哈希值也是一样的。

**（重点）如果equals方法调用结果返回true，那么这两个比较的对象的hashCode方法的返回值必须一致。**

为了保证“equals方法调用结果返回true，hashCode方法的返回值必须一致”：

1.要么都不重写，都按照内存地址判断

2.要么**<u>同时重写，而且重写的依据必须一样</u>**

例如一个Student类，它有成员变量id,age,score...

假设重写equals方法根据id判断对象相等，那么hashCode方法也必须根据id来计算哈希值。

总结：

在哈希表中：

​	1.两个对象调用equals方法返回true，意味着它们是映射中集合A当中的同一个元素，映射不允许一对多，返回这两个对象调用hashCode方法的返回值，哈希表，必须也是一样的。这就要求，必须同时重写equals方法和hashCode方法，而且重写的依据应该是一致的。

​	2.两个对象调用euqals方法返回false，

注意事项：

​	1.一旦重写hashCode方法，默认toString方法不再打印地址值了。

所以重写hashCode方法，顺手也自动生成以下toString方法的重写

​	2.如果类中有引用数据类型的成员变量，那么继续调用它的hashCode方法，也就需要重写它的hashCode方法。

#### java8中的String = 字符数组

比如"abc" 是['a','b','c']

String是final修饰的没有子类类型

## `finalize`方法

#### 方法的声明

```Java
protected
```

方法体是空的，而且访问权限是`protected`。这种写法是指必须要重写，该设计可以学习。

#### 方法的作用

没有用

是为了模仿C++中的析构函数的设计。

对象资源占用的情况

两种资源：对象本身占用的内存和对象使用的系统资源

（⭐）在Java中，所有对象占用的额外资源释放，都必须依赖程序员手动完成，所以以后大家做I/O操作，网络操作，数据库操作等需要占用系统资源的操作时，一定不要忘记在用完之后关闭

> sc.close
>
> 《java编程思想》讲了一个对象的生命周期。

##  `clone`方法

提供了一种全新的不同于`new`对象的创建对象的方式

#### 方法的声明

```Java
protected native Object clone() throws CloneNotSupportedException；
```

`protected`：在子类当中创建子类自身对象

#### 方法的作用

得到一个和原先对象，完全独立的新对象并且成员仍和原先对象一致。

不用构造器

#### (重点)如何使用`clone`方法？

⭐步骤如下：突破访问权限——>重写返回值类型——>实现接口

1. （重要必须做）如果不是自己克隆自己，首先需要在子类中重写`clone`方法的<u>访问权限。</u>

2. `clone`方法在`Object`类当中的默认实现，就会得到一个独立的和原先对象一样的新对象。

3. （重要）Object类的clone方法不会改变对象类型，所以为了调用方法的方便，建议重写返回值为<u>自身类型</u>。

4. （重要）如果想要对某个类型的对象做克隆操作。那么该类型必须实现接口"java.lang.Cloneable"否则会报错“`CloneNotSupportedException`”

#### 注意事项

1. `clone`方法是通过本地方法创建对象，创建对象过程中不会执行构造器！它和`new`创建对象是平行的关系。

2. `clone`方法得到的新对象和老对象是独立的，但类型以及成员都是一致的，这是`Object`类的默认实现。假如真的有需求，可以考虑重写`clone`方法，文档中，也给出了重写的常规协定：

*          在进行克隆操作时，正常情况下，我们使用Object类当中的默认实现就足够了，不需要重写实现。
*          但假如你真的有需求，对于某个对象的引用x，JDK文档中也规定了一些重写的原则：
*          a.x.clone() != x 为 true
*          b.x.clone().getClass() == x.getClass() 一般也为true
*          c.x.clone().equals(x) 一般情况下也为true
*          上述规定告诉我们：
*          a.克隆必须是一个新的独立的对象
*          b.克隆最好不要改变数据类型，除非你真的有需要。
*          c.克隆后的两个对象调用equals方法，应该返回true。前提是，必须按照成员变量的取值重写equals方法。



#### ⭐Cloneable接口

该接口是一个空接口，没有定义任何抽象方法，接口体是空的。

实现这样的一个空接口，有啥用呢？【标记接口配合`instanceOf`实现标记】

>虽然实现类不能得到任何成员，但是实现类的数据类型改变了，从以往不是空接口的子类类型，变成了空接口的子类类型。
>
>在这样的前提下，配合`instanceOf`语法，就可以做出相关的判断，从而执行相应的操作。

判断引用指向的对象是不是`Cloneable`的子类对象，`Cloneable`配合`clone`方法就是这样实现的。

所以在Java当中，向`Cloneable`这样的空接口，实现了就允许做xx操作，不实现就不允许甚至抛出异常，我们称之为**“标记接口”**，标记接口在Java中算是比较常见的。

另一个比较常见的是"`java.io.Serializable`"。

#### 浅克隆和深克隆

1. 浅克隆/浅拷贝

​	Object类当中的clone方法的默认实现，就是浅克隆。对于引用数据类型的克隆，导致克隆对象和原先对象不是独立的，克隆的对象里有引用数据类型，只克隆了引用。

2. 深克隆/深拷贝

​	无论对象中有无引用数据类型，都要确保克隆得到完全独立的新对象。深克隆实现的方式很多，这里讲一个最简单的方式：

+ a.深度克隆是在浅克隆的基础上进行的，还是需要先做浅克隆//super.clone();

+ b.将对象中的引用指向的对象，在克隆一个新对象

+ c.将拷贝对象中的拷贝引用，指向克隆后的新对象

# String类

## String类自身特点⭐⭐

String类在java.lang包下

注意：

1. String不要导错包了

2. String类提供了大量的API用于操作字符串，不用记但是需要用一下留印象

3. 理解和掌握String类自身独特性：

   + a. String对象是不可变的（不可变常量）

   + b. 配合字符串常量池，String字面值常量对象在堆空间是唯一的（⭐）

一个字面值就表示一个对象。

"ABC"既是一个字面值常量，同时也是一个Java对象。

String类在给引用赋值时，普通情况选择直接用字面值赋值，但有些场景下，也要用到String类的构造器来创建对象。

String类的常用构造器：

```Java
// 创建一个空的,长度为0的字符串对象，而不是null
public String()

//将一个字符串的十进制编码值表示，转换成对应的字符串（这个过程中要有编码集参与）
//offset 指偏移量，下标为0开始时，偏移量就是index
public String(byte[] bytes)
public String(byte[] bytes,int offset,int length)

// 同字节数组
public String(char[] value)
// 同上，不过指定了开始下标和长度
public String(char[] value,int offset,int count)
  
// 套娃
public String(String original)
```

## String对象不可变

> 什么是不可变对象？
>
> >《Effective Java》
> >
> >“对象一旦被创建后，对象所有的状态及属性在其生命周期内不会发生任何改变”

从对象的角度来看，某个String对象完成创建后，除非销毁它，否则就不能再改变它对象的状态。

从代码的角度，从使用角度来理解String对象不可变：任何想要修改String字符串内容的方式，都不会修改成功，都不是直接修改原先对象的状态，而是创建了一个新的对象，原先的老对象不变。

所有不可变对象都是如此，比如`BigDecimal`。

#### （重点）为什么`String`对象不可变呢？⭐

看源码，设计核心是`char[] value`，被`private final`修饰

重要原因之一是`final`修饰，表示引用不能指向新的对象，但是理论上说对象可以改变。所以还要依赖于其它的精巧设计。

其次，所有`String`类的方法，都很小心地没有去改动`value`数组里的元素，且没有对外暴露这个`value`数组。

（细节）最后，`String`类所有用数组进行传参赋值的构造器，都不会直接用传参的数组给`value`赋值，而是会将该参数数组拷贝一份，然后再传参给`value`。这可以防止外部代码通过修改传入的数组来改变`String`对象的内容。

请简要描述`String`对象不可变。
[+] 参考回答
建议大家有条理，有逻辑的按照以下顺序来回答这个问题：

>先简要描述一下String对象不可变是什么。
>
>1. 讲一下为什么String是一个不可变对象。
>2. 再讲一下好处。
>3. 最后谈一谈弊端。当然也可以进一步谈谈如何解决这个弊端。
>
>我们知道被 `final` 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，`final` 关键字修饰的数组保存字符串并不是 `String` 不可变的根本原因，因为这个数组保存的字符串是可变的（`final` 修饰引用类型变量的情况）。
>
>`String` 真正不可变有下面几点原因：
>
>1. 保存字符串的数组被 `final` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。
>2. `String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。

参考的回答如下：

 ⚡`String`对象是一个不可变对象。**这意味着某个`String`对象一旦被创建，那么就不可以改变它的状态了。**具体而言，就是这个字符串的内容就不可以再改变了。我们常做的字符串操作，比如拼接，截取，替换等，实际上都会创建一个新的`String`对象，而不是直接在原先对象上进行操作。
`String`对象之所以是一个不可变对象，依赖于`String`类优秀封装设计：
`String`用一个`char`类型的`value`数组成员变量，来封装字符串数据。而这个`value`是`private`和`final`修饰的，外界不能直接访问和修改这个`value`。
通过轻巧小心的设计，`String`类的所有操作都没有暴露这个value数组或者修改这个`value`数组。`String`类提供的字符串操作，都是创建了新`String`对象，新的`value`数组而不是直接修改原先的`value`。而典型`toCharArray`方法也没有直接返回`value`数组而是返回它的拷贝。
`String`类用数组赋值的构造器，没有直接用传入的数组对象给`value`赋值，而是用它的拷贝给`value`赋值。这样就避免了外界通过修改传参的数组去修改`String`。

String的不可变特性，给String类本身带来了很多优点，比如：

1. 安全性。字符串在Java程序当中，经常用来存储一些敏感信息，如密码、配置信息、文件路径等。如果String是可变对象，那么这些敏感信息就可能被其它代码无意或恶意的修改，从而引发安全问题。不可变的 String 可以确保这些信息在整个应用程序运行期间都不会被修改。

2. 线程安全。由于字符串是不可变的，因此它们在多线程环境中是绝对线程安全的。这使得String对象在多线程环境下，无需通过线程同步来保证数据安全，这提高了并发编程时，程序的效率。

3. <u>哈希值不变</u>。`String`对象的哈希值在调用一次`hashCode`方法后会直接用成员变量`hash`存储，并且由于`String`对象不可变，该哈希值`hash`在整个对象的生命周期中都不会改变。如果用`String`对象做哈希表的`key`，那么由于哈希值不变，就无需多次重复计算哈希值，就可以显著提高哈希表的性能。实际上，字符串`String`就是Java当中最常用的哈希表的`key`。

4. 支持字符串常量池。正是由于`String`对象是不可变对象，字符串常量池中的`String`对象才有了共享使用的可能性。如果`String`对象是可变的，那么字符串常量池也就失去意义了。

当然`String`对象的不可变特性，也带来了一些弊端，比如：

1. 时间耗费。字符串往往每操作一次就会创建一个新的字符串对象，如果遇到需要频繁操作的场景，时间耗费非常大。

2. 空间浪费。频繁操作字符串时使用`String`，就会导致频繁创建`String`对象。这就可能造成大量的内存空间浪费。
3. 性能损耗。频繁操作`String`对象，需要频繁创建对象，时间耗费大，空间浪费严重。同时也给`GC`的垃圾回收带来了负担，进一步加剧了性能损耗。

为了解决这些问题，Java提供了`StringBuilder`和`StringBuffer`两个类，这两个类表示的字符串是可变的，<u>可以直接在原先字符串对象上进行各种操作</u>，从而解决了由于`String`对象不可变性引起的性能问题。当然就没有不可变字符串`String`的那些优点了。

>请简要描述一下字符串常量池的概念。

[+] 参考回答

字符串常量池（String Constant Pool）是JVM的一部分，在Java8的环境下，字符串常量池在堆上。

字符串常量池用于存储所有的字符串字面量对象，每当代码中出现一个字符串字面量，JVM就会检查字符串常量池：

如果字符串常量池中已经存在相同内容的字符串，则不会创建新的对象，而是返回指向已有对象的引用。

如果不存在相同的字符串，则创建新的String对象并放入字符串常量池。

加之String对象是一个不可变对象，Java就通过字符串常量池实现了对String字面值对象的复用。

这样的设计，减少了String对象的创建频率，避免了不必要的对象创建，从而减少内存开销，提升程序的性能。

但是要注意，字符串常量池这种实现String对象共享的机制，仅适用于字面值String对象，任何通过new创建（构造器赋值）的String对象都不会自动将引用存储在字符串常量池中，因此不会被共享。

 



