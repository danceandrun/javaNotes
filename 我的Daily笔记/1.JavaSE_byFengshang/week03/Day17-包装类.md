## String类

> 什么是字符串常量池
>
> JVM的一部分，java8以后在堆上（之前在方法区）

String的独特性在于太常用。字符串在JVM中需要频繁大量创建和使用，所以为了减少内存开销，提高程序的性能。优化的方式是：**用字符串常量池来存储字符串字面值对象<u>的引用</u>，一旦再次需要使用该字面值对象，就不会创建该对象了，而是直接共享字符串常量池中存储的对象。**

当然，如果初次使用某个字面值String对象，那么还是在堆上创建对象，然后将引用存到字符串常量池，这样就可以对该字面值字符串对象实现复用！

#### 字符串字面值

字符串常量池用来存储的是字符串字面值

String对象不可变是字符串常量池应用的前提。

注意事项：

## intern 字符串（拘留字符串对象）

#### intern方法在Java8的实现逻辑

* 该方法是一个成员方法,调用者也是一个String对象

  调用该方法,首先会判断调用者String对象相同内容的String对象是否已在字符串常量池(就是检查一下是否存在相同内容的拘留字符串):

  1. 如果存在,那就不做任何操作,直接将这个拘留字符串返回

  2. 如果不存在,那么就<u>把调用intern方法的字符串对象的引用存入字符串常量池</u>

  这样方法调用者String对象就从一个非拘留字符串,变成了拘留字符串，并且将这个拘留字符串返回。那么在后续就可以复用这个拘留字符串



#### 拘留字符串的复用

对于字面值常量和字面值常量的运算参与赋值都可以复用。（常量和常量的运算是一回事）。

对于String字符串对象的复用以及new对象，场景如下：

一定会在堆上创建一个新的、独立的String对象的几个场景：



intern方法在java8的实现逻辑：

该方法是一个成员方法，调用者也是一个String对象

调用该方法看，首先会



## String API

调用方法时，方法的返回值影响到了循环的参数

```java
while (((fromIndex = str.indexOf("java", fromIndex)) != -1)) 
```

赋值语句是有结果的，结果就是等式右边；

（重点）在所有源码中的方法中，只要是涉及数组区间的问题，一律是左闭右开。因为可以这样写[0,str.length).

#### 字符串比较大小

比较对象有两种方法：

1.equals比较相等与否

2.通过实现一个接口Comparable（在java.lang包下）

```java
int compareTo(String str);
int compareToIgnoreCase(String str)
```

可以把这个方法理解成this -str；

* 如果方法的返回值是小于0的 说明this < str
* 如果方法的返回值是大于0的 说明this > str
* 如果方法的返回值是等于0的 说明this = str

比较大小是为了排序

**（重点）实际上Java中，所有实现了接口`java.lang.Comparable`的类，都可以对其对象容器做排序.**

称之为“自然排序”，而且是按照对象从小到大进行排序；对象比较大小的规则就是实现Comparable中的compareTo方法，；

具体的，可以通过以下两个方法实现自然排序：

* 1.如果对象容器是一个对象数组的话,可以用

  java.util.Arrays.sort(数组);

  实现对数组容器中对象的从小到大排序,该方法没有返回值,直接对原先数组排序
  
* 2.如果对象容器是一个对象集合的话,可以用

  java.util.Collections.sort(数组);

  实现对集合容器中对象的从小到大排序,该方法没有返回值,直接对原先集合排序

当然，任何类实现Comparable接口，重写compareTo方法，表示对象的大小规则，都可以做以上自然排序。



更灵活的对容器做排序的接口，java.util.Comparator接口，自定义比较接口。是功能接口，用Lambda表达式实现。

java.util.Comparator接口,自定义比较器接口

基于该接口就可以实现更灵活的对象容器排序

具体方法如下：

* Arrays.sort(arr,Comparator)

* Collections.sort(collection,Comparator)

  Comparator接口中,强制子类实现的抽象方法如下:

  compare(Object o1,Object o2);

  这个抽象方法在实现时,可以看成o1 - o2

  如果该方法返回负数,表示o1 < o2

  如果该方法返回正数,表示o1 > o2

  如果该方法返回0,表示o1 = o2

  也就是Comparator自定义比较接口的实现类就表示一个比较大小的规则,然后将这个规则传入sort方法

  就可以实现对对象容器的排序,当然也是从小到大进行排序



## 可变字符串

string对象不可变：如果要频繁地修改字符串内容就需要频繁地创建对象，带来时间消耗，空间消耗等弊端。

在实际开发中，如果遇到频繁操作字符串的场景，尤其是大量数据的场景，应该使用可变字符串`java.lang.StringBuffer`或者`java.lang.StringBuilder`

#### 为什么StringBuffer，StringBuilder是可变字符串呢？

> 掌握两点
>
> 1. 可变字符串的value和普通String的value有什么区别？
>
> 2. 扩容的机制

`AbstractStringBuilder`源码

可变字符串的value一般称之为“字符串缓冲区”，它是用来缓冲存储字符信息的，代表这个可变字符串当前能够存储的最长字符串。

成员变量count用来指示字符串缓冲区，当前已存储的长度。



**通过`StringBuffer`的构造器进一步了解可变字符串扩容机制。**⭐⭐⭐（集合里也有扩容，重点）

`.length()`

获取当前字符串缓冲区真正存储的字符串的长度，也就是count取值；

`.capacity()`

获取当前字符串缓冲区的容量，也就是value数组的长度

> 查看源码时，控制鼠标光标的位置：
>
> ctrl + alt + <-

反转字符串方法只有可变字符串有

> 为什么String作为引用数据类型，可以使用运算符"+"?
>
> 编译器有自动处理，运算符重载。“+”用一次至少创建3个对象：StringBuffer，toString，value



## Java的包装类型

早期因为虚拟机的性能原因，没有把基本数据类型设计为对象。

`java.lang.Void`

包装类型普遍封装了该类型下的一些常量。最大值，最小值，所占位数。

实际上所有包装类型（能创建对象的，不包括void），都是用一个



#### 包装类型对象不可变

所有包装类型的对象，和String对象一样，都是不可变对象。

原因如下：

​	1.value是private final修饰的

​	2.

所以，包装类型的对象和String一样，对象一旦创建，内容就不会改变，除非销毁它。

#### （最重要的特点）自动拆装箱机制

包装类型和基本数据类型的自动拆装箱机制：

装箱(boxing)：基本数据类型到引用数据类型

拆箱(unboxing)：引用数据类型到基本数据类型

在java中，装箱和拆箱都是自动完成的，意味着包装类型和它的基本数据类型基本可以混用。在一些方法中很常用。

**原理**

原因就是在底层自动调用方法，由编译器完成了转换过程。自动装箱要依赖于自动调用该类型的静态方法,valueOf(基本数据类型元素)；

自动拆箱要依赖于自动调用该类型的成员方法，xxxValue()；其中xxx表示该基本数据类型。

**用处**

将返回值类型改为包装类型



**包装类型对象比较大小，不能用“`==`”，用`equals`；**

⛳ **包装类型的缓存机制**，会将一个`byte`范围内的整型对象事先创建完毕，存储起来，然后在使用时，会直接复用缓存。

