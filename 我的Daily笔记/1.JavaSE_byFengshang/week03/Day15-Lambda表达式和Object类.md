## Lambda表达式语法

> 《JAVA8实战》

```java
(形参列表) -> {
 // 方法体
};
```

1. "`（形参列表）`"就是功能接口中，强制子类实现的抽象方法的形参列表，完全照抄

​	形参列表一致指的是数据类型，数量，顺序一致

2. "`->`"读作"goes to"，也就是Lambda表达式运算符

3. "`{}`"是功能接口中的抽象方法的方法体而不是类体

函数式接口或者功能接口：**方法体只有一个**

所以Lambda表达式最多重写一个方法，只一套形参列表和方法体，所以Lambda表达式必然要求接口是**功能接口。**

通过以上语法，单独在代码中使用Lambda表达式创建接口的子类对象，是不行的，必须明确该Lambda表达式创建的对象的具体类型，也就是指出接口的子类对象。

#### Lambda表达式的==类型推断==的四种方式：

1.直接用父接口的引用接收，直接指出该Lambda表达式创建对象的类型

2.（了解，不建议用）类似强制类型转换。

3.（实际开发最常见）借助方法的形参数据类型，完成Lambda表达式

4.借助方法的返回值类型

#### Lambda表达式的简化

主要是简化格式

简化的前提：不能带来歧义

它是功能接口的子类对象，而功能接口中有且只有一个**必须**要实现的抽象方法。

> 1.对于“（形参列表）”能不能简化？

可以简化，形参列表的<u>数据类型</u>写不写都是一样的

特殊的如果形参列表就只有一个形参，小括号也可以简化。当然，如果形参列表是空，没有参数，那么不能把“()”省略；

> 2.对于"{}"可以简化吗？

可以简化。<u>规范中不允许省略if ，for循环的大括号</u>。但是这里Lambda表达式重写的方法体语句就只有一条，那么可以省略"{}"

方法有返回值，并且方法体的这一条语句就是返回值语句，return加不加都一样

在实际开发中，绝大数情况下，不太可能一行就重写完了抽象方法，所以"{}"的省略用以上方式就做不到了，此时使用Lambda表达式语法当中的**“方法引用”**

<u>方法引用**：可以用一个已经实现的方法作为Lambda表达式当中抽象方法的实现。**</u>

>核心点）⭐
>
>**究竟什么样的一个已实现的方法，可以作为Lambda表达式当中抽象方法的实现？**
>
>大原则：只要这个已实现的方法，可以实现该抽象方法的功能就够了。不需要考虑完全一致。

```java
/*对于一个已实现的方法*/
[修饰符列表] 返回值类型 方法名（形参列表）{
    //方法体
}
```

1.“访问权限修饰”有没有要求？

没有特别要求，但是在使用的地方必须有权限

2.“static”"非static"有没有要求？

没有要求

3.对于已实现的方法，“返回值类型”有没有要求呢？

有要求。

> 如果功能接口中的抽象方法返回值类型是基本类型和void必须一致，如果抽象方法返回值类型是引用类型，可以保持一致还可以返回子类类型。

4.对于已实现的方法，“方法名”有要求吗？

没有要求

5.对于已实现的方法，“形参列表”有要求吗？

必须保持一致

#### 方法引用的具体语法

两种

1.不省略"->"(了解，不建议使用)

```java
(形参列表) -> 已实现方法的调用(形参列表)
```

解释：

​	a.前后的”形参列表“需要保持一致，都是抽象方法的形参列表

​	b."已实现方法的调用"：

​		静态方法用类名点调用；成员方法用对象点调用（可以匿名对象）

**2.省略"->"（推荐的方式）**

```Java
已实现方法的归属者::已实现方法的方法名；
```

解释：

​	1.”已实现方法的归属者“:

​	如果是静态方法，属于类，写类名

​	<u>如果是成员方法，属于对象，写对象名/匿名对象</u>

​	2."已实现方法的方法名"：就是把名字写在这里

#### Lambda表达式使用的注意事项

1.是特殊的局部内部类，可以访问局部变量，但是不能赋值

2."Variable 'num' is already defined  in the scope"

>除此之外，局部内部类，匿名内部类它们都有自己独立的作用域，能够自定义自己的成员。 但是Lambda表达式没有自身独立的作用域，不能自定义成员，和方法共用同一个作用域。

Lambda表达式{}和类体{}共用一个作用域，和if语句的{}类似。

3.用一个已实现的方法来作为功能接口中抽象方法的实现。*这个已经实现的方法可以是任意已实现方法*

*      不仅仅是自己定义的方法
*      比如源码中的方法,三方工具库中的方法等都是可以



#### 方法回调与Lambda表达式

把一个方法作为参数传递给另外一个参数

> 应用：Java对象数组的排序

## Java常用API

API是广义上的接口。不是Java语法中的interface，而是指一些已经预先定义好的，暴露给外界使用的方法或者工具。

中低级程序员被戏称为"API caller"

学习重心在“方法调用”

多线程也算API

课下每一个API都要敲一遍。

1.通过API文档查看说明，非常容易有翻译错误，要注意看源码原文。2.百度博客。3.chat-GPT对API使用基本不会犯错误。最终都要自己测试一下。

## Object类

Object类是没有成员变量定义的，并且由于子类对象的隐式初始化，Object类有且仅有一个默认提供的无参构造方法。

```Java
getClass()
toString()
⭐equals(Object obj):用判断对象相等，String类有对它的重写
⭐hashCode():用于获取对象的哈希码值
finalize():Java9中用"@Deprecated"标记了该方法
clone():克隆对象，开发中很少用；但提供了一种全新不同于new对象的创建对象的方式
    
1.public final Class getClass()    
2.public String toString()
3.public boolean equals(Object obj)    
4.public int hashCode()
5.protected void finalize()   
6.protected Object clone()    
```

#### getClass()

```Java
public final native Class<?> getClass();
```

> <?>表示泛型：泛型也是传参，是来自C++，而C++是真泛型可以影响程序运行，Java1.5开始引入泛型，但此时已经不能加入真正的泛型，所以是伪泛型，不影响运行。

学习该方法的主要问题：

**1.什么是Class对象**

**2.Class对象有啥用**

> 解决此问题需要“类加载”
>
> 在运行的过程当中获取类型信息（类的名字，方法，构造器），用来动态地进行操作。
>
> JVM在类加载过程中（严格来说是加载阶段）将类型信息封装成一个对象。
>
> 所以只要有该类型的Class对象就可以动态地访问信息，操作对象。可以在不事先知道该类内容地前提下，直接在程序运行期间，对该类进行一些操作。（Class对象向上推是反射，反射向上是框架）。

1.getClass方法只不过是获取堆上的class对象，返回它的引用，但实际上Class对象是类加载过程中，JVM创建的，不是getClass方法创建的

2.（重点）类加载只有一次，那么某个类型的Class对象必然也是唯一的。如果用两个同类型的对象，调用getClass方法，然后用“==”连接，返回true.

基于以上特点，getClass方法在实际开发中最重要的用途是：

**判断两个引用指向的对象，是否是同类型的对象。**

```java
public static void judgeClassType(Object o1,Object o2){
if(o1.getClass() == o2.getClass()){
    System.out.println("是同种类型对象");
}else {
    System.out.println("不是同种类型对象");
}
}    
```

```Java
String getName()
String simpleName()
```









































