# 面向对象设计

抽象类 接口 内部类 内部类对象

## 抽象类 

（不常用，要知道语法）

### 关键字`abstract`

case：Animal类不会创建对象，方法体实现是多余的

Missing method body, or declare abstract;

一个方法要么有方法体要么必须声明为抽象方法。

#### 抽象方法的定义语法：

**abstract关键字修饰，没有方法体**

```Java
[修饰符列表] abstract 返回值类型 方法名(形参列表);
```

Class 'Animal' must either be declared abstract or implement abstract method 'shout()' in 'Animal';

**（重点⭐）一个普通类是没有抽象方法的，抽象方法必须在抽象类中。**

抽象类的定义语法：

```Java
[修饰符列表] abstract class 类名{
    //类体
}
```

抽象类不能实例化instantiated，不能创建对象。

在抽象类的子类中，一样可以重写抽象方法，也就是实现(implement，这里重写和实现是相同的概念)抽象方法。

### 抽象类的使用场景

在一个继承的继承层次中，**祖先类才需要设置为抽象类**，也就是说抽象类是做祖先类而存在的。可以想见，抽象类在日常开发中，抽象类不常见也不常用。

**（重点）抽象类当中能够定义的结构有哪些？抽象类的自身特点：**

>抽象类的类名命名特点？
>
>抽象类仍然是一个类，但在开发规范中，常见要求命名为AbstractXxxx或BaseXxxx，用于表示该类是一个抽象类（源码中常用`AbstractStringBuilder`）
>
>抽象类能够用哪些修饰符？
>
>1. 访问权限修饰符
>
>2. `final`，不可以被`final`修饰，因为抽象类就是为了被继承出现的。
>
>3. `abtract`

#### **抽象类中能够定义的成员结构有哪些？**

注意 🟡抽象类有*<u>构造器</u>*并且和普通类一样

（原因：构造器作用是在创建对象的过程中给成员变量赋值，而不是创建对象。虽然抽象类不能创建对象，**但构造器要给子类对象初始化使用。**在Java中，任何类都有构造器。）

*<u>构造代码块</u>*也是赋值，所以也可以定义，同理*<u>静态构造代码块</u>*也可以定义。

***总结，作为抽象类可以定义普通类当中允许定义的所有结构。***在不考虑创建对象的情况下，直接把一个类声明为abstract，是不会编译报错的。

抽象类*允许不定义抽象方法*，但是抽象类就应该有抽象方法，没有抽象方法的抽象类毫无意义，抽象类的存在就是为了抽象方法。注意使用场景，不能为了禁止创建对象而把一个类定义为抽象类。<u>（ps:禁止创建对象，可以私有化构造器。）</u>

#### **（重点）抽象方法的特点**

抽象类的子类，如果是**一个普通类，那么就<u>必须实现抽象类当中的所有抽象方法</u>**，这是语法上的强制规定。

抽象方法的这种作用，称之为“占位”的作用。抽象方法本身没有实现，没有任何意义，没有使用价值。

实现方法专指实现抽象方法。

##### 抽象类的子类特点：

1.普通类，普通类继承抽象类，必须实现所有的抽象方法

2.抽象类，抽象子类不需要实现抽象方法，抽象子类可以自由选择实现（或实现或不实现）

> 注意事项
>
> 1.abstract修饰方法时，该方法不能有以下修饰符：
>
> ​	a.private
>
> ​	b.static
>
> ​	c.final
>
> "Illegal combination modifiers:'abstract' and 'private'."
>
> 当然abstract修饰符也不能修饰构造方法

抽象类是怎么用的：

case:员工系统

强转

```Java
bs.cast
```



抽象类是作为祖先类而存在的，特点是有抽象方法，抽象方法没有方法体起到占位的作用。

## 接口⭐

*难点在于如何理解其用途。*生活中的接口（扩展功能），语法中的接口（接口的协议）。

接口是引用数据类型。

> `interface`是Java语言当中一种非常重要的引用数据类型，大多数情况下，<u>接口当中就只会定义抽象方法</u>，从而表示对行为的抽象以及指定相应的**标准和规范**。实现接口，需要实现接口中的抽象方法，从而实现相应的标准和规范，以最终达到根据标准和规范来扩展功能的目的。

单继承的限制导致不可能继承多个抽象类，希望可以继续使用多个抽象方法。引出”接口“的概念。

### 定义

#### **接口的定义语法：**

```Java
[访问权限修饰符] interface 接口名{}
```

接口不是类，接口允许被一个类来实现它，称之为接口的实现。实现接口，使用`implements`关键字。一个普通类实现接口必须实现所有抽象方法。

#### **普通类实现接口**

```Java
[访问权限修饰符] class 类名 extends 类名 implements 接口名 {}
```



注意：

1. 接口的实现类和类的继承，本质上是一回事，还是父子类的关系。

2. 接口和它的实现类，可以称之为父接口和实现类，从使用上来说，看成父子类也没有问题。

3. 如果一个类实现接口并继承一个类，顺序是“先继承再实现”

4. **<u>==（重点）接口不受Java类继承的单继承限制，一个类可以继承别的类的同时实现接口，而且可以实现多个接口。==</u>**一个类只能直接继承一个类，这是单继承。但是一个类可以实现多个接口，这是接口的多实现。

接口和实现类之间的关系"like-a"。接口中的抽象方法表示开发标准和规范，实现接口表示对功能的扩展，它只关注行为，不关注属性。

### 接口的特点

#### 1. 接口的声明特点：

接口本身就是抽象的，**<u>接口的声明中隐含了关键字"abstract"</u>**，接口和抽象类一样，也不能实例化。不能用`final`修饰。（隐含的关键字不可以写出来）

#### 2. 接口和它的实现类命名的特殊形式：

某些程序员为了区分，表示该类型是一个接口，会将接口的命名以"I"开头比如"IDemo"等。

接口的实现类，有时为了体现它是某个接口的实现类，可以命名为“接口名 + Impl”，而且可以专门定义一个包，包名就叫"impl"，将实现类放进去。

#### 3. （重点）接口中能够定义的结构及其特点：

<u>接口中可以定义数据，**但只能定义公共的全局常量**，实际上接口中定义的数据，全部默认被`publi static final`修饰。</u>

注意：

1. 隐含的关键字不要写出来；

2. 接口中没有静态代码块，只能显示赋值

3. 接口中能够定义的所有结构，一律默认`public`修饰：接口中的结构访问权限一律是`public`，而且不可更改。

4. 接口侧重于对行为的扩展，实际开发中几乎所有的接口都不会定义全局常量！只有当接口的所有实现类都需要一个共同的全局常量时，才需要在接口中定义。

接口的抽象方法，大多数普通子类也必须全部实现，有少部分抽象方法不需要子类实现。

接口中，在Java7及其以前，是不能定义任何<u>带有实现的方法</u>的（有方法体），Java8后可以，但很少使用。

```Java
interface IA{
	//注意隐藏的修饰符绝对不可以写出来
	void test();
	int test2();
}
```

#### 4.接口中是否可以定义构造器呢？

不能，<u>接口确实是没有构造器的</u>，因为自己没用，子类也不会用；抽象类是自己没用，但子类会用。

接口没有静态代码块，也没有构造代码块。

接口只允许定义：

1. 全局常量

2. 抽象方法

3. （Java8以后）带有实现的静态方法和默认方法

普遍来说，接口中就只有抽象方法的定义。

> Java8当中，新增的语法：接口中的静态方法和默认方法
>
> 默认方法真的是默认方法，它是用关键字`default`关键字修饰的方法。语法：
>
> ```Java
> default 返回值类型 方法名（形参列表）{
> //方法体
> }
> ```
>
> 在`switch`中也有关键字`default`，表示最后的选项结果。
>
> 为什么接口中多了带实现的方法呢？
>
> 1. 如果接口的实现类确实需要一个公共的实现，那么可以定义在接口中（为接口的使用增加了灵活性）
>2. 为了配合Lambda表达式来一起使用，所以接口中就出现了实现方法

探讨如下一些问题：

**`super`关键字在接口的子类构造器中表示什么呢？**

> **答：表示接口实现类的父类，如果有就是直接父类，如果没有写，那么就是Object。**

接口的实现类可以是什么？

> 1. 普通类实现接口，一般而言，必须实现所有的抽象方法；
>
> 2. 抽象类实现接口，可以按需实现部分的抽象方法
> 
> 扩展：接口除了可以被一个类实现，还可以被继承(用`extends`关键字)，被另一个接口继承
>

（⭐重点：要小背一下~）**总结一下`extends`和`implement`的使用**

>首先，它们虽然语义不同，但基本都是继承的含义，都属于父子类的关系。
>
>其次，**继承（`extends`）是不能跨越种族的，类和类继承，接口和接口继承，接口和类之间没有继承关系。**
>
>**类的继承是单继承的，接口的继承是多继承的。**
>
>1. 普通类继承一个抽象类，需要实现里面的所有抽象方法。
>2. 抽象类继承一个抽象类，按需实现里面的抽象方法。
>3. 抽象类继承一个普通类，是可以的。
>4. 接口在继承一个接口后，会得到接口的所有抽象方法。
>
>**实现（`implements`），必须发现在类与接口之间，接口和类是没有任何关系的。**
>
>1. 普通类实现接口，**一般而言**，必须实现所有的抽象方法。
>2. 抽象类实现接口，按需实现抽象方法

### `interface`在实际开发中的用途

广义上的接口：程序员开发出来，暴露给外界第三方使用的方法或者工具。

对于前后端交互来说最重要的是：形参和返回值类型。

#### 接口的使用：MVC设计模式

接口使用时和设计模式结合

MVC设计模式（重点）

概念：

**设计模式**(design patterns)：一套完整完善应对某个普遍存在问题的解决方案。常见：单例模式，工厂模式，装饰模式，观察者模式，策略模式等。

**解耦**（decoupling）：减少消除不同部分之间的依赖关系。依赖注入和观察者模式等设计模式。

在代码中应用设计模式就是为了实现解耦。

MVC：Model -View-Controller

主要部分是模型，包含业务逻辑和数据；

视图是模型的可视化表示，可以是GUI，而在Web应用中，view通常是指渲染数据的HTML。

控制器是连接model和view的部分，它接收用户对view的输入，并将这些输入转化为对model的操作。

可以通过进行包的划分来实现MVC设计模型。

搞清楚依赖关系。

**接口在mvc中的应用**：service层和dao层需要写接口，制定开发的标准和规范。

依赖于service层实际上是依赖于接口。

父类引用指向子类对象，限制访问范围只能访问接口的抽象方法。

区分业务逻辑和数据处理，service DAO层分别做什么

写业务逻辑时如果需要一个方法，先假设它存在把逻辑写完。



view层——>controller层——>service层——>DAO层——>Model层



链式调用配合lambda表达式和集合注意不要超过10，超过要写中间变量接收一下，不然代码可读性差。
