日期的格式化类

字符串      -------->日期类对象 ：解析过程 parse()

日期类对象 ------->字符串 ：格式化过程 format()

# 异常

异常就是一个普通类。

**异常，指的是<u>程序运行时出现</u>的不正常的情况，一般情况下异常会导致程序运行报错，程序终止执行。**

异常要和编译报错区分开。

（重点）注意事项：

**异常类和异常对象都只是封装了异常的信息，提供了相关操作。但是异常何时被抛出，何时被处理以及如何处理异常等都不是异常对象或异常类决定的。**

Java异常的继承体系/继承层次

祖先类：`java.lang.Throwable`

常见异常：java.lang.Error:ClassNotFoundError，栈溢出错误，堆溢出错误

java.lang.Exception：它描述的是Java程序运行时可以被捕获并且被处理的问题

对Exception分类：

1.运行时异常(RuntimeException)

运行时异常的特点是,即便程序中有可能产生运行时异常,程序也不会出现任何编译报错,程序照样正常启动!

常见：空指针异常，除0异常，数组下标越界异常...

2.编译时异常(CheckedException,也叫受检查异常)

受检查异常

Exception下的非RuntimeException子类

编译时异常的特点是,如果程序中有可能产生编译时异常,那么会强制程序员显式处理该异常.

如果不处理就会编译报错

常见：`CloneNotSupportedException`（克隆不支持异常）,`ParseException`（解析异常）,`IOException`.

特点：会强制程序员显示处理该异常，如果不处理就会编译报错，编译报错程序就无法执行

> (重点⭐考题要记得)总结一下编译时异常和运行异常：

> （严重理解错误）编译时异常是编译时抛出的异常,运行时异常是运行时抛出的异常

>无论编译时异常还是运行时异常，**都是运行时期产生的**，编译时期只会编译报错没有异常。
>
>编译时异常，意味着程序可能产生该异常时，必须显式处理，否则编译报错；
>
>运行时异常，意味着程序可能产生该异常时，如果不显示处理，也无所谓，不会编译报错，程序照样启动运行。
>
>编译时异常，指的是Exception的非RuntimeException的子类； Exception类的子类java.lang.RuntimeException以及RuntimeException的所有子类都属于运行时异常
>
>最大区别在于：是否需要**<u>在程序编译时期</u>**就处理这个异常，如果是，就是编译时异常。如果不是，就是运行时异常。

在Java的异常继承当中，直接继承一个Exception，表示它是一个编译异常，而Exception自身，Java程序也是作为编译时异常处理的。而直接继承一个RuntimeException，表示它是一个运行时异常，而RuntimeException自身，Java程序也是作为运行时异常处理的。

设计原则：尽量设计成编译异常，因为需要显式处理，这样可以让程序员再检查一下代码。

#### 异常处理逻辑

一直向上抛出异常，最终抛给JVM。JVM必须进行异常处理。这种异常处理方式，称之为“Java默认的异常处理机制”。

##### 默认处理

1. 终止程序执行，从错误行开始后面无法执行。

2. 在控制台打印异常的相关信息。

注意：程序中如果可能产生编译时异常，那么程序员必须显示处理该异常，否则会编译报错，***所以默认的异常处理机制针对的是运行时异常。***

如果希望程序出现异常时仍能够运行，需要`try...catch`

##### 捕获并处理异常

语法：

```java
try {
 // 可能出现异常的，正常的代码逻辑
} catch(要捕获的异常类类名 对象名) {
// 在catch分支中写处理异常的代码，操作捕获的异常对象
}
```

解释：

1. `try`关键字后面的"`{}`"中，放可能产生异常的，正常的能够通过编译的代码逻辑

2. `catch`关键字后面的"`()`"中，写被捕获的，需要匹配的异常类型：

   *      比如要捕获的异常是`NullPointerException`，那么就可以直接写`NullPointerException`以及它的父类类型

   *      当然如果写`Exception`，意味着所有异常都能够匹配


3. `catch`代码块中，写异常处理的代码

注意事项：

1. 如果`catch`当中，成功匹配`try`代码块中抛出的异常，那么就不会做默认的异常处理了，而是执行`catch`代码块。程序不会报错终止，照样正常执行！

2. （⭐）**如果`try`代码块产生了一个异常，那么`try`代码块就不会继续执行了。   这意味着`try`代码块要么就不产生任何异常代码正常执行，要么就最多产生一个异常。**

3. 如果匹配失败，照样做默认处理。`catch`代码块不会执行，程序照样报错终止。

4. 写异常匹配时，尽量写具体的子类类型来做匹配。这样可以更精准处理异常。当然如果有必要，也可以用父类类型来匹配。

5. 如果`try`代码块中没有异常，那么`catch`捕获就不会生效。程序正常执行完毕`try`代码块以及后面的代码，`catch`代码块不会执行。

6. `try`代码块和`catch`代码块当中都属于局部位置，其中定义的变量都属于局部变量。

7. `try`代码块当中应该尽量只有一行代码，就是那行可能产生异常的代码。

8. `try...catch`是<u>编译时异常显式处理的一种方式</u>，表示程序一旦抛出这个编译时异常，就会捕获处理它。当然捕获处理的异常就不会再抛出了，也不会导致程序终止了。

9. IDEA中`try...catch`的快捷键：ctrl +atl + T

```java
* 补充语法:
* 单分支的try...catch还可以使用以下语法结构，表示同时匹配多个异常类型：
    
try{
// 可能出现异常的，正常的代码逻辑
}catch(要捕获的异常类类名1 | 要捕获的异常类类名2  对象名){
// 在catch分支中写处理异常的代码，操作捕获的异常对象
}

* 注意：该语法结构中使用"|"不是逻辑运算符，也不要尝试使用“短路形式”，没有这种用法。
```

获取异常信息的API:

```java
// 获取异常类名和异常信息，以及异常出现在程序中的位置（推荐使用）
/*
    注意:
    实际开发中,异常的信息肯定不可能打印在控制台
    因为程序最终跑在服务器上,服务器是没有控制台查看信息
    所以实际开发中,异常信息会打印到日志文件中
    当然有相应的日志框架支撑这个工作
    在此之前,大家使用该方法将错误信息打印在控制台就够了
 */
// void printStackTrace()
e.printStackTrace();
```



#### 异常处理的第二种方式:`throws`

`throws`是一个关键字，用在方法声明中，是方法声明的一部分。

```Java
 语法:
[方法的修饰符列表] 返回值类型 方法名(形参列表) throws 异常列表{
  // 方法体
}
```

解释:

1. (重点)仅表示该方法抛出异常的**可能性**。实际是否抛出要看代码执行结果。

2. “异常列表”可以写多个异常的类型，写类名即可，多个异常之间用"`,`"隔开

3. **(重点)对于运行时异常没有必要使用throws关键字，只要不捕获会默认处理，自己向上抛出。**

所以`throws`关键字*应该配合方法体中可能抛出的编译时异常使用*，它是编译时异常显式处理的一种方式.

4. (重点)如果一个方法的声明中，明确指出可能`throws`编译时异常，那么调用该方法必须显式处理该编译时异常。两种方式：1. 继续抛出 2.`try...catch`自己处理

> 调用`clone()`方法需要实现`Cloneable`接口

注意事项:

`throws`关键字后面跟的异常列表中出现的异常类型,

> 补充方法重写的语法:
>
> ```Java
> [访问权限修饰符] 返回值类型 方法名(形参列表) throws 异常列表 {
>   // 方法体
> }
> ```

> 子类重写该方法:
>
> * 1.访问权限可以改写,但是只能变得更宽松,不能更严格
>
> * 2.返回值类型如果是基本数据类型和`void`,子类必须保持一致。但如果是引用数据类型，子类可以保持一致，也可以重写成子类类型
>
> * 3.方法名和形参列表都必须保持一致，当然形参列表中形参名字无所谓
>
> * 4.方法体重写无所谓
>
> * 5.重写不能抛出更多的异常.
>
> **子类重写方法,可以抛出更少的异常,可以保持一致,但不能抛出更多的异常.**

























