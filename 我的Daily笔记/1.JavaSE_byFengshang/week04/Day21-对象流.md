## 标准输入/输出流

在JDK源码当中，**标准输入流指的是：`System.in`**

它的特点是：

1. 默认从键盘`read`数据，默认的输入设备是键盘。
2. 它的本质是一个字节输入流`InputStream`。

**标准输出流指的是：`System.out`**

它的特点是：

1. 默认向显示器`write`数据，默认的输出设备是显示器。
2. 它的本质是一个字节打印流`PrintStream`。

> 标准输入流的read方法也是一个阻塞方法，需要等待键盘录入

🏷️ 利用标准输入流，模拟`Scanner`键盘录入的`nextLine()`方法实现：

> 分析：已学过的可以读一整行的数据的IO流方法只有类`BufferedReader`有，所以要想办法把标准输入流这个字节输入流`InputStream`包装成缓冲字符输入流`BufferedReader`。

将字节输入流`InputStream`包装成缓冲字符输入流`BufferedReader`的方法：

`InputStream` 使用转换流--> `InputStreamReader`---> `BufferedReader`

网络传输底层用的IO流，包装原理也是如此。

## ⭐⭐⭐ 对象流

普遍把使用对象流进行对象二进制数据操作的过程，称之为序列化和反序列化。具体来说指的是：

1. 序列化，需要使用序列化流，是一个输出向的操作。指的是将堆中的对象二进制数据，直接输出写到外存中进行持久化保存。

2. 反序列化，需要使用反序列化流，是一个输入流。将外存中对象的二进制数据，读取进JVM内存，在堆上新建这个对象。

> 序列化流是对象流，所以开头是Object，是输出向的流且操作对象是二进制的字节。
>
> 序列化流： `java.io.ObjectOutputStream`
>
> 反序列化流：`java.io.ObjectInputStream`

注意事项：

1. 之所以序列化一个对象数据，目的是为了持久化保存一个对象的数据或者网络传输对象的数据等。

2. 反序列化可以认为是一种新的、独特的创建对象的方式，该过程不依赖构造器。

>目前已知三种创建对象的方式：
>
>1. new对象 
>2. clone  
>3. 反序列化   

### 序列化和反序列化基本使用

操作一个文件时要知道底层流是`InputStream`或者`OutputStream`

在序列化某个类型的对象时，**该类型必须实现接口`java.io.Serializable`，该接口和`Cloneble`接口一样**，是一个空接口，是一个标记接口。只有实现了该接口的类型的对象，才能进行序列化操作，否则会抛出异常：`NotSerializableException`

> ⭐ 复习一下对象的存储结构：
>
> 对象头 + 成员变量 + 对齐
>
> 在Java中，对象的存储结构可以分为三个主要部分：对象头（Object Header）、实例数据（Instance Data）和对齐填充（Padding）。这些部分一起构成了Java对象的内存布局。
>
> 1. **对象头（Object Header）**：
>    - **Mark Word（标记字）**：包含一些用于管理对象的元数据，比如哈希码、锁信息、垃圾回收标记等。Mark Word的内容在不同的虚拟机实现中可能有所不同。
>    - **Class Metadata Address（类型指针）**：指向对象的类元数据，用于确定对象属于哪个类。这个指针使得JVM可以通过对象找到对应的类信息。
>
> 2. **实例数据（Instance Data）**：
>    - 包含对象的实际数据，即字段的值。这些字段按照在类中定义的顺序排列。
>
> 3. **对齐填充（Padding）**：
>    - 对齐填充是为了保证对象的起始地址是8字节的整数倍，这样可以提高访问效率。对齐填充并不包含实际的数据，只是用于填充使得对象的总大小是8字节的整数倍。
>
> 一个简单的示例可以帮助理解这个结构：
>
> ```java
> public class Example {
>     private int intValue;
>     private long longValue;
>     private String stringValue;
> }
> ```
>
> 对应的对象内存布局可能是这样的：
>
> ```
> [对象头（Mark Word + Class Metadata Address）][intValue][longValue][stringValue（指向字符串实例的引用）][对齐填充]
> ```
>
> 需要注意的是，这个结构可能会因为不同的虚拟机实现而有所不同。上述结构是一种常见的布局，但并不是所有Java虚拟机都完全相同。例如，一些虚拟机可能采用压缩指针技术来减小对象的内存占用。

> 序列化操作要实现`java.io.Serializable`
>
> 克隆操作要实现`java.lang.Cloneable`

>  🏷️序列化要做的事情：
>
> 1. 实现接口`java.io.Serializable`
>
> 2. 某个要进行序列化操作的类型，必须显示声明`serialVersionUID`
>
>    格式：
>
>    ```java
>    private static final long serialVersionUID = xxxL;
>    ```
>
>    修改IDEA设置自动加UID（Editors ---> Inspections --->  搜索UID）

### `transient`关键字

`transient`关键字可以修饰类的成员变量，用于表示在序列化操作过程中，不需要被序列化的成员变量。一个成员变量被该关键字修饰，那么序列化时，就不会存储它的具体取值，只会存一个默认值。当然反序列化时，读出来的也是一个默认值。

三个使用场景：

1. 成员变量是可以通过其他变量计算得出的，因此在序列化时不需要保存。
2. 成员变量是表示瞬时状态或环境相关的数据，如线程、数据库连接等。
3. 成员变量包含敏感信息，如密码、安全密钥等，不应该在序列化过程中暴露。

> `static`修饰的静态字段也是不能够序列化保存的。因为序列化的目的是保存对象的状态，当然不会存储属于类的静态字段。


