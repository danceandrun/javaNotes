字节输入流与字节输出流的3个读写方法是对应的，一个字节一个字节的读写，一个字节数组字节数组的读写。

这么设计是为了方便边读边写。

## 字节输入流

### 循环read

使用文件字节输入流循环读取文件数据

```Java
//一个字节一个字节的循环读取文件中的数据
int readData;
while((readData = in.read()) != -1){
    
}
in.close();

//一个字节数组一个字节数组的循环读
	//循环读，此数组是装文件中字节数据的一个缓冲区，所以经常命名为buffer
byte[] buf = new byte[3];
int readCount;
while((readCount = in.read(buf)) != -1){
   String str = new String(buf,0,readCount);
    System.out.println(str);
}
```

固定格式要经常写练习

### 实现文件复制功能

广义上，网站上传文件也是一种复制，从本地上传到服务器。

思路：

1.	将外存中的文件，循环读取到内存中；
2.	在循环读取的过程中，再将数据，循环写到外存中的另一个文件中

单字节和多字节的复制

## 缓冲字节流

自带缓冲区，提高效率。缓冲字节流的底层功能实现仍然依赖于字节流对象。

**包装流**在原有流的基础上进行功能扩展的流，大多数流都是包装流。

`FilterOutputStream`是过滤字节输出流，实现了这个流就是包装流。

`Flushable`接口也是重点

3种方式：

1. 一个字节

2. 一个字节数组

3. 一个字节数组指出`offset`，`len`

缓冲字节输出流------`java.io.BufferedOutputStream`

### 步骤如下

1. 创建对象

>创建包装流对象需要先创建一个底层流

构造器格式里，传参`OutputStream out`：它是抽象父类，传其子类，最常见的是`FileOutputStream`

2. 调用方法

> ⭐**包装流实现IO功能要依赖于底层流**，而创建`FileOutputStream`对象,如果文件已存在，会创建新的文件覆盖源文件，需要append设置为true
>
> 🟡缓冲区当中的数据必须**满足一定条件**才可以写到外存种。
>
> 三个条件：
>
> ​	1.缓冲区装满了
>
> ​	2.手动调用flush方法来强制刷新缓冲区
>
> ​	3.关闭缓冲流
>
> 其一，要注意缓冲区大小：默认缓冲区大小：8192字节，8KB.
>
> 其二，一般固定刷新，使用带缓冲区的输出流时有固定格式

3. 关闭资源

> 关闭包装流会同步关闭底层流

### `Flushable`接口

`java.io.Flushable`

只要是带缓冲区的输出流就得刷新，不刷新数据就在缓冲区，如果不带缓冲区的输出流和所有的输入流都不需要。实际上输入流没有实现该接口。

> any buffered output 

### 缓冲字节输入流 `java.io.BufferedInputStream`

实际上使用和文件字节输入流没有区别，是完全一样的。

一个字节一个字节

一个字节数组一个字节数组

循环读

缓冲字节流输入流的缓冲区不需要刷新，数据可以从缓冲区读取到Java程序当中，即便如此，也不要忘记关闭流。

### 提取工具类实现文件复制

定义一个工具类，利用字节流来实现文件复制

## 字符流

> 为什么需要字符流？

英文字母和阿拉伯数字一个字节就可以表示。

字符流是对字节流读取文本数据场景的一种增强和补充

处理文本文件使用字符流

> 哪些是文本文件？
>
> `.txt`,`.md`,.`.java`,`.class`,`.py`,`.c`
>
> 尤其注意word文件不是文本文件

字符流相关的基本概念

- 编码表

  - 虽然ASCII码表用8位存储但是第1位是不用的，只有128个。

  - Unicode只规定了映射关系，究竟用多少字节存没有规定，所以Unicode编码集不是一个可以使用的编码集。
  - UTF-8是遵循Unicode规则的一个具体可以使用的编码集。特点是可变长。

- 编码值：二进制表示的数值大小（非负的）

- 编码：实际上就是`String-->byte[]`

  - 🟡怎么实现？

  - > 用String类的成员方法
    >
    > 1. `.getBytes()`;无参的方法表示使用默认的编码集来进行编码操作，默认的编码集在IDEA当中是UTF-8
    >
    > 2. `getBytes(编码集的名字字符串)`；该方法表示用指定编码集来进行编码操作

- 解码：实际上就是`byte[] ---> String`

  - 🟡怎么实现？

  - > 用String类的构造器
    >
    > 1. `String(byte[] b),String(byte[],int off, int len)`
    > 2. `String(byte[] b , int offset, int len, 编码集的名字)`

- 乱码问题：编码和解码的规则不同。

- 字符流 = 字节流 + 编码表

首先字符输入流对象实现IO功能，仍然要依赖于普通字节流输入流。

用来编码解码的缓冲区，注意缓冲区释放的时刻：利用编码表一次一个字节读入，当读到正确的编码集对应的字节数时，缓冲区输出



> ⭐⭐ 如何理解“字符流 = 字节流 + 编码表”⭐⭐ 
>
> 字节流和字符流都是Java中进行IO操作处理的方式，它们之间主要区别在于：
>
> 1. 处理数据的逻辑单位不同：字节流以字节（8位）为基本处理单位，而字符流固定以字符为单位处理数据。
> 2. 能够处理的文件类型不同：字节流是万能流可以处理任何文件，但字符流只能用于处理文本文件。
>
> 关于“字符流 = 字节流 + 编码表”这句话，首先应该清楚所有的字符流实际上都是字节流的包装流，它们底层实现IO功能的流仍然是字节流，其次，字符流对象在内部还封装了一个基于编码表的进行编解码的缓冲区。
>
> 比如：当我们使用字符流读取文本数据时，实际上是先通过字节流读取字节数据，然后通过编码表将这些字节转换为字符。
>
> 相反，当我们使用字符流写出文本数据时，实际上是先通过编码表将字符转换为字节，然后通过字节流将这些字节写出。
>
> 所以对于字符流，可以通俗的认为，它就是一个基于编码表，扩展了编解码功能的字节流。

## 转换流

看继承关系，所有的字符输出流都需要刷新缓冲区

### `java.io.OutputStreamWriter`

该类是将一个字节输出流转换成一个字符输出流。

转换流是连接字节流和字符流的通道，是一种很重要的流。

使用转换输出流向文本文件中写数据的步骤：

1. 创建对象

2. write写

3. flush刷新/等待关闭资源刷新

4. 关闭资源

#### **使用转换流循环写数据**

### `java.io.InputStreamReader`

将字节输入流转换成字符输入流的方式

1. 创建对象

> 读和写的编码值要保持一致

2. 调用read方法读数据

3. 关闭资源

#### **使用转换流循环读数据**

注意事项

​	1. 写换行的问题

​	2. 要注意编码集的问题，写数据时，写入的字符编码集要和文件使用的编码集一致

> anki指的是操作系统本地的编码集：gbk

#### 用转换流实现文件复制的功能

## 简化流

简化字符输出流，也叫文件字符输出流

简化字符输入流，也叫文件字符输入流

`java.io.FileReader`

`java.io.FileWriter`

简化流就是基于`File`输入输出字节流的转换字符流的一个简化形式。但是有个小区别，简化流只能用默认编码集，以及不能指定编码集了。

## BufferedWriter缓冲流

`java.io.BufferedWriter`

字符流本身自带的缓冲区是为了实现字符的编/解码，而`BufferedWriter`缓冲流当中的缓冲区是为了提高IO效率

1. 创建对象

2. 调用`write`方法，写数据

> ⭐拥有一个独有的、独特作用的成员表方法：
>
> `void newLine()` 写入一个行分隔符 就是换行

## BufferedReader

`java.io.BufferedReader`

包装了一个普通的字符输入流

1. 创建对象

2. 调用方法

>⭐ 缓冲字符流的使用很多时候因为这个特殊的方法：
>
>`String readLine()`读取一整行的文本，读完后会换行。注意，如果已经读到了末尾，会返回`null`。

> 读文件时，只有`readLine()`方法得到的是一个字符串

### 利用缓冲字符流的独特方法实现一行行地复制文本文件

⭐⭐⭐ 

写法与以往稍微有些不同

```java
while(line = in.readLine() != null){

}
```

总结，带缓冲区的字符输入输出流：

1. 减少IO操作提高效率

2. 提供了独特的“读一行”以及“换行”的方法，尤其是“读一行”是非常独特的重要方法。

## 数据流

数据流的作用是操作Java基本数据类型数据。

数据流都是字节流，没有字符流。在使用字符流和字节流的过程中，没有办法直接将一个Java基本数据类型写到外存中。

数据输出流`java.io.DataOutputStream`

数据输入流`java.io.InputStream`

所有的数据流都是包装流，都需要包装一个底层的字节流来实现功能，但是数据流是不带缓冲区的不需要刷新。

⭐⭐ 

关键是：数据输出流是直接将对应JVM当中基本数据类型的二进制字节数据直接写入此输出流

数据输出流和数据输入流总是成对出现的，单独出现没有意义。

还要注意，怎么写的就怎么读，不能乱了顺序。

## 打印流

`java.io.PrintStream`

`java.io.PrintWriter`

> `String.valueOf()`可以将基本数据类型转换成字符串

将各种类型的数据，全部以字符串的形式打印输出到外存中，这就是打印流。

### 字节打印流

字节打印流虽然实现了`Flushable`接口但是没有缓冲区，不需要刷新。

是一个包装流，它通过为其它字节流添加新功能的方式，使得字节打印流可以“以字符串的形式打印Java各种数据类型”（包括基本和引用数据类型）

### 字符打印流

字符打印流因为字符流的缓冲区所以需要刷新

打印流在将对象打印到外存时，会隐式调用toString方法，将反复噶的返回输出到外存中。

在所有实现了接口`Flushable`，并且带有缓冲区的输出流当中，`PrintWriter`最特殊，因为它的缓冲区可以自动刷新

> 自动刷新的机制：
>
> 1. `PrintWriter`当中的所有`println`方法（包括无参有参）会调用`.flush()`方法
>
> 2. `PrintWriter`当中的所有`format`方法

文件指针不能回退，要读两次文件时需要创建两个流。

```Java
获取随机整数的方法：(int) (Math.random*length)
```











































