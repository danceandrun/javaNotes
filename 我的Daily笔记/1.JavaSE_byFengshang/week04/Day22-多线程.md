## 多线程入门

多线程理论基础

代码实现多线程

多线程数据安全问题

线程间通信

## 前言

在整个JAVA中的地位

非常常见于前端，后端开发。

服务器是网络编程中的一种，服务器就是多线程的，同时能够响应多个请求

学入门，不讲业务逻辑，只讲概念，API，真正难点是业务逻辑和技术结合

做项目时要特别关注每个技术的应用场景

基础知识：来自《OS》，方便理解代码的实现

> - JAVA的多线程有几种实现方式？
>
> - 线程的生命周期⭐ 
>
> - 线程同步：（5个人同时花100块钱）其中有典型问题，线程间的数据安全问题
>
> - 线程通信问题：通过通信来共同实现功能
>
> - 多线程的扩展主题

学JAVAEE 框架时要留意，虽然不直接用，多线程应用也随处可见

> 书籍补充：《Java并发编程》

多线程是用代码的复杂性来换效率

> 首先把多线程当成API学习

### 一些概念

#### 程序（program）

静态的概念，没有运行的状态。是一段代码/指令的合集

#### 进程

动态的概念，运行中正在解决问题的程序

与程序是一体两面（当然是跑在操作系统上的程序）

>**进程是操作系统分配资源的基本单位。操作系统将系统的资源（如CPU、内存、磁盘等）划分成了若干个单元，每个单元就是一个进程，操作系统通过分配进程所需要的资源来控制进程的运行。在这个过程中，操作系统会根据进程的优先级、等待时间、I/O操作等因素，对进程进行调度，以达到最优的资源利用效率。**具体的分配资源算法详见《OS》

用JAVA角度解释：

🟡 每一个Java进程对应一个JVM实例

🟡 每次启动一个`main`方法，操作系统会在内存中分配资源创建一个JVM实例

一个Java进程就有自己独立的堆，栈和方法区 

#### 线程

**一条独立的执行路径**

> 线程是CPU进行资源**调度**的基本单位，线程是进程内的一个执行单元，它可以共享进程的内存空间和资源。

用JAVA角度解释：

1. 启动一个`main`方法就是启动Java进程

2. `main`方法就是主线程。任何Java进程都会有主线程。

3. （重点）🔔 在JAVA中**任何进程都不是单线程的，至少有3个：**

​	a. 主线程（工作线程）

​	b. 异常处理线程（后台线程）

​	c. GC垃圾回收线程

##### 注意分清JVM内存中哪些是线程私有的哪些是公有的：

***一个线程是一个完整独立的方法调用链***，所以JVM栈，本地方法栈都是私有的；而堆和方法区因为自身占内存空间较大，所以是共享的。既然是共享的，就会存在数据安全问题。

#### 串行

早期没有线程概念，只有进程

单道批处理操作系统：只有一个进程

多道批处理操作系统：内存中有多个进程

#### 并行

多个线程同时执行

需要硬件基础：多核CPU

#### 并发

多个线程交替执行

对于JAVA程序员来说，不管并行还是并发都是多个线程“同时”执行。

## 多线程的概念

优点

使用场景

1. 提升CPU利用率：比如边下边播

2. 解决了一些**必须**同时处理两个或者多个任务的场景

> `TimeUnit.SECONDS.sleep();`
>
> 该方法可以让线程休眠xx时间

主线程有一个每个3秒打印一次的任务，利用死循环加休眠线程实现。当需要再下面写一个方法提供结束条件时，无法做到，此时就是必须使用多线程的场景。

## Thread类

`java.lang.Thread`

## 实现方式一

实际上，在Java当中 ，肯定是要创建`Thread`对象的，所谓的三种实现方式，只不过是使用的构造器不同，传入的参数不同罢了。

**方式一步骤🟡** 

1. 新建一个类A，让该类继承`java.lang.Thread`类

2. 重写该类A继承自父类的`run`方法

3. 创建该A对象

4. A类对象调用成员方法`start`方法启动这个线程

**注意事项**

1. 继承相关注意：`Thread`类就是一个普通类，要主动重写`run`方法。

   方法重写不能抛出更多编译时异常，只能`try...catch`

2. 启动线程是调用`start`方法而不是直接调用`run`方法

   `run`方法只是一个普普通通的成员方法，只有`start`才可以启动。

3. 启动一个新的线程后，**和原本的主线程是并行/并发执行**。从运行效果看，是同时执行的。

**细节问题**

>1. 能不能直接创建`Thread`对象来新建线程？

可以但是直接`new Thread`创建一个对象因为没有重写`run`方法，这个线程不能执行任何任务，这个线程是没有任何意义的。

> 2. 启动`main`方法时，发生了什么？⭐ 

* 1. 启动`main`方法就是运行一个Java程序，也就是在操作系统中启动了一个Java进程。而Java程序是执行于JVM当中的，所以一个Java进程，实际上是一个JVM的进程。

* 2. `main`方法是程序的入口方法，`main`方法的执行代表了这个Java进程中的**一条执行路径**，也就是一个线程。我们一般称呼`main`方法执行的线程是“主线程”，其它线程为“子线程”。

  `main`方法执行意味着主线程启动，主线程是一个Java进程执行中的一条主要路径。

*      3. 在`main`方法中又开启了一个线程，这个线程是主线程当中新建的子线程。子线程的开启意味着该Java进程中开辟了一条新的执行路径，这条新的执行路径和原先的主路径可以“并发执行，同时执行”。

#### 多线程的执行特点和线程调度方案

执行没有规律可循，或者说规律是：随机。

>1. 什么是线程调度？
>
>   线程调度就是<u>*操作系统给线程分配CPU处理权*</u>的过程，拿到CPU处理权的线程才会被执行。
>
>2. 线程调度方式有哪些？
>   1. **协同式线程调度**，线程的执行时间是由线程自己决定的。如果某个线程执行完报告操作系统切换到别的线程执行。
>   2. **抢占式线程调度**，线程的执行时间由操作系统决定。受操作系统调度算法以及机器当前负载等多重因素的影响，**可以认为这种方式是多个线程同时“争抢”CPU处理权，谁“抢”到就执行谁。**
>
>
>
>3. Java采用什么调度方式？
>
>   1.  Java采用**抢占式线程调度**
>   2. 协同式线程调度可能会由于<u>*线程阻塞*</u>导致线程始终占据CPU执行权，所以**Java多线程的线程调度方式是抢占式的线程调度方案。**
>
>

不能明确谁先谁后，这也是多线程带来的一个问题。不过我们并不需要关心到底哪个先后执行，当作同时执行就可以。

注意：不能重复启动同一个线程。

## 多线程实现方式一的API

Java多线程的API就是指`Thread`类的成员方法和静态方法。

而多线程的实现方式，都是基于`Thread`类，所以此API是每种实现方法都可以用的。当然具体要看是用成员方法还是静态方法。

> 构造器`Thread(String str)`
>
> 如果希望给线程起个名字需要用这个单参构造器，`String`类型的str就是线程名字。
>
> 注：如果创建线程对象时，没有指定线程名字，线程的名字会从Thread-0开始编号。
>
> `Thread`还存在以下两个方法针对线程名字进行操作：
>
> 🟡 **获取线程名称的方法**：
>
> ```java
> public final String getName();
> ```
>
> 🟡 **修改线程名称的方法**：
>
> ```java
> public final void setName(String name);
> ```

🟡 **关于获取线程名字**

获取当前的线程对象

```Java
public static Thread currentThread()
```

> 这个静态方法可以在相应位置获取**当前线程对象**。

在Java中任何一个地方都有当前线程对象。

🟡 **线程休眠**`sleep`

`sleep`方法是`Thread`类的静态方法

```Java
public static native void sleep(long millis) throws InterruptedException
```

> 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。

+ 单位是毫秒

+ 受操作系统影响

常用的是经过时间换算的方法：

（推荐使用）`sleep` 的替代枚举类型`TimeUnit`

*在调用`sleep`方法的过程中，此线程处于阻塞状态。*

> 一个练习题
>
> **用构造器给线程执行任务需要的数据进行传参**
>
> `System.CurrentTimeMillis()` 获取当前时间的毫秒值。

 🟡**线程加入**`join`

`join`

```Java
public final void join() throws InterruptedException
```

作用描述：等待该线程终止

**该方法是线程插队的方法，调用该方法，可以让调用方法的线程插队执行**

> 通过代码看作用
>
> ```java
> ThreadA a = new ThreadA("A线程"); 
> ```
>

插队之后让线程执行模式从并行/并发重新变成了**串行执行**。

学习`join`方法要弄清如下问题

1. 谁等待？

> 执行`join`方法代码所处的线程等待

2. 等待谁？

> 哪个线程对象调用`join`方法

3. 谁先执行完？

> 调用`join`方法的线程

4. 谁后执行完？

> 被执行`join`方法的线程

🟡 线程礼让 `yield`

静态方法

```java
public static native void yield();
```

让出来之后再去抢

> 礼让让的只是执行权
>
> 注意不是让出来另一个线程执行完之后再执行，如果要实现轮流执行，需要线程间通信来完成。

🟡🟡 线程守护

#### 重要概念之线程分类

##### 用户线程（工作线程）：

在Java代码中，如果不做特殊设置，启动的线程都是工作线程

##### 守护线程

为用户线程服务的线程，可以理解为用户线程的奴仆。通过`Thread`类的`setDaemon()`成员方法

```java
public final void setDaemon (boolean on);
```

```Java
AThread a = new AThread();
a.setDaemon(true);
```

##### 注意：只有当所有工作线程都结束时，守护线程才会结束。

>注意：
>
>1. 守护线程是守护进程中所有的工作线程的，而不是守护某一个工作线程。
>
>2. （重点⭐ ）对于一个Java进程来说，当进程中还存在任何一个工作线程时（不止主线程，只要是工作线程都可以），进程都会继续执行，而不会终止执行。
>
>3. （重点）一个Java进程当中，所有的工作线程都结束时，进程也就结束了。换言之，一个Java进程中，如果只剩下守护线程了，那么进程就结束了。**JDK文档中原话是：当正在运行的线程都是守护线程时，Java 虚拟机退出。**

```Java
TimeUnit.SECONDS.sleep(5);
```

> 练习
>
> 利用一个守护线程，每隔一秒钟打印一下当前的时间，10s后不再打印。

## 如何中断线程

`@Deprecated stop`方法

该方法的作用简单明了，任何线程调用该方法，不论线程处于什么样的执行状态，都会立刻

> 在代码中，不要去使用过时的方法和类

> 为什么`stop`方法是一个过时的方法呢？
>
> 可能会带来未知的风险。
>
> 看案例：模拟后台下载进程
>
> 在使用`stop`方法去终止一个线程时，线程的状态是不可预期的，不能知道该线程是处于正在执行还是已经执行完成的状态。这样就无法对程序进行处理。
>
> 比如中断一个下载后，下载是成功的还是失败的，程序员是不可得知的，这样程序员就无法做出应对。
>
> 合理的线程中断应该告诉程序员**中断后程序的执行状态。**
>

安全的线程中断（比如中断下载线程）

一个安全的线程中断，应该告诉程序员中断的情况，并作出相应的处理。

对于下载线程来说：

1. 下载成功返回成功信息

2. 下载失败，打印失败信息到log文件中

## 线程优先级

优先级：`priority`

优先级是`[1,10]`的整数，10是优先级最高

```Java
setPtiority(10);
```

注意：优先级仅具有统计学意义。因为实际上并不是设定级别高就一定会抢到资源。

Java的开发者官方是这么解释线程优先级的：**线程优先级并非完全没有用，设置线程优先级至少具有统计学意义。总的来说，高优先级的线程占用CPU的执行时间多一点，低优先级的线程占用CPU的执行时间会短一点。**

总之，线程优先级由于它的不确定性，仅具有统计学意义。对日常的开发意义不大，了解即可。

该方法和`yield()`方法类似都不常用。

## ⭐⭐ 多线程实现方式二

基于`Thread`类的另外两个构造器来实现创建`Thread`类的对象，从而实现多线程

方式一：无参和单参（指出名字）

方式二：单参和双参（指出名字）

基于`Runable`接口

```Java
Thread(Runnable target)
Thread(Runnable,String)
```

### 步骤：

1. 定义一个子类A，实现`Runnable`接口并**重写`run`方法**。

2. 创建A类的对象。

3. 使用构造器：

   ```java
   Thread(Runnable target) 
   ```

   来新建`Thread`类的对象，然后将A类的对象作为参数传递。

4. **调用`Thread`类的对象的`start`方法，这时会启动一个新的线程，并且JVM会自动调用重写`run`方法。**

### 注意事项

1. （🟡 重点）`Runnable`接口的实现类并不是表示一个线程，而是表示一个在线程中执行的任务：`XxxTask`

2. 利用`Thread`类的构造器，将`Runnable`接口的实现类对象作为一个任务传递给`Thread`对象

```Java
Thread t = new Thread(new ATask());
```

3. `Runnable`是一个功能接口

使用Lamba表达式

`Runnable`对象作为参数，就是传入一个重写的`run`方法。把一个方法作为参数传递，这就是**回调方法**。回调方法的实现普遍采取匿名内部类以及Lambda表达式来实现。

> 补充：注意父类中`run()`没有抛出异常，重写方法时也不能抛

注意：Lambda表达式在这里有个小问题，不方便传参。

> 为什么执行`Runnable`接口中的`run()`而不是`Thread`中的`run()`?
>
> 在`Thread`类当中存在一个成员变量：
>
> ```java
> private Runnable target;
> ```
>
> 用`Runnable`接口新建`Thread`类对象时，该成员变量会被赋值。大致代码（源码会更复杂一点，但大体逻辑是这样的）如下：
>
> ```java
> Thread(Runnable target){
> 	init(target);
> }
> 
> void init(){
> 	this.target = target;
> }
> ```
>
> 而`Thread`类的`run`方法是这样设计的的：
>
> ```java
> @Override
> public void run() {
> 	if (target != null) {
> 		target.run();
> 	}
> }
> ```

>⭐ （面试题）多线程有哪些实现方式？
>
>答：三种，但是不管方式1，2，3都是基于`Thread`类创建的，只不过是用的构造器不同。方式1是...

 🏷️两种实现方式的比较
 1. 方式一必须直接继承`Thread`类，而Java是单继承的，方式二则没有这种限制。
 2. 方式二把线程对象和执行的任务分开定义，这在设计上称之为“解耦”。关联越少，越有利于各自的修改。**由于解耦，方式二将任务和线程分割了，所以多个线程可以同时做同一个任务。这样更有利于线程间的数据共享。**同样的把对象和执行的任务分开定义的解耦方式，有动态代理中的`invocationHandler`。

 但这两种方式归根结底都是基于`Thread`类的，所以包括API使用在内的很多地方是差不多的。

## 线程生命周期（初版）

（看图哦）

### 操作系统层面理论上的线程状态

1. **新建：**刚`new`出来的线程对象，此时还没有`start`，线程并没有启动。
2. **就绪：**刚刚`start`的一个线程。（但是没有执行）
3. **执行：**“抢”到了CPU执行权一个线程。
4. **阻塞：**没有CPU的执行权，但也不是就绪和死亡的状态。而是由于缺少一些必要的条件处于非执行状态的线程。（典型的比如处于`sleep`状态的线程）
5. **死亡：**已经执行完毕`run`方法，已经完成任务的线程。

线程最重要的一个状态是阻塞。

⭐ ***阻塞结束之后不是执行而是重新回到就绪状态！！！！***

🟡 被抢走执行权和`yield()`方法都会从执行状态回到就绪状态

⭐ 成为阻塞状态的3种情况：

1. `sleep()`;
2. 被执行`join()` ;
3.  IO阻塞

### Java代码层面的线程状态

`Thread`类当中有一个枚举类型`State`规定了5种状态(`WAITING` , `TIMED_WAITING`, `BLOCKED`)

1. `NEW`：至今尚未启动（未start）的线程处于这种状态。 
2. `RUNNABLE`：正在 Java 虚拟机中执行的线程处于这种状态。 
3. `BLOCKED`：受阻塞并等待某个监视器锁的线程处于这种状态。 
4. `WAITING`：无限期地等待另一个线程来执行某一特定操作的线程处于这种状态。 
5. `TIMED_WAITING`：等待另一个线程来执行取决于指定等待时间的操作的线程处于这种状态。 
6. `TERMINATED`：已退出的线程处于这种状态。

处于就绪和执行状态都是`RUNNABLE`

`BLOCKED` \ `WAITING` \ `TIMED_WAITING`属于理论中的阻塞。



