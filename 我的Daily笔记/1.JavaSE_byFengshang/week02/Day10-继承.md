问题

> 描述一下new对象的过程
>
> 1. `new`关键字用于实例化一个新的对象。它告诉Java虚拟机要分配内存以存储新对象的实例变量。
> 2. Java虚拟机根据对象的类信息，确定需要分配多少内存空间来存储该对象的实例变量。这个信息在编译时通过类的定义确定。
> 3. Java虚拟机在内存中为对象分配空间，并将分配的内存初始化为默认值（例如，整数默认为0，布尔类型默认为false，引用类型默认为null）。
> 4. 执行对象的构造函数。构造函数是一种特殊的方法，它初始化对象的状态。通过构造函数，可以对对象的实例变量进行赋值、执行其他必要的初始化操作。
> 5. 构造函数执行完毕后，`new`表达式返回一个指向新对象的引用。通过该引用，可以访问和操作对象的实例变量和方法。

> JVM类加载是什么过程？一个对象是怎么创建的？
>
> > 类加载时执行静态成员变量的赋值和静态代码块，`new`对象过程中执行显式赋值，构造代码块和构造器。

 🔔命名规范：包名名词时不要加s,类名工具类这种加s

开发中，尤其要注意<u>边界值的测试</u>，测试人员也是中间随便测试一个，然后主要测试边界值是否正常。

> 如何理解如何看待Java面向对象？
>
> >区分概念：”面向对象的编程思想“和”面向对象的语言特性“。
> >
> >面向对象的编程思想：一个程序，只要以“对象/个体”为核心进行编程都是面向对象的编程思想，这个“对象/个体”可以是任何合理的结构。在C语言中，可以把结构体看成类似对象的个体，以它为核心进行编程，就是具有面向对象编程思想的程序。
> >
> >面向对象的语言特性：明确了类，对象的概念，增加访问权限，封装，继承，多态等明确的面向对象的语言特性。所以我们常说，Java是面向对象的，实际上是说Java具有面向对象的语言特性，但用Java编程，究竟写出来的程序是不是具有面向对象思想，要看怎么编码，用Java也完全可以写出具有面向过程思想的程序。
> >
> >程序规模越来越大，可复用性要求越来越高
> >
> >优点：
> >
> >面向对象思想模块化编程，各个模块之间低耦合。
> >
> >面向对象思想可以复用代码，以便更好得以应用需求变更
> >
> >缺点：
> >
> >内存开销大运行效率低，解决办法是提高硬件性能们直接在服务器上跑程序。

# 封装

面向对象的基础

面向对象的三大语言特性：封装、继承、多态

狭义上的封装是指java中的class，只要把数据和操作绑定在一起就是封装。

## 封装的目的/意义（广义上的封装）：

定义一个类的目的是为了将数据保护在内部。封装就是为了将数据保护在内部，是为了尽可能地隐藏内部的细节，只保留一些对外<u>“接口”</u>（广义上的接口）使之与外部发生联系。

对于Java而言，封装从语法上来说，这种将数据隐藏在内部，也就是私有化成员变量，然后如果外界有访问数据的需求，需提供成员方法（相当于“接口”），给外界访问。

## 封装，从语法上来说，就是Getter/Setter方法。

Getter/Setter方法实际上就是成员方法来完成成员变量的访问和赋值。

## 明确以下几点：

> 1.建议在实际的开发中，成员变量的访问权限，在不确定的情况下，一律给private。私有化之后，根据情况，提供Getter/Setter方法
>
> 2.自动生成“Alt + Insert”
>
> 3.`Getter`/`Setter`优点:
>
> a.让成员变量的读写分离了，不再是以往“对象名.”一体的形式了
>
> b.从不可控变为了可控
>
> c.可以根据情况来选择提供或不提供或提供部分，选择的权力在程序员自己手中。

**关于Getter/Setter方法的注意事项**

1.实际开发中有更好的控制手段，比如框架（框架就是用来管理操作对象的）提供的注解

2.**（重点）在实际的开发中**，**Getter/Setter方法普遍提供给框架使用**

a.不要修改Getter/Setter方法的实现用于控制访问或赋值，一律自动生成即可

b.既然不是给程序员用的，所以Getter/Setter方法的定义应该将它放在最后面，或者直接加上一个注解

3.布尔类型自动生成的Getter方法名不是"getXxx"而是"IsXxx",这样在框架使用时可能会出错。

*真正的封装是:经过深思熟虑，依靠精巧的设计，暴露给外界“功能完善但最少”的接口，并使具体的内部实现完全对外透明。*

# 继承

*（重点1.）继承中两个类的关系和引用数据类型的类型转换*

*（重点2.）继承的层次*

*(重点3.)(最核心)子类对象的初始化问题*

*（重点4.）(最最核心)**继承中的方法覆盖**【之所以继承，从某种意义上讲是为了方法的覆盖】*

## 继承的引入

> 复用的需求解决办法：
>
> a.对代码的复用使用方法
>
> b.对类的成员的复用使用继承

关键字 extend

subclass extends superclass

 **子类继承父类，会得到父类的<u>所有成员</u>，成员指的是：成员变量和成员方法，<u>不包括静态成员和构造器</u>。**

## （重点）理解继承的本质

> 继承为什么使用关键字extends?
>
> > 继承的本质就是扩展，而不是单纯的inherit。子类继承父类，除了得到父类的成员外，<u>还可以自定义自身的成员</u>，也即是子类可以在父类的基础上，扩展属于自身的功能。Java的继承，实际上是子类扩展父类。

## 继承中两个类的关系

子类“is-a”父类（子类是一个父类）

1.从代码角度直观理解

即，父类引用指向子类对象，把子类对象当作父类类型来使用

```Java
//子类对象可以用一个父类引用 接收
Father fs = new Son();
//即，父类引用指向子类对象，把子类对象当作父类类型来使用
```

2.定义了一个类就是定义了一个全新的数据类型，定义一个类就是定义了数据＋操作。

3.直观的逻辑角度就是Student类就是Person类

## 引用数据类型的类型转换

### 分两类

> > 自动类型转换
>
> > 强制类型转换：编译器不会自动进行转换，需要程序员写额外代码

自动类型转换：把一个子类引用赋值给父类引用

```Java
Son s = new Son();
Father f = s;
```



> **两个问题**
>
> > 1.引用数据类型的类型转换，前提条件是什么？
> >
> > 答：是继承。引用数据类型的类型转换，必须发生在具有继承关系的两个类型之间。
>
> > 2.引用数据类型的类型转换，转换的是什么？（引用数据类型 = 引用 +对象）
> >
> > 答：转换的是引用的数据类型。

>**自动类型转换的条件**
>
>> 把子类引用转换成父类引用时，发生自动类型转换，该过程由编译器自动完成，程序员无需写任何额外代码。
>
>**原因**
>
>> 相当于把一个子类对象当作父类类型来使用，这种操作完全可行。

**引用数据类型的自动类型转换的特殊称呼/简称：向上转型**

### 强制类型转换的条件

> > 把父类引用转换为子类引用时，发生强制类型转换
>
> 语法是：
>
> 强制转换后的子类类型 对象名 = (强转后的子类类型)被强转的引用/匿名对象；
>
> 但是强转相当于把一个父类对象当成子类类型去使用，这在绝大多数场景中都是不可能的，只有极少数才能成功。这些极少数的条件，我们称之为“引用数据类型的强转类型转换”

> 转换成功的条件很重要（多态的时候再讲），如果转换异常，`ClassCastException`

**引用数据类型的强制类型转换的特殊称呼/简称：向下转型**

## 继承的优缺点

### 继承的优点

1.继承的出现，弱化了类型的约束力，打破了Java引用数据类型的类型限制，<u>使得引用数据类型之间出现了类型转换。</u>这其实是Java实现面向对象的第三个特征——多态。

2.提高代码的复用性，有利于功能的扩展，提升了程序的可维护性，更好地应对需求变更。

（数据库的字段概念就是Java中的成员变量）

### 继承的缺点

1.父类中的修改<u>会严格地体现到</u>子类当中。

（扩展 实际上Java对这种问题，可以用语法”方法的重写“来进行弥补：子类继承父类方法，可以修改父类方法的实现。）

## （重点）继承层次

> "Class cannot extend multiple classes"

单继承：Java中，某个类最多只有一个<u>直接父类</u>

继承层次(hierarchy)：由某个祖先类派生出来的所有类的集合叫做继承层次。

### （重点）**继承链**：从某个子类开始，到其祖先类的路径。

在一条继承链中，下游类（子类）总可以看成一个上游类（父类），存在"is-a"关系。

从代码上看，下游类（子类）的对象总是可以用上游类（父类）的引用指向。Object的引用可以指向任何对象。

不在一条继承链中的类没有任何关系。

*文档《jdk6》*

继承层次，继承链和Java引用数据类型转换的关系

> 结合继承层次，具体而言：
>
> （重点）引用数据类型的类型转换，只能在同一条继承链当中进行类型转换。
>
> 向上转换类型，是自动类型转换；向下转换类型，是强制类型转换。

## 继承的限制

> 父类的所有成员（以及构造器）都可以被子类继承使用吗？
>
> 1.父类的构造器能不能被子类继承？
>
> 答：不能。Constructors are not members, so they are not inherited by subclasses！
>
> 
>
> **2.父类的静态成员能不能被子类继承？**
>
> 答：**不能！！**继承的含义指的是子类对象会得到父类的成员，不包括静态成员。
>
> ***但是父子类共享父类成员，不是继承是共享。***
>
> 如果父子类有同名的静态成员，那么就会变成各用各的。
>
> 
>
> 3.（争议）父类的私有成员能不能被子类继承？
>
> 子类继承父类的成员，我们考虑继承的可见性，这取决于访问权限修饰符。

## protected访问权限

protected访问权限只能修饰类中成员或构造器，*不能修饰static*

> protected受保护权限的含义;
>
> > 1.如果同包，可以任意访问
> >
> > 2.**（重点）如果是跨包，只有在子类中才可以访问它父类的protected成员**
> >
> > **注意：这里不是随便可以访问的。**
> >
> > <u>==**只有创建子类自身对象，访问从父类中继承过来的受保护成员。**==</u>
> >
> > 在子类的成员方法中，因为已经有this了所以就不用再new了。
> >
> > 不同包下: 必须在子类中，创建子类自身对象，才能够访问父类中继承过来的受保护成员
> >
> > 3.如果跨包，并且非子类，一定不能访问

作为同包下的子类，访问父类受保护成员的方式：

1.创建父类对象，直接访问父类自己的受保护成员

2.创建子类自身对象，访问从父类中继承过来的受保护成员

3.创建父类其它子类的对象，访问它们从父类中继承过来的受保护成员

使用protected访问权限，普遍用来修饰成员变量/方法，不用来修饰静态成员。

>clone方法是java.lang包下Object类，当中的一个受保护访问权限的成员方法
>
>现有以下类:
>
>a包下的public Student类
>
>b包下的public Student类
>
>a包下的public Test类
>
>以下关于clone方法的调用，说法是正确的是（不考虑异常，只考虑访问权限）：(A D E)
>
>- A.在a包下Student类的成员方法中可以直接调用clone方法
>
>- B.在b包下Student类的静态成员方法中可以直接调用clone方法
>
>- C.在a包下Test类的方法中，创建a包下Student类的对象，可以直接调用clone方法
>
>- D.在a包下Test类的方法中，创建b包下Student类的对象，不可以直接调用clone方法
>
>- E.在a包下Test类的静态方法中，必须创建自身Test对象才能够调用clone方法
>
>- F.在a包下Test类的成员方法中，也必须新建自身Test对象才能够调用clone方法
>
>  >总结，对于某个受保护成员的访问问题：
>  >  1.首先观察访问的位置和定义的位置，是否同包，如果同包，可以随意访问。
>  >  2.如果不同包，先看这个类是不是子类，如果不是子类，肯定没法访问，一定访问不到
>  >  3.如果是不同包下的子类，就一定要创建这个子类自身对象，然后访问子类自身从父类继承过来的受保护成员

扩展：

方法的重写：子类继承父类的方法，可以选择性地重写父类方法的实现，可以修改访问权限。

## 子类对象的初始化问题

> 背景：`JVM`通过类加载了解一个类型，从而能够完成创建对象，或者其它的一些操作。在继承中，子类会继承父类的成员，**创建子类对象可以直接访问父类中继承过来的成员**。
>
> 问题：父类的成员变量也需要赋值，那么赋值顺序是怎样的？赋值结果是怎样的？为什么会体现出这种特点？

> 子类对象的初始化问题：
>
> 研究子类创建对象时，父类的成员从何而来，父类成员变量的赋值等相关问题。
>
> >1.类加载，创建子类对象，会类加载父类吗？顺序是什么？
> >
> >2.类加载结束后，创建子类对象，会连带创建父类对象吗？
> >
> >3.创建子类对象时，对象中成员变量的赋值顺序是什么呢？为什么是这种顺序呢？
