# `static`关键字

## `static`引入

## `static`的语法

不是独属于某个对象，而是属于全体对象所共享的属性，**属于类的变量**，即静态成员变量。

三种变量类型：局部变量，成员变量，静态成员变量。

定义：被全体对象共享，属于类的变量，存储在一片能够被全体对象所共享的内存区域。

*对于hotspot虚拟机 静态成员变量（对象）就存储在堆空间上。（《深入理解Java虚拟机》）*

> 成员变量和成员方法，统称为成员，属于对象

> 静态成员变量和静态成员方法，统称为静态成员，属于类的，被全体对象共享。

静态成员变量 

静态成员方法

```java
[访问权限修饰符] static 返回值类型 方法名（形参列表）{
    //方法体
}
```

1. 静态成员变量禁止“对象名.”方式访问

2. 应该用“类名.”来访问

3. 静态成员变量和成员变量一样具有默认初始化

静态成员方法的调用和上述一样，也要用“类名.”

**<u>特殊的，当在同一个类当中，调用自身static静态成员方法，可以直接写“方法名”来调用，类名可以省略</u>**

对于类的静态成员，即便不创建任何该类型的对象，也可以直接用“类名.”访问。

## static原理

```Java
class Team{
    pulic static salary;
}
```

随着类加载的完毕，静态成员就存在了，并且能够使用(理解类加载的过程就易理解下面)

1. 静态成员变量在类加载过程中完成默认初始化具有默认值，然后进行一些其它赋值，类加载结束就可以访问了。

2. 静态成员方法的二进制指令集合在类加载过程也准备完毕，可以调用。（方法的存储是将二进制指令合集存在方法区）

🔔严格区分两个过程：

1. 类加载的过程；

2. 创建对象的过程

这两个过程都会执行属于自身阶段的代码，是不同的

**最重要的推论）**

1. 一共5种类加载时机。

访问类的静态成员，会触发类加载，这是一种典型的类加载的时机。

> 已学的3种时机：
>
> 1. new对象
>
> 2. main方法执行时
>
> 3. 访问静态变量🔔 

注意类加载只有一次。

2. (最重要)类加载只有一次，所以类的静态成员变量只有一份，在整个类的全局唯一。这是静态成员变量最重要的特点：**全局唯一**。（为什么在开发过程中把一个变量变为静态呢，因为静态变量，全局唯一）在任何场景下，都不应该使用“`对象名.`”访问静态成员！！

在类加载过程中，**给静态成员变量赋值**，有以下手段：

1. 默认初始化，具有默认值

2. 显示赋值，定义时直接给出一个初始值

某个类的类加载过程中，会执行一个“`clinit`”方法，该方法是JVM自动封装的一个方法，JVM会把类加载过程中会执行的代码封装到该方法中。

目前已知的会被封装的代码：静态成员变量的显示赋值。

如果有多行“静态成员变量显示赋值”的语句，会按照代码书写顺序，从上到下封装执行。

静态成员方法可不是在类加载过程中，会自动被调用的方法！！因为所有方法不调用不执行，必须间接或直接在main方法中调用才会执行。

## 比较三种变量的区别：

> **成员的所属**
>
> ​	成员变量：属于对象
>
> ​	局部变量：作用域内部生效
>
> ​	静态成员变量：属于类
>
> **在内存（JVM运行时数据区域）中的位置**
>
> ​	成员变量：堆中的对象中
>
> ​	局部变量：方法栈帧中
>
> ​	静态成员变量：（Java8）堆上
>
> （重要，决定用法）**在内存中出现的时间**
>
> ​	成员变量：new对象后
>
> ​	静态成员变量：类加载后
>
> > ​	类加载在前，new对象在后，所以静态成员一定先于普通成员出现在内存中
>
> ​	局部变量：方法调用后
>
> **调用方式**
>
> ​	成员变量：“`对象名.`”
>
> ​	静态成员变量："`类名.`"
>
> ​	局部变量：在作用域内部直接用变量名使用
>
> （重点）**内存中的个数**
>
> ​	成员变量：<u>对象有多少个，就有多少个成员变量</u>
>
> ​	静态成员变量：只有1个
>
> ​	局部变量：可以有多个

## 比较静态方法和非静态成员方法：

静态和非静态各自之间都是可以直接互相访问的。

> 1. 在静态方法中，能否访问非静态的成员，为什么？
>
>    不能。
>
> >静态方法中没有this,没有当前对象，所以是不能访问非静态的。因为非静态属于对象，必须有对象，才能够访问。
> >
> >在静态方法调用时，就只经历类加载的过程，静态
> >
> >方法不依赖对象去调用，完全可能是没有对象的，没有对象就不能访问非静态。

> 2. 在普通成员方法中，能否访问静态成员，为什么？
>
>    可以。
>
> > 可以访问，既然能够调用成员访问，说明已经创建了对象，该类型也一定加载了，所以静态成员就一定可以用。

总之，关键在于搞清在内存中出现的时间，后出现的可以直接访问先出现的。

静态成员变量，在类中的所有位置都是直接访问的（因为它出现的最早），所以有些人会把静态成员变量称之为“全局变量”（Java中没有明确的“全局变量”概念。）

## `static`使用场景

静态成员变量和静态成员方法的使用场景：

静态成员变量有以下两个主要特点：

1. 静态成员变量是属于类的，被整个全体对象所共享，

2. 静态成员变量在类的全局唯一

> 学语法最后的效果：运用自如。

静态方法的主要优点：**直接调用，无需创建对象。**

成员方法需要创建对象后再使用。

（**重要**）<u>当一个类中全部都是静态成员方法时，类中的所有方法的调用都可以使用类名点去完成，这就是Java当中的“工具类”。</u>

比较常用的<u>工具类</u>：数组工具类`Arrays`，集合工具类`Collections`，数学工具类`Math`

注意：只有静态的成员变量，没有静态的局部变量。即当一个变量写在局部位置时，许多局部变量都无法使用修饰符。

读程序要分清是类加载执行还是new创建对象时执行。

> 类加载的连环触发
>
> clinit方法栈帧依次进栈

> 匿名对象
>
> anonymous object
>
> 没有引用的对象。在创建对象时，就没有引用指向的对象，就是匿名对象！

# 代码块（重点）

代码块的分类，根据其位置和声明方式的不同，可以分为：

1. 局部代码块（局部代码块没有特别作用，为保证可读性，尽量不嵌套局部代码块）

2. (🎶)**构造代码块**：**直接定义在**成员位置的一个"`{}`"代码块

3. **静态代码块**：**直接定义在**成员位置的一个"`static {}`"代码块

4. 同步代码块：同步是线程中的概念

## 构造代码块的作用

构造代码块随着构造器的执行而执行，是给成员变量赋值的补充手段。

构造代码块中也有隐式的`this`传参，指向当前对象，构造代码块当中也是存在当前对象的。

> 总结目前为止给对象中成员变量赋值的手段：
>
> 1. 默认初始化具有默认值
>
> 2. 显示赋值
>
> 3. 构造器赋值
>
> 4. 构造代码块赋值
>
> > “掐头去尾”原则
> >
> > 1. 显示赋值和构造代码块赋值按照代码的书写顺序从上到下执行;
> >
> > 2. 显示赋值和代码块赋值，在整个new对象的过程中，必须执行一次，也最多执行一次。

## 构造代码块的原理

1. 查看反编译代码

   编译器在编译构造代码块的结构时，会<u>智能地根据情况</u>将构造代码块中代码以及显示赋值的代码放入构造器当中。所谓“智能”是指按照代码书写顺序从上到下执行代码块和显示赋值。

2. 构造代码块或显示赋值的代码，在放入构造器时，会放在构造器代码的上面以保证构造器代码最后执行。

3. 构造代码块或显示赋值的代码，在放入构造器时，类中的每一个构造器都会放，以保证构造代码块随着构造器的执行，一定会执行。

   <u>**独特用途**：如果某个类的所有构造器，都需要一行或者一段代码的执行，那么“提取公因式”，把这些代码放入构造代码块中是最好的选择。</u>

4. 如果某个构造器存在`this`调用自身其它构造器的情况，那么第三条就不成立了，就不会把代码加入该构造器。

> 总结在Java当中，有一个“非静态上下文”的概念

<u>静态上下文依赖类加载</u>，没有对象，没有`this`，比如静态方法就是典型的静态上下文。

> **非静态上下文**：*依赖于`new`对象，依赖于对象*，有`this`，比如成员方法就是典型的非静态上下文（<u>所谓上下文就是可以写代码的地方</u>）
>
> > **1.成员方法**
> >
> > **2.构造代码块**
> >
> > 以上两个结构中的this，表示指向当前对象
> >
> > 成员方法中的this，是一个引用，指向当前对象，实际上就是调用该成员方法的对象
> >
> > 构造代码块在new对象过程中执行，所以它的this指向的就是new创建出来的对象
> >
> > **3.构造器**
> >
> > 构造器也在new对象过程中执行，所以它的this指向也是new创建出来的对象
>
> 关于非静态上下文的结论：
>
> 1. 非静态上下文意味着创建对象，所以它们都可以任意访问静态成员
>
> 2. 成员方法和构造代码块中的this指向表示指向对象，访问属性，调用方法。

## 静态代码块

在类加载的过程中，给类的静态成员变量赋值。

静态代码块的语法

```Java
static {
 //局部位置   
}
```

静态代码块的作用

随着类加载的过程而执行，静态代码块可以看成是一个在类加载过程中，会自动调用的静态方法，用于给静态成员变量赋值。

**总结以下，在类加载的过程中，给类的静态成员变量赋值的手段**

> 1. 默认初始化，永远最先执行；
>
> 2. 显示赋值
>
> 3. 静态代码块赋值
>
> 显示赋值和静态代码块赋值按照代码书写的顺序，从上到下执行。

1. 类加载过程中，JVM会调用一个`clinit`方法，用于在类加载的过程中执行一些代码，给静态成员变量赋值。这些代码包括：
   1. 静态成员变量的显示赋值
   2. 静态代码块中的代码。（<u>反射那一节会讲类加载</u>：加载+连接+初始化）

2. (重点)**类加载只有一次，所以某个类的静态代码块的执行，也只有一次。**

静态代码块的使用场景：

1. 如果一行或一段代码在整个类的全局只执行一次，可以写到静态代码块中。

2. 静态代码块可以完成<u>复杂的静态成员变量的赋值</u>。（向集合里添加数据）

> **（重点）总结一下，代码中所谓“静态上下文”的概念：**
>
> 1. 静态成员方法
>
> 2. 静态代码块

> 静态上下文中是不能直接访问非静态的。

注意：静态代码块也经常被用来测试类加载是否完成。

*类加载细节的补充*

# 导包

## package关键字

Java源文件必然是要放在一个包下。

## 全限定类名

包名+类名：可以唯一确定一个类

## import关键字

写完代码后，最好看一看自己Java文件的开头的导包语句，如果是灰色不需要的，要及时删掉！！！

import的静态导入：

import static 全限定类名.静态成员的名字

静态导入导入的是静态成员（变量和方法）

## 编译单元导致的错误（了解）
