# 子类对象的初始化问题

## 什么是子类对象初始化问题？

> 背景：JVM通过类加载了解一个类型，从而能够完成创建对象，或者其它的一些操作。在继承中，子类会继承父类的成员，**创建子类对象可以直接访问父类中继承过来的成员**。
>
> 问题：父类的成员变量也需要赋值，那么赋值顺序是怎样的？赋值结果是怎样的？为什么会体现出这种特点？

> 子类对象的初始化问题：
>
> 研究子类创建对象时，父类的成员从何而来，父类成员变量的赋值等相关问题。
>
> >1.类加载，创建子类对象，会类加载父类吗？顺序是什么？
> >
> >2.类加载结束后，创建子类对象，会连带创建父类对象吗？
> >
> >3.创建子类对象时，对象中成员变量的赋值顺序是什么呢？为什么是这种顺序呢？

## 类加载的时机（4种）

1.启动main方法

2.new对象

3.访问静态成员

4.触发子类的类加载，会优先类加载它的父类（“先父后子”）

> **子类触发的类加载要和<u>类加载连环触发分开</u>**，类加载的时机是指，一旦有子类要加载，直接真的从父类开始，不是clinit方法连环调用的过程。类加载连环触发是clinit方法的连环调用。

类加载结束，开始进行new对象过程。

new对象在程序员看来就是构造器方法帧进栈的过程，按照从上到下的顺序执行显示赋值和构造代码块，最后执行构造器代码。

> 如果创建一个子类对象，那么该对象要存储父类的成员变量，如何存呢？
>
> 答：首先要明确，这个子类对象，会同时存储父类成员变量和子类成员变量，在一个子类对象中被划分为两个区域：
>
> a.存储自身成员变量的区域
>
> b.存储直接父类成员变量的区域

内存区域图：

this关键字：指向当前对象

super关键字：指向子类当中父类成员的区域

> 子类对象已经创建完毕了，内存划分已经完成了，此时需要考虑给子类对象的父子类成员变量的·赋值顺序。
>
> 先父后子。先把父类中的所有赋值手段执行完毕，再执行子类的所有赋值手段。
>
> 通过保证父类的构造器和子类构造器执行的”先父后子“来保证的。
>
> 只要在子类构造器中第一句调用父类构造器就可以实现。

在某个类当中，在构造器当中，如果构造器方法体的第一行没有直接用this或者super表示调用其它构造器，那么永远隐含"super();"，表示调用父类的无参构造器。

为了显示赋值，可以在子类构造器的第一行，直接用”super（实参列表）；“直接调用父类的有参构造器，给父类的成员变量赋值。

**所谓的子类对象初始化，在创建子类对象的过程中，无论是隐式初始化，还是显示初始化，最终都是要保证”父类的构造器先于子类构造器执行“也即”父类的所有赋值手段，都要先于子类中所有的赋值手段“。**

> 子类对象初始化过程中，需要注意的事项

1.如果某个类作为父类，且没有默认构造器时，注意其子类对象隐式初始化就无法完成。此时要么给父类加上无参构造器，要么在子类中显示调用父类提供的有参构造器。

**2.（重点，总结构造器的作用）**

构造器的作用是new对象过程中，给自身成员变量赋值

既然只是赋值，那么：

a.new某个类的对象，该类的构造器执行多个（该类存在this调用同类构造器）

b.new某个类的对象，执行其它类的构造器（执行的是父类构造器）

c.没有new某个类的对象，但是它的构造器执行了（new的是它的子类对象）

3.super关键字和this关键字在构造器当中使用时，都具有特殊作用：都可以用于表示调用构造器。但是都必须在第一行，即表示调用构造器时不能同时存在，只能有一个，**而且必然有一个。**写了就有，不写就有"super();"

## super 和this的异同

这是两个Java面向对象当中的关键字

它们相同的地方在于，

1.构造代码块

2.构造器

3.成员方法

不同点：

1.this 就是真的指向当前对象。super是指向当前子类对象内存区域的父类对象

2.this.表示访问子类成员 加 父类成员，super.表示访问父类成员

如果父子类没有出现同名成员时，this可以同时访问父子类成员。

但是如果出现同名，this.仅表示子类自身成员，super.表示父类成员。就可以以此区分父子类同名成员

3.this指向自身子类对象，所以this访问子类自身不受任何权限的限制；但super毕竟表示父类，所以访问权限受限

## 继承中的属性隐藏（了解，知道）

属性的隐藏现象

属性之所以体现为隐藏，是由于“对象名.成员变量名”的访问机制决定的，是语法机制决定的。

**重点在于探究“对象名.成员变量名”的访问机制**

> 研究方向：
>
> - 访问的范围，该“对象名.”能够访问到哪些成员变量
> - 访问的结果，该“对象名.”能够访问到这个成员变量，且最终的结果是什么

“对象名/引用”的三种创建方式：

- 创建父类对象，用父类引用指向父类对象
- 创建子类对象，用子类引用指向子类对象
- 创建子类对象，用父类引用指向子类对象

 “对象名.成员变量”的访问范围只需要关注引用的数据类型就可以了。

> 引用决定了编译器如何看待这个引用数据类型.引用是何种类型，编译器就会认为该引用数据类型是何种类型。

“对象名.成员变量”的访问结果也是根据引用的数据类型决定。

**（重点：最终结论）“对象名.成员变量”都是根据引用的数据类型决定**

> <u>（重点）扩展一：父类引用指向子类对象和子类引用指向子类对象的区别</u>
>
> >区别在于引用的数据类型不同，从而导致通过"对象名."操作对象时，访问范围发生变化。换句话说，父类引用指向子类对象会限制子类对象的功能，子类对象的独有功能，父类引用指向子类对象都不能访问了。
> >
> >“父类引用指向子类对象”的优点在于多态。
>
> 扩展二：存在继承后，alt + insert自动生成构造器。子类构造器必然调用父类构造器，所以会先选择父类构造器。
>
> 扩展三：静态成员变量在父子类中的同名问题。
>
> >它们是两个互相独立的静态成员变量，互相不影响。

## （重点）继承中的方法覆盖

有既定的语法。

不同于隐藏的**<u>代码现象</u>**叫方法的覆盖或者方法的重写(override)。

当然在子类中用"super."还是可以调用的，这是因为方法覆盖不是物理意义上的覆盖，而是由于<u>"对象名.成员方法名"的**调用机制决定**的。</u>

> (重点)研究“对象名.成员方法名”的调用机制

>首先研究访问范围，因为访问范围是编译上的概念，所以还是看引用:
>
>1.引用是父类类型，访问范围是父类
>
>2.引用时子类类型，访问范围是子类+父类

>（重点）研究调用方法的结果
>
>“对象名.成员方法名”的调用结果要根据对象的具体类型来确定。是何种对象，就体现出它的行为。
>
>**尤其是父类引用指向子类对象，父子类出现同名方法时，调用该同名方法，结果是子类的行为。**

（重点）具体语法

写一个注解，"java.lang.Override"

```Java
@Override
```

该注解写在子类重写父类方法的声明上面

如果该注解和方法体都没有报错，说明该方法确实是重写自父类

反之，则不是方法重写，对于注解@Override的使用，只要是方法重写，后续一定要写！！！

>使用注解的好处？
>
>1.该注解可以检测重写是否成功
>
>2.提高代码的可读性

父类的成员方法格式：

```Java
[访问权限修饰符] 返回值类型 方法名(形参列表){
    //方法体
}
```

1.“访问权限修饰符”：子类重写父类方法的访问权限可以保持一致，可以更宽松，但不能更严格

2.“返回值类型”：保持兼容。

> 自己测试
>
> void:不能改
>
> 基本数据类型的返回值类型：不能改
>
> 引用数据类型的返回值类型

3.“方法名”：不能改，因为重写就是父子类具有同名的方法

4.“形参列表”====：不能改，必须完全保持一致。当然形参的名字不影响方法的调用，改变名字是无所谓的

5.“方法体”：无要求。

> 面试题：override和overload
>
> 相同点：
>
> 都是多个方法，而且都要求方法名相同
>
> 不同点：
>
> ​	1.方法重写的前提是继承，至少发生在两个类之间；方法的重载在一个类当中；
>
> ​	2.方法重写要求访问权限保持一致或更宽松，方法重载则无所谓没有要求
>
> ​	3.方法重写要求返回值类型保持兼容，方法重载则无所谓
>
> ​	4.（核心截然相反）方法重写要求形参列表必须一致，而方法的重载必须不同

> 方法重写的注意事项：

1.（重点）

如何快速，规范的重写父类方法？

> 两种方式：
>
> ==1.Alt + Insert==:一次性重写多个方法
>
> 2.如果明知重写父类的某个方法，那可以直接在子类类体的空白处，写父类方法的名字，然后根据提示回车即可。

2.父类中的所有方法都能够被子类重写吗？

>3种不能被重写的方法：
>
>a.构造方法和
>
>b.静态方法是不能被继承的，所以不能被重写。
>
>c.私有方法以及<u>所有父类中对子类没有权限的方法</u>都是不能被子类重写的，虽然能继承，但没有权限访问，自然就不能重写。

*课堂上的例子*

执行父类的时候子类还没有执行任何赋值语句。

引用是什么是没有关系的

只要调用这个方法都要体现出子类的行为这就是方法重写。
