每日问：

1. 类加载过程中执行和`new`对象过程执行的结构

2. 静态成员变量显示赋值和静态代码块

3. 成员变量的显示赋值和构造代码块和构造器

# 类加载细节补充

一个类只有当完完全全确定不会用到才卸载，这种情况很少。

1. 加载：类加载的开始是I/O的过程，该过程作用是：<u>将字节码文件读到方法区</u>

2. 连接：验证（检验字节码文件的正确性和安全性）+ 准备（**执行静态成员变量的默认初始化**）+解析（用来把“符号引用”转换为直接引用）

   【符号引用&直接引用的知识需要补充：`JVM`虚拟机的规范】


3. 初始化：
   1. 执行`clinit`方法，也就是执行静态成员变量的显示赋值和静态代码块（按书写顺序由上到下执行）
   2. 类加载的时机，实际上指的是类初始化的时机，指的是碰到这些场景就一定要初始化这个类。
   3. “类加载只有一次”更准确的说是“类初始化只有一次”
   4. 初始化的步骤只是执行`clinit`方法，目的是赋值，而`JVM`真正了解认识类型的过程，是加载和连接的过程，**某个类只要开始了初始化，在JVM看来它就已经在内存中可用了！**


初始化过程是程序员可以看到的，别的过程看不到

> 两个例子
>
> > 构造代码块先执行的例外，关键在于对<u>b的值为0</u>的理解：只要能访问就有默认值，所以b是0.（但是问：要想访问不得有一个声明，static int的过程）

# 访问权限修饰符

c语言没有访问权限的概念

**访问级别：访问权限的级别是依赖包(package)实现的**

4个级别：

|                | private | 默认 | protected | public |
| -------------- | ------- | :--: | --------- | ------ |
| 同类中         | ✔       |  ✔   | ✔         | ✔      |
| 同包的类       |         |  ✔   | ✔         | ✔      |
| 不同包下子类   |         |      | ✔         | ✔      |
| 不同包下所有类 |         |      |           | ✔      |

> 注意：默认访问级别 = 缺省访问级别 = 包私有访问级别(package-private)。 该访问级别不是"`defalut`"， 不对应任何关键字，只需要在写访问权限修饰符的位置保持空着，所以叫“缺省的访问级别”。

注意事项：

1. 非`public`的`class`不能跨包使用

2. 类的权限要大于类中结构的权限，如果不能访问某个类，那么类中结构必然也不能访问（类有一个双层保护的作用）

3. （了解）为什么定义类时，只有两种访问级别？

   <u>单独定义一个`class`是独立的概念</u>，没有对谁私有，受谁保护的概念，当定义内部类时有访问级别。抽象类，接口，注解，枚举等的访问权限和`class`是一致的。

4. 修饰类时有两个，修饰类中的成员和构造器的访问权限可以使用4种。

**构造器在**类中定义，意味着`new`对象赋值的方式，在后续`new`对象方式时，都需要考虑构造器的访问权限。

## Java高级特性

### 反射 可以破解私有权限

1. 工具类：类中所有方法都是静态方法的类是工具类。工具类在使用时，不需要创建对象，直接"`类名.`"使用即可。所以工具类都应该私有化构造器。

    🔔私有化构造器是定义工具类的第一步。

2. 中间方法，过程方法私有化。类中的方法，如果需要给外界使用，用`public`来修饰，而实现这些`public`方法的中间方法，过程方法，对外界是没有意义的，所以这些方法私有化。

使用原则：尽量私有化，尽量少的给予访问权限，尽量少给`public`。

