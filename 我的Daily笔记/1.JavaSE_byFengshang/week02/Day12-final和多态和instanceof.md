# final关键字

final是个修饰符关键字 可以修饰 类，方法，变量

重点看修饰变量（成员变量、静态成员变量和局部变量）

## final修饰类

表示该类不能被继承，注意不要和修饰方法搞混淆了。

> final修饰类语法

```Java
[访问权限修饰符] final class 类名{
    //类体
}
```

[修饰符列表]中的访问权限 final static顺序没有强制语法要求，但仍要注意书写规范

final修饰类的场景:

常见在`JDK`源码中：String类,System,Scanner,Void,四类八种基本数据类型的包装类（由于基本数据类型不是对象）。保证其安全性

数组既可以装基本数据类型也可以装引用数据类型 集合只能装引用数据类型，为了能在集合中也使用整型等概念，使用包装类将int包装成Integer类。

## final修饰方法

final修饰方法的语法：

```Java
[访问权限修饰符] final 返回值类型 方法名(形参列表){
//方法体
}
```

1.**表示该方法<u>不能被重写</u>。但是可以被继承！**📣重点⭐

2.使用场景：常见于源码中，常见的有：Object类中的`getClass（）`方法还有其中和线程相关的方法。

> 不是所有方法都可以被final修饰
>
> 1.构造器，不能用final修饰，它本身也不能被继承，不需要final
>
> 2.静态方法，因为不能被继承，当然不能被重写，如果用final编译器会提示
>
> 3.`private`方法，同静态方法一样，可以加但属于画蛇添足

**总结，一个类中4种方法不能被子类重写：**

> ​	1.构造器
>
> ​	2.静态方法
>
> ​	3.私有方法以及所有子类没有权限的方法，没有权限进行重写
>
> ​	4.`final`修饰的方法

## final修饰变量

表示常量。（常量表示在整个程序期间，值不会再改变，**不具有改变的可能性。**）

**final修饰变量，可以修饰：**

> 1.局部变量（少有的修饰符之一）
>
> 2.成员变量
>
> 3.静态成员变量

关于常量

> 常量分类有两种：
>
> 1.字面值常量（直接在代码中出现的整数，小数，布尔值等常量）；
>
> 2.自定义常量，也就是final修饰的变量。

明确三点：

1.final修饰变量，便是常量，也就是Java当中的自定义常量。

自定义常量的命名（重点）

```java
所有单词字母全部大写，单词之间用"_"下划线隔开
MAX_VALUE,MIN_VALUE
```

注意：该规范约束力不强。**final修饰的静态成员变量**要采用该方式！

2.（重点）

final修饰变量表它是一个常量，那么除了取值不变成为常量外，该变量的<u>使用方式，生命周期，内存中的位置等</u>都和被修饰的变量一样不会发生改变。（注意回顾三种变量的区别）

3.（重点）

final修饰引用数据类型，表示修饰的是引用，表示引用不可变，即引用中存储的地址不变，即引用不能再次指向新的对象。但是，仍然可以通过这个不可变引用改变对象中元素的取值，改变元素的状态。

**final修饰局部变量**

>一个方法的定义，其中的局部位置有：
>
>1.形参列表
>
><u>test(final int a)，并不表示调用该方法需要传入常量，而是该参数一旦传入方法，就不可以修改了。</u>
>
>```Java
>public static int test(final int[] arr){}}
>```
>
>2.方法体
>
>该常量需要手动初始化赋值，然后就不可以修改了
>
>"Cannot assign a value to final variable 'num'."

**final修饰成员变量**

> final修饰成员变量，表示它是一个成员变量，取值不变，但是使用特点，生命周期，内存中的位置是不变的。

语法：

```Java
[访问权限修饰符] final 数据类型 变量名;
```

> 成员变量和成员常量显著的区别是：
>
> 常量的赋值，只要进行了，就不能再改了，只能赋值一次，所以成员常量，没有默认初始化，它没有默认值，必须手动进行初始化赋值。手动给成员变量的3种赋值手段(1.显示赋值；2.构造代码块；3.构造器)必须选择其一，也只能选择其一。
>
> 尤其注意如果选择用构造器赋值，**必须保证类中的所有构造器都能完成该成员常量的赋值**（尤其是无参构造器要加入赋值语句）。

**final修饰静态成员变量**

> 全局常量：final修饰的静态成员变量
>
> 在类的全局仅有一份。必须选择一种初始化赋值方式。

语法：

```Java
[访问权限修饰符] static final 数据类型 变量名;
```

访问类的静态成员变量会触发该类的类加载，静态代码块会随之执行。但是，访问类的用字面值常量赋值的赋值的全局常量，不会触发类加载，静态代码块也不会执行！（原因在于类加载是懒加载，只有在迫不得已时才加载，主要是为了节省内存开销，提高效率）（常量池：静态常量池，运行时常量池，字符串常量池）

## 练习

```Java
public class Demo{
    public static void main(String[] args){
        byte num1 = 0;
        byte num2 = 0;
        final byte num3 = 10;
        final byte num4 = 20;
        byte result;
        //以下哪些代码能通过编译，哪些不能？
        //result = num1 + num2;
        //result = num3 + num4;
        //result = num1 + num3;
    }
}
```

⭐**表达式的类型提升问题**：byte,short,char任意两个参与运算都会表达式提升。

在有变量参与时，遵循表达式的类型提升；两个常量参与运算，不遵循表达式类型提升。

# 多态(polymorphic)

有继承有方法重写就有多态。作为面向对象的第三大特性。

> 什么是多态（polymorphic）呢？
>
> > 同一个事物，在不同的时刻/情况表现出不同的状态，就可以称之为多态

**在Java中，多态指的是：同一个父类引用指向不同子类对象时，调用同名成员方法，根据指向实际对象的不同，得到的行为也会随之不同**

> 1.同一个事物：同一个引用（父类的引用）
>
> 2.不同情况：指向不同的对象(不同的子类对象)
>
> 3.不同的状态：调用同名方法会体现出不同的行为

**多态的条件**

> 多态的条件/发生的场景：
>
> > 1.继承，必须有父类和子类（而且是多个子类）
> >
> > 2.子类要重写父类中的方法
> >
> > 3.父类引用指向子类对象

**不能发生多态的场景**

> 不能发生多态的场景：
>
> >1.没有继承，比如final修饰的类，不能被继承；
> >
> >2.没有方法重写，以下方法：
> >
> >​	a.final修饰的成员方法
> >
> >​	b.构造器
> >
> >​	c.静态方法
> >
> >​	d.私有以及所有子类没有权限的方法

**多态的访问特征**

> >多态的访问特征：
> >
> >方法的调用结果要根据对象的具体类型来确定。

**一个方法在调用时，实参的数据类型必须和形参数据类型保持一致吗？**

```Java
* 一个方法在调用时,实参的数据类型必须和形参数据类型保持一致吗?
* 不需要完全一致
* 可以保持一致,还有只需要保证实参的数据类型可以自动类型转换到形参数据类型
*
* 以往我们已经用过基本数据类型,现在学了引用数据类型
* 引用数据类型也有自动类型转换(向上转型)
* 所以引用数据类型也符合这一方法调用的特点
*
* 只需要在形参的位置,写父类类型,那么在调用方法时,就能够传入子类类型的对象
*
* 补充: 如果形参的类型是Object,意味着调用方法可以传入任何一个对象
*
* 方法的返回值类型和具体的返回值数据类型也是有这个关系的:
* 当具体返回值的数据类型可以自动类型转换到返回值类型时
* 该返回值是允许的
* 这一条同样适用于基本数据类型和引用数据类型
```



> 子类方法的重写过程中，返回值类型和父类必须保持兼容，什么叫兼容？
>
> 1.如果是基本数据类型和void返回值类型，必须保持一致
>
> 2.如果是引用数据类型返回值类型，那么父类返回父类，子类可以返回子类

## 多态的优缺点

> 用父类引用指向子类对象多了这么多限制，那为什么还有这样的规定呢？

**多态的优点**

1.要实现多态必须要继承，而继承提高了代码复用率，提升了程序的可维护性。（继承保证）

2.有了多态后，用父类引用指向不同子类对象，只需要调用同名方法，就能自动根据不同子类对象，得出不同的行为。
这大幅度简化了代码，提升了程序的扩展性。（多态保证）

**多态的缺点**

多态中存在父类引用指向子类对象，父类引用会限制子类对象的访问范围，只能访问父类中的成员。而不能访问子类独有成员。

**如何应对该缺点？**

> 之所以出现这个问题，是由于父类引用导致的，所以只需要把父类引用转换成子类类型就可以了，这个过程也就是向下转型，引用数据类型的强制类型转换。

# ⭐引用数据类型的强制类型转换（向下转型）

> 向下转型能够通过编译的条件是什么？

必须是把一个父类类型的引用，转换成**同一条继承链当中**的子类类型引用，否则不能通过编译

> 语法是什么？

```Java
子类类型 对象名 = （子类类型）父类类型引用
```

绝大多数场景中会运行出错，抛出异常，`ClassCastException`

> ⭐(重点）能够让代码正常运行的条件是什么？

3个理解方向：

> **1.父类引用指向子类对象，相当于限制。可以完全解除限制回到自身类型，也可以部分解除。**
>
> 2.强转要想成功，强转后的引用，要真的能够指向这个对象
>
> 3.（直接）强转要想成功，要么就是子类对象的类型，要么就是子类对象的父类类型

```Java
引用数据类型的强制类型转换，在开发中比较常见。
基本数据类型的强转，多见于小数取整。
```

## 帮助判断能否强转的关键字`instanceof`

```Java
引用/对象名 instanceof 类名
```

**（重点）用于判断左边引用指向的对象是否是后面类名的对象或者子类对象。如果是，整体返回true，否则返回false.**

```java
if(引用 instanceof 类名){
    类名 对象名 = （类名）引用；
}
```

为了避免类型转换异常，导致程序终止，所以以后写代码时一定要先使用`instanceof`判断再强转。



> *读程序步骤*
>
> 1，看引用决定访问范围
>
> 2，看对象决定方法调用结果，如果子类有方法重写要体现出子类重写的结果
>
> 3，方法调用有多个可以选择时，遵循：就近原则



> 下周安排：
>
> 1.抽象类（一节课）+接口（重要）
>
> 2，内部类+内部类对象（重要）







