# 面向对象

## 比较局部变量和成员变量

> 5个角度
>
> > 1，在类中定义的位置不同
>
> 局部变量定义在<u>局部位置</u>（除了类体的大括号都是局部位置）
>
> 成员变量定义在<u>成员位置</u>（也就是直接定义在类体中）
>
> > 2，在内存中的位置不同
>
> 局部变量：存储在方法的栈帧中
>
> 成员变量：堆上的对象中
>
> > 3，生命周期不同
>
> 局部变量：和方法调用“同生共死”
>
> 成员变量：和<u>对象“同生共死</u>”，*一个对象称为垃圾（引用消失），`GC`将堆上的对象清理之后才完全消失*
>
> > 4，**（重要）有无默认初始化不同**
>
> 局部变量：没有默认值，必须手动初始化赋值；<u>先声明再初始化是局部变量的特点。</u>
>
> 成员变量：有默认值，默认值初始化永远最先进行，不需要手动初始化赋值也可以用
>
> > 5，作用范围
>
> 局部变量：包裹局部变量的`{}`的作用域内部生效；
>
> 成员变量：不是真正意义上的“全局变量”，它不是真的整个类中都可以直接访问。
>
> 在成员方法中，可以任意直接访问同类下的成员变量。注意，加`static`的方法不是成员方法，成员变量不能在其中使用。

## 成员变量的赋值

对象中的元素，默认初始化永远是第一步！

## this关键字

搞清楚数据的最终取值。

"对象名.成员变量" 是**创建对象后**的赋值手段，会覆盖掉所有创建对象过程中的赋值。

`this`关键字：在Java一个类的<u>所有成员方法</u>中，其形参列表都隐式传入了一个参数，传入的就是<u>当前类型的对象</u>，称之为“**当前对象**”，这个当前对象，传入方法后，就可以在方法体中使用“`this`关键字”来使用它，也就是说：“`this`”关键字指向当前对象，它是一个引用。

**什么是当前对象？**

谁调用该方法，谁就是这一次方法调用的当前对象，<u>不同次</u>方法调用，当前对象可能不一样。

### <u>（重点）this关键字有什么用？</u>

1. 成员方法中可以*无条件访问*同类下的成员变量，一个类中的成员方法也可以无条件互相调用。这一切的原因都是隐式传参"`this`"

   换句话说：任何**成员方法**当中，都已经存在当前对象了，所以在成员方法中，访问同类成员变量和调用成员方法是天经地义的。

2. `static`方法当中没有`this`传参，没有当前对象 。既然没有对象，就不能直接访问成员变量和调用成员方法，因为它们都需要对象才能访问。

> 对于方法总结，在一个类当中：
>
> <u>`static`方法和`static`方法之间可以直接互相调用，成员方法和成员方法之间也可以互相调用</u>。

3. `this`是一个隐式传参，所以在一个成员方法中，如果只是简单的访问成员变量或者调用其它成员方法，是没有必要把"`this.`"写出来，可以省略。只有一种情况除外：如果成员方法中的形参名和成员变量名同名，此时就必须写表示访问成员变量。

4. to be continued...


### this关键字常见用途

在一个给成员变量赋值的方法中写以下语句：

this.成员变量名 = （形参）局部变量名；

```Java
this.num = num;
```

## 构造器

constructor源自C++，也就是构造器，构造方法，构造函数

### 第一，基础简单使用

构造器的语法：

```Java
[访问权限修饰符] 类名（形参列表）{
    //构造方法体
}
```

构造方法也是方法，但它是特殊的方法，语法和定义使用都和一般方法不同

**类名的位置必须和当前类的类名完全一致，可以认为类名就是构造器的名字。**

构造方法没有返回值，也不需要写返回值类型。而且极少使用`return`，以后不要写`return`，形参列表可以为空，称之为无参构造。也有有参构造，双参构造，三参构造等。

构造方法体，和一般成员方法类似，也可以写语句。

<u>（重点）**构造方法也隐式传入当前对象，用this引用指向这个当前对象**</u>

构造器的作用：

1. `new`关键字

   **构造方法的作用不是创建对象，而是在创建对象的过程中给对象中的成员变量赋值。**

   一般的方法想要执行，必须在main方法中直接或间接调用，main方法由JVM调用，构造器也是由JVM调用；

2. **创建对象的整个过程都由JVM负责完成，和构造器没有必然联系**

   `new`对象过程中，由JVM调用构造器给对象中的元素属性赋值，<u>调用该类型的构造器只意味着成员变量赋值了</u>，<u>不意味着它的对象就创建了</u>。

3. 虽然程序员没有办法直接调用构造器，但是可以指示JVM在`new`对象的过程中，**由哪个构造器完成赋值**

   ```java
   类名 对象名 = new 类名（实参列表）;
   ```

根据实参列表的不同，指示JVM调用该类型的某个构造器

比如:

```java
new A(18,"hello"):表示JVM在创建A对象时，用A类的双参（int,String）构造器来完成成员变量的赋值
```

构造器的定义：

1. （**重点**）一个类中，如果没有提供任何构造器 ，没有定义任何构造器，那么由编译器在编译代码时<u>默认提供一个无参构造器</u>，提供的默认无参构造器语法是:

```Java
[访问修饰符]类名(){}
```

2. 默认无参是无法给成员变量赋值的，所以如果希望new对象过程中，能够自定义成员变量的取值，需要使用“有参构造器”，有参构造器必须由程序员手动来定义

```Java
[访问修饰符] 类名 (数据类型1 成员变量名1，数据类型2 成员变量名2...){
    this.成员变量名1 = 成员变量名1；
        ...
}
```

3. 同一个类中，多个构造器是方法重载的关系

4. 用构造器给成员变量赋值，属于new`创建`对象过程中执行的赋值手段

### 第二，探讨使用过程中的注意事项

1. 构造器的方法重载问题

   注意形参的名字不同，不能构成方法重载

2. （重点**<u>）如果某个类手动提供了任何构造器，那么隐式提供的默认无参构造器就不再提供了，即不能再`new ()`方式</u>**

**重要推论**

> a. 在Java中，<u>**任何类**都有构造器</u>（现在学的普通类，以后的抽象类，内部类都是的！！**很罕见的确定**）
>
> b. 在需要无参构造器的场景中，需要手动添加。

3. （IDEA快捷键的使用）

   构造器的格式很固定，考虑快捷键"alt + insert"来自动生成构造器。把自动生成的构造器称为“标准构造器”。开发中也一般使用标准构造器。

4. （**最重要**）用构造器赋值的特点

目前有3种赋值方式(给成员变量赋值,只是讨论在创建对象过程中)：

> 默认初始化赋值vs显示赋值vs构造器赋值
>
> 在所有Java给成员变量赋值的手段中，构造器的赋值（构造器的代码）永远是最后执行的，如果该构造器是标准格式构造器，那么构造器的传参一定是对象中成员变量在new对象以后的最终结果。

成员变量的赋值遵循“掐头去尾”原则：

<u>“头”：默认初始化；“尾”：构造器赋值</u>

5. 用IDEA的Debug模式追踪new对象过程中，成员变量的赋值过程💫

> init方法栈帧进栈
>
> f 即field：字段 ，成员变量

扩展：JVM创建对象的过程中，执行构造器给成员变量赋值，也就是`JVM`调用`init`方法，是`JVM`创建对象的最后一步。在执行init方法之前，该对象的结构已经创建完成了，包括对象中的属性也都已经具有默认值了。

> new对象的创建过程:
>
>  step 1. 类加载检查
>
>  step 2.  分配内存
>
> step 3. 初始化零值
>
> step 4. 设置对象头
>
> step 5. 执行`init`方法

6. （代码规范，了解知道）

目前在一个类当中，可以定义三种结构：

A.成员变量

B.构造器

C.成员方法

在定义类时，也要按照上述的顺序从上到下定义

7. （代码规范主要是看源代码怎么写的，见多了就会了。）

定义构造器时，如无特别需求，不要在构造器中写过多的业务逻辑代码。尽量保证构造器是标准格式。如果确有需求，那么单独定义一个成员方法，比如`init`，然后在构造器中调用它。

### 第三，构造器中的`this`关键字

首先，构造器中的`this`有和成员方法中的`this`相同的一点，指向当前对象，可以用来调用成员方法，访问自身属性。

其次，构造器中的`this`有自身独特的使用方式：**在一个构造器当中调用自身构造器。**

在构造器中，有时需要再复用同类另一个构造器，也有时必须调用同类其他构造器完成需求。

此时就用到了关键字

（重点**）在一个类的构造器中，可以使用“`this`(实参列表)；”表示访问同类对应的构造器**

注意事项：

1. 只有构造器中的`this`才能这么用，其他地方不行

2. （**重点**）**构造器中的`this`在表示调用同类的其它构造器时，必<u>须处在构造器代码的第一行</u>！**

总结：

1. 从debug模式看，new对象过程中，`new`对象的构造器的方法栈帧进栈，先调用`new`对象的构造器

2. 如果该构造器的第一行有“`this(实参列表)`；”表示调用自身其他构造器，那么就去调用对应构造器，构造器方法栈帧进栈

3. 构造器方法栈帧进栈后，要先执行“显示赋值”，因为构造器代码最后执行

4. 显示赋值执行结束后，再执行构造器的赋值代码！依据JVM栈“先进后出”，依次执行构造器。

5. （重点）在一次`new`对象的过程中，构造器可能由于`this`执行多个，但显式赋值最多执行一次，而且在构造器之前执行

6. 在`new`对象的构造器都执行完毕，方法栈帧出栈后，整个~对象的过程就结束了，该对象就完全创建完毕了。

### 类加载，构造器，`new`创建对象过程的总结

*类加载的关键过程等有一个文档要常看*

1. `new`对象是类加载的时机，所以在`new`之前，先类加载该类型，然后才能创建对象

2. 某类型的类加载全局只有一次，但`new`对象可以`new`很多次，只有第一次`new`对象才会类加载。构造器是在`new`对象的过程中执行，构造器是`new`对象过程的最后一次，如果都执行构造器了，类加载必然进行！

3. （重点）因为一次`new`对象的过程中，只创建了一个对象，但构造器可能执行很多次，所以构造器和创建对象没有必然联系

# 面向过程 VS 面向对象

## 面向过程以方法调用为核心

## 面向对象，不是纯粹的按流程调方法，而是对象体现出它的行为

> 摘自《深入理解JVM》
>
> 在软件业发展的初期，程序编写都是以算法为核心，程序员会把数据和过程分别作为独立的部分来考虑，数据代表空间中的客体，程序代码则用于处理这些数据，这种思维方式直接站在计算机的角度去抽象问题和解决问题，被称为面向过程的编程思想。与此相对，面向对象的编程思想则站在现实世界的角度去抽象和解决问题，它把数据和行为都看作对象的一部分，这样可以让程序员能以符合现实世界的思维方式来编写和组织程序。
>
> 面向对象的编程思想极大地提升了现代软件开发地效率和软件可以达到地规模，但是现实世界与计算机世界之间不可避免地存在一些差异。例如，人们很难想象现实中的对象在一项工作进行期间，会被不停地**中断和切换**，对象的属性（数据）可能会在中断期间被**修改和变脏**，而这些事件在计算机世界中是再普遍不过的事情。有时候，**良好的设计原则**不得不向现实做出一些妥协，我们必须保证程序在计算机中正确无误地运行，然后再考虑如何将代码组织得更好，让程序运行得更快。

值传递，Java只有值传递，意味着Java方法得到的只是实参变量的拷贝。

方法可以改变对象的状态，但方法不可以改变其它方法当中传入的局部变量（包括基本数据类型变量，以及引用数据类型的引用）

显示赋值语句是按照代码书写的顺序从上到下执行的。

# `static`关键字

#### `static`引入

##### `static`的语法和原理

不是独属于某个对象，而是属于全体对象所共享的属性，属于类的变量，即静态成员变量。

三种变量类型：局部变量，成员变量，静态成员变量。

定义：被全体对象共享，属于类的变量，存储在一片能够被全体对象所共享的内存区域。

对于`hotspot`虚拟机 静态成员变量（对象）就存储在堆空间上。（《深入理解Java虚拟机》）

成员变量和成员方法，统称为成员，属于对象。静态成员变量和静态成员方法，统称为静态成员，属于类的，被全体对象共享。

静态成员变量 

静态成员方法

```java
[访问权限修饰符] static 返回值类型 方法名（形参列表）{
    //方法体
}
```

1. 静态成员变量禁止“对象名.”方式访问

2. 应该用“类名.”来访问

3. 静态成员变量和成员变量一样具有默认初始化

静态成员方法的调用和上述一样，也要用“类名.”

特殊的，当在同一个类当中，调用自身static静态成员方法，可以直接写“方法名”来调用，类名可以省略。

