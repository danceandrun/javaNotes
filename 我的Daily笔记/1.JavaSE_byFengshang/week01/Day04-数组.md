# 数组

最基本的容器是数组，最常用的容器是集合（collection）

（重点）通过学习数组，一方面搞清楚数组的基本操作，为集合打基础，另一方面探讨学习==引用数据类型==的特点，JVM 内存模型。

集合只能装引用数据类型，数组可以存储基本数据类型，也可以存储引用数据类型。

数组的优缺点：

优点：可以利用下标实现随机访问。根据数组的首地址和下标，通过寻址公式直接计算出对应的内存地址。

缺点：1.数组的存储空间必须连续；2.数组的每一个存储单元必须大小一样 （重点）3.最主要的缺点：数组在创建后，长度就不可变了，除非销毁它。

一些代码当中，偏移量：offset就是☞index

**局部变量必须要经过声明和初始化**

声明：declaration

因为数组是容器，装多个元素，*命名时考虑使用名词的复数！*

数据类型[] 变量名；

==作为局部变量，该数组仅声明是不可用的，还需要初始化。==

## 初始化的两种方式：

### 静态初始化

```java
//写几个元素，长度就是几。
//静态初始化一个长度为0的空int类型数组
int[] arr = new int[]{};
```

只告诉取值不告诉长度

```java
int[] arr = {1,2,3};
```

注意这里是静态初始化隐含new关键字，仍然是一个独立的新的对象。

### 动态初始化

只告诉长度不告诉取值

指的是由程序员显示的指出数组的长度，而不直接指出数组中的元素取值。

```Java
//动态初始化一个长度为3的byte类型数组
byte[] arr = new byte[3];
```

为什么动态初始化没有指出元素的赋值，但仍能够完成初始化？因为数组中的元素具有==默认值==。

int类型数组默认值是0；boolean默认值是false。

## `JVM`内存模型

### `JVM`运行时数据区域

简称`JVM`内存。Java开发者在《Java虚拟机规范》中指出，`JVM`内存共分为：`JVM`栈，堆，方法区，程序计数器，本地方法栈。

方法区（method area）的具体实现可能不同，也有叫 永久代 元空间 

所有虚拟机都符合该规范，其中`hotspot `虚拟机是Oracle开发的，也是常用的。

### `JVM`栈

以后如无特别说明，我们提到的栈都是指Java虚拟机栈。

==方法调用==
`JVM` 栈，描述的是Java普通方法执行时的耗费资源的内存模型。

普通方法vs本地方法(native method)

==栈帧(frame)==
进栈出栈的基础单元，称为“栈帧（frame）”。`JVM`栈中，进出栈的基本单元就是“方法栈帧”。
==基本数据类型的局部变量，直接存储在方法栈中。而方法栈帧是相互独立的，所以局部变量就仅在方法作用域内部生效==
==栈的先进后出特点，决定了Java方法的执行顺序。==
Java中局部变量的生命周期：
随着方法调用，方法栈进栈，局部变量开辟空间创建，生效了。而随着方法调用完毕，方法栈出栈销毁，局部变量也销毁了。
“局部变量和方法调用同生共死”

### 堆（heap）

堆是`JVM`内存中负责存放<u>对象和实例</u>的。

对象 Object

**面向对象的程序，程序的核心是堆。**栈几十KB，堆 几百MB

实例 Instance

`new`关键字表示在堆上开辟空间，创建一个==新的、独立的==对象。

也就是说，只要在代码中出现`new`关键字，一定会在堆上创建一个新的独立的对象。

## 什么是引用数据类型？

```Java
int[] arr = new int[3];
```

1. arr是数组的名字，是**对象名**，它是一个局部变量，需要在栈上开辟空间存储它。它是引用数据类型变量的一个组成部分，我们把它称之为<u>引用数据类型</u>的引用，简称**引用**。

2. `new`关键字表示创建对象，在堆上开辟空间创建一个长度为3的int类型数组对象。

3. “=”连接引用和对象这两个部分，表示“栈上的引用指向堆上的对象”**<u>。引用通过存储堆上对象的地址来对与对象产生联系。</u>**



==引用数据类型 = 引用 + 对象==（如果这个引用数据类型变量是一个局部变量，那么引用存储在方法的栈帧中）

Java8 中所有对象都在堆中，引用可以存在堆中的对象里或是方法栈中，在方法栈中时是局部变量，没有默认值，需要手动赋值初始化。

把引用存储在栈帧中是局部变量的特点，不是引用数据类型自身的特点。

**<u>只能通过引用间接操作对象。</u>**

"`==`"和`.equals`的区别：

<u>“`==”`比较的是两个引用是不是指向同一个对象。</u>

> 判断如下代码的输出结果

```Java
int[] arr = {1, 2, 3};
int[] arr2 = arr;
int[] arr3 = {1, 2, 3};
System.out.println(arr == arr2);
System.out.println(arr == arr3);
```

结果是：

> true
>
> false

第一个true：毕竟arr2就直接用arr赋值，它们指向同一个对象。

第二个false： 因为*数组的静态初始化隐含了`new`关键字*，而**只要存在`new`关键字，那么就一定会在堆上创建一个新的独立的对象！**arr和arr3指向的对象就不会是同一个对象。

### 区分基本数据类型和引用数据类型

引用数据类型无非是引用加对象，重点是弄清楚引用在什么地方。

### 堆和栈中内容的区别

三个角度：

**1.存储类型：**堆上存储的是`new`出来的东西，是引用数据类型的实质——对象；栈上存储的是局部变量

**2.默认值：**栈上存储的局部变量，局部变量没有默认值，必须手动初始化完成赋值以后这个局部变量才可用。堆上对象中存储的元素（属性），它有默认值，我们把对象中元素具有默认值的过程称为”默认初始化”，**<u>默认初始化由JVM在创建对象时完成。</u>**

如果对象中存储引用数据类型变量，那么默认初始值是`null`(空常量)。指向`null`表示引用没有指向任何对象，指向虚无。引用等于`null`时，没有对象可供操作，此时该引用是不可用的。

数组的静态初始化当中，虽然看起来已经给出元素的具体取值了 ，但默认初始化，具有默认值的过程仍要执行

**==在以后的学习中，会有很多种方式给对象中的元素（属性）赋值，但不管有多少种方式，永远是最先执行默认初始化，永远先具有默认值。==**

**3.生命周期：**

栈上局部变量的生命周期：和方法同生共死。

堆上对象的生命周期（了解）：

在Java中，某个对象一旦所有的引用都被销毁，那么就无法再次访问操作该对象，这种对象，就是“垃圾”(garbage). （面向对象语言中的“垃圾”概念都是如此。）

## 异常的简介

Java中万物皆对象，处理文件先搞一个文件对象，使用线程先搞一个线程对象。

JVM会把这个异常信息封装为一个对象，然后在默认情况下JVM就会终止程序执行，并在控制台打印这个异常信息。

1. 代码会在异常处终止，所以一次程序的运行最多产生一个异常
2. 异常和编译报错区分开

### 数组下标越界异常(Array IndexOutOfBoundException)

常出现在循环遍历时。

### 空指针异常（NullPointerException）

用来描述通过一个指向null的引用**访问、操作**对象时的问题。当引用数据类型的引用指向了`null`时，表示引用是没有指向任何对象，这时如果还想通过引用操作堆上对象，就会产生`NPE`。

常见的规避手段：通过`if`进行判断。 

> 不要讲数组为空，因为有歧义：应该说数组长度为0或数组是`null`

## 数组的操作

### 数组的遍历

1. 循环 `arr.length`

​	for循环遍历数组的快捷键，快速生成for循环遍历数组

​	数组名`.fori`

2. 写if的小技巧，注意事项：尽量把少的代码放到“{}”里面，这样减少代码层级，提高代码的可读性。

3. 标准写法

```Java
if (arr == null || arr.length == 0){
};
```

```
str == null || str.length == 0 
```

4. `java.util.Arrays`  数组工具类

​	仅仅希望打印查看数组中每个元素的取值，不希望手动写实现，而直接用源码中已存在的实现`Arrys.toString()`;

5. 增强for循环（也叫迭代器,`foreach`）

```Java
for（数据类型 变量名 ： 要遍历的数组或者集合）{
	System.out.println(变量名);
}
```

​	a. 增强for直接遍历元素，普通for遍历数组其实是遍历数组的下标。

​	b. 增强for快捷键：`iter` (`iterator`缩写)

​	c.  普通for语法稍微复杂，增强for更加简洁

```Java
for(int element : arr){
	System.out.println(element)
}
```

​	增强for用不了的场景:

​	a.  需要用下标的场景；

​	b.  需要修改元素的场景。迭代器就是为了遍历访问容器中的元素诞生的，只能读，不能写

​	**增强for循环是多线程**，实际上遍历的并不是容器中的元素本身，是元素的复本拷贝。

