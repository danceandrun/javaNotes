#### 方法的重载（overload）

###### 什么是方法重载？

###### 一句话：在同一个类中，允许多个方法拥有相同的方法名。

方法的语法

```java
[修饰符列表] 返回值类型 方法名 (形式参数列表){
	//方法体
}
```

###### 方法的声明

[修饰符列表] 返回值类型 方法名 (形式参数列表)

其中[修饰符列表]可以省略。

###### 方法头即是方法的声明

###### 方法签名

方法名（形式参数列表）

###### 方法签名唯一确定方法

条件：形参列表不同。



既然方法签名唯一确定一个方法，方法重载时要方法名相同，所以区分方法重载时的不同方法的条件是形参列表不同

形式参数列表要不同

1，形参数据类型

2，形参顺序

3，形参数量

1.重载和修饰符无关，修饰符是否相同不影响 

2.重载和返回值类型无关

3.形参的名字对重载没有影响。形参对外起作用的是数据类型，形参名字只对内起作用

###### 就近原则：当有多个选项都可以是适配时，优先选择最近的。

## 单元测试

Junit可以在同一个类中实现多个main方法的效果，避免重复创建Java文件。

###### 使用步骤：

1，找到一个类,最好不要叫Test

2，在类体的空白处写注解:"@Test"

3,alt+enter (版本有问题找老师)

4，测试方法的格式：

```java
public void 方法名(){
	//方法体
}
```

5，把需要执行的代码写在方法体中

6，启动测试方法

###### 注意：

1，不要再写main方法

2，测试方法格式固定：public void!!!

###### 扩展：

1，注解(annotation)是和class同等级别的数据类型，同样是引用数据类型。

"@Test"中"@"是实例化注解的语法，"Test"是注解的名字

依赖导入等知识在EE阶段

2，关于导包语句

Scanner的导包语句：import java.util.Scanner 这表示Scanner类是java.util包下的Scanner类

Junit单元测试使用注解Test的导包语句：import org.junit.Test: Test是org.junit包下的Test注解

###### 如果在一个Test类中使用Junit，使用注解Test，会出现什么情况？

就近原则，应该在注解Test的时候，不直接写"Test",而是带上包名，改成@org.junit.Tst

###### 两个重要概念

同包下不允许出现同名类，但不同包下可以

简单类名：比如Demo,Student等

==全限定类名(Fully qualified class name)：带上完整包名的类名。比如com.cskaoyan.Demo==

main方法中使用String是java.lang中的

##### 测试

白盒测试：熟悉原理，测试代码可用性，代码是否健壮。单元测试是白盒测试的一种常见方式。

黑盒测试：测试功能，由专业测试人员完成。

## Debug

###### 用debug模式看源码

编程难点在于把问题都发现，写了bug立刻可以找到。

###### 使用步骤：

1，打断点：debug模式是控制程序的执行的。会在该行执行时暂停。

2，以debug模式启动程序：程序会在断点处暂停，暂停的阴影行表示将要执行但还没有执行的代码

frame 帧

console 控制台

step over 下一步

step into 步入

进入到源码当中的方法：force step into

step out 跳出当前方法 会把方法执行完

drop frame 跳出方法不执行

阻塞方法必须满足条件才会跳过 

resume 恢复 跳过当前断点去到下一个断点(breakpoints)

3,智能步入:Run-->Smart step into

断点条件：在循环当中很常用，循环100次希望在第50次时停下来

