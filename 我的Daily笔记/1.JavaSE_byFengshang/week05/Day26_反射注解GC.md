###### 反射后面要自己多琢磨 注解 今天只是了解知道有什么作用，以后的框架学习会让代码更简洁。20个左右的注解作用要记住。面试分Java基础（学的时候理解清楚，练的时候练到位，面试前背一背），项目的业务逻辑（有什么场景？这个场景为什么要使用这个技术？）

# 反射

高级特性指的是专门的技术，专门性比较强。

字符串是不可变的原因之一是`private final`修饰

reflect

## 类加载

### 概念：

是JVM认识了解某个类的过程。

> 类加载的定义：**Java虚拟机把描述类的数据从.class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。**

### 类加载的过程：

![类加载的详细流程](https://hixiaodong123.oss-cn-hangzhou.aliyuncs.com/typora/202302032005119.png?align=center&padding=true)

**加载**主要完成两个事情：

1. 读取class文件到方法区（JVM内存中）；（该过程是一个IO过程）

2. 在堆上创建该类型的Class对象（Class对象封装了该类型的类型信息）

**连接**分三个步骤：验证、准备和解析

验证：检验读取到内存中的class文件数据的安全性、合法性

准备：为类的静态成员变量进行默认初始化赋值

解析：把符号引用转换成直接引用（《深入理解java虚拟机》）

**初始化**是程序员可控的，执行程序员书写的以下代码：

1.静态成员变量的显示赋值

2.静态代码块

这个过程也就是执行该类型的`<clinit>`方法的过程。这个方法是编译器自动封装在类加载过程中由JVM调用的一个方法，封装代码的顺序是，按照代码的书写顺序从上到下封装a和b的代码



### 类加载的时机

5个时机

1. 直接使用`java`命令来运行某个主类，也就是启动某个类的`main()`方法，会类加载该类型。
2. 创建类的对象。(首次)
3. 访问类的静态成员（首次）
4. 触发某个子类的类加载，会优先类加载父类。

5. 利用反射来强制获取类型的`Class`对象，会触发该类型的类加载⭐⭐



### 类加载器

加载的过程需要类加载器，`ClassLoader`是一个抽象父类

`Java`当中的类加载由三种组成：

1. `Bootstrap ClassLoader` 根类加载器
2. `Extension ClassLoader` 扩展类加载器
3. `System  ClassLoader`  系统类加载器

常用的类（Object, String, System）都是需要类加载的只不过使用的类加载器不同。java.lang.包下的类就是核心类。



 🏷️**Class对象是由类加载器在类加载的过程中完成创建**。

 java中符号`$`用来表示内部类



### 类加载器的层次结构：双亲委派模型

除了根类加载器（`Bootstrap ClassLoader`）外，Java当中的每一个类加载都有一个**“逻辑”**上的父类（不是Java语法上的继承关系）。

一共三种类加载器，每次都“上抛”和“下踢”

这样java程序每加载一个类型所有类加载器都会知道该类被加载了，所以确保了类只会加载一次。

>双亲委派机制：
>
>1. 当一个类加载器收到加载类的请求时，它首先不会自己尝试加载该类，而是将请求委托给其父类加载器。
>2. 父类加载器收到请求后，也会采用相同的方式，将请求继续委托给更上层的类加载器。
>3. 请求沿着类加载器的层次结构向上传递，直到达到根类加载器。然后根类加载器会尝试开始加载该类型；
>  4. 如果能够加载，它就加载该类
>  5. 如果无法加载，请求将沿着类加载器的层次结构向下传递，直到找到能够加载该类的类加载器。
>6. 如果所有的类加载器都无法加载该类，那么**最初请求**加载该类的类加载器会抛出`ClassNotFoundException`异常
>
>注：`ClassNotFoundException`是运行时异常

## 通过`ClassLoader`类型读文件

> 最重要的是搞懂路径

`ClassLoader`的相对路径

```Java
Sytem.getProperty("java.class.path");
```

idea中out是存放字节码文件的。读取文件的相对路径相对于：

当前project的out目录下的当前module的根目录

```java
InputStream in = ClassLoader.getSystemResourceAsStream(“1.txt”);
```

 ⭐在当前module下创建一个文件夹，标记成resources权限，这样此文件夹下的文件会自动放进out目录下的对应文件夹中

注意out目录下的文件在打包时会成为工程的一部分，当需要把一个文件作为工程的一部分打包时就可以采用这些方法。

> ⭐⭐⭐ 底层的字节输入流的方式
>
> 1. 文件字节输入流
>
> 2. Socket字节输入流
>
> 3. ClassLoader 在当前module下创建一个文件夹，标记成resources权限，这样此文件夹的文件就会被自动放进out目录下
>
> 当然具体使用时需要学会包装 🟡。

## 反射

首先，第一个问题：什么是反射？反射是一种什么样的技术？

通俗来说就是**获取类型的Class对象，然后在程序运行期间动态地对该类型执行一些操作**。

JAVA反射技术是在**运行状态中：**

1. 对于任意一个类，都能够知道这个类的所有属性和方法（包括私有），
2. 对于任意一个对象，都能够调用它的任意一个方法，访问任意一个属性。

这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。

**总之，反射是提供<u>获取运行时类信息</u>的一种技术，或者更通俗一点反射技术就是操作一个类的Class对象。**

自然，反射技术应用的起点就是获取某个类的Class对象。

### 如何获取Class对象呢？

方式一：依赖于Object类的`final`成员方法`getClass`

> 不常用；该方法常用于判断是否属于同一类

方式二：`数据类型名.class`

> Java的每一种数据类型都有一个隐含的静态属性包括基本数据类型。
>
> 不常用：该方法主要用于**给泛型传参**，**给方法调用传参**等。
>
> 比如某个方法的形参列表时(Class... vars);
>
> 此时调用方法可以传参(String.class, int.class)
>
> 注意事项：基本数据类型和它的包装类型的`.class`不是同一个对象，所以在此处方法传参时不能混用`int.class`和`Integer.class`

方式三：用全限定类名＋forName静态成员方法🟡 

```java
Class<?> forName(String className)
```

获取此全限定类名的类型的Class对象

全限定类名：右键reference

注意：

1. 同一类用三种方法的结果是一样的

2. **不论哪种方式获取Class对象，都不是它们创建的而是类加载器在类加载的加载阶段在堆上创建的**

3. 配合配置文件使用

## 配置文件（.properties文件）

`.properties`配置文件是源码中提供的

`.xml`

`.yml`

配置文件怎么写？

键值对

### 如何操作properties配置文件

1. 创建`java.util.Properties`类的对象，用无参构造器即可

2. 使用API操作这个Properties对象

```JAVA
// 从输入流中读取属性列表（键和元素对）。
void  load(InputStream inStream)        
// 按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）。
void  load(Reader reader)       
// 用指定的键在此属性列表中搜索属性。
String  getProperty(String key)        
```



```Java
public static void main(String[] args) throws IOException {
    // 创建Properties对象
    Properties properties = new Properties();
    // load加载这个配置文件,实际上就是IO流读这个文件
    properties.load(new FileInputStream("config.properties"));
    // getProperty获取属性值
    String host = properties.getProperty("ip");
    String username = properties.getProperty("port");
    String studentClazzName = properties.getProperty("StudentClassName");
    System.out.println(host);
    System.out.println(username);
    System.out.println(studentClazzName);
}
```



> 如果配置文件中有中文等非英文字符会咋样？
>
> `load`不要加载字节流而是要加载符合要求编码集的字符流

***

配置文件要放在资源目录下(`resources`)

## 反射API

1. `java.lang.reflect.Constructor`类用于描述构造器，且包含和构造器相关的一些操作。
2. `java.lang.reflect.Field`类用于描述成员变量，且包含和成员变量相关的一些操作。
3. `java.lang.reflect.Method`类用于描述成员方法，且包含和成员方法相关的一些操作。

这三个类都有一个共同的特点是：**都继承了类`java.lang.reflect.AccessibleObject`。**

这个类，作为一个父类，给`Constructor`、`Field`、`Method` 三个类提供了一个重要成员方法：

```Java
void setAccessible(boolean flag)
```

当该方法的参数设为`true`，表示反射在使用（调用方法）对象的过程<span style=color:red>可以突破Java语言的访问权限检查。</span>**就是该方法参数设置为`true`后， 即便访问权限是私有，也可以随意访问。**

### 方法名中`Declared` 和`S`的作用

Class类的API中，

`Declared`作用：

带Declared:*获取所有权限*
不带Declared:*获取public权限*

`s`的作.用：

带"s":*获取符合要求的所有*
不带"s:  *获取符合要求的一个*

构造器获取完毕之后可以创建对象

```Java
newInstance
```

私有权限是私有的所以不能直接用，需要先破解权限

```java
setAccessible(true)
```

## ORM框架

Spring是用来管理对象的，依赖注入，控制反转是常考的。

ORM对象关系映射

用于维护对象和数据库之间的关系

## 注解

类，接口，注解，枚举

`@Override`

annotation

注解是一种全新的引用数据类型。

注解可以理解成代码的一个特殊标签，这些标签也会传递一些代码外的额外信息。然后这些标记和额外信息可以在代码编译、类加载、运行时期被读取，并执行相应的处理。

> 注解与注释
>
> 相同点：两者都传递了额外的信息，但是区别很明显：
>
> 1. **注解可以参与编译，但注释显然不可能。**
> 2. **注解有确定的使用范围和使用方式，注释虽然也有语法，但基本想咋写就咋写。**
> 3. **注解是Java引用数据类型的一种，它和class、interface、enum具有同等地位**。



> 注解到底是个什么东西？
>
> 给一段代码加上一个注解到底有什么用？
>
> 注解本身相当于是一个**标签**，给代码加注释相当于给它贴上一个标签。标签本身是不会也不可能去执行一些操作的，是不会起任何作用的。标签附带**额外信息**以后，如何处理这个标签额外信息，不是标签自己能决定的。
>
> 总结作用：
>
> 1. 标签
> 2. 附带额外信息

在标签传递额外信息的过程中，由注解处理器来处理注解所带来的额外信息。

如果注解处理器处理了注解带来的额外信息，那么此注解会生效否则注解就是没什么用。

### 如何声明/定义一个注解？

框架里到处是注解要记

```Java
访问权限修饰符 @interface 注解名{
  // 注解体
  属性类型 属性名();
  属性类型 属性名();
  属性类型 属性名();
  .....
}
```

解释：

1. 注解的访问权限修饰符和class、interface等是一样的。
2. 注解名也遵循大驼峰的命名原则。
3. 注解中的属性能够定义的数据类型必须是：
   1. 基本数据类型
   2. java.lang.String
   3. java.lang.Class
   4. 枚举enum
   5. 注解
   6. 以及上述类型的数组



### 注解的使用⭐⭐⭐ 

以往我们使用一个类，往往需要创建它的对象。而注解的使用，也有相似的概念，也必须实例化一个注解。

注解进行实例化使用的方式和语法也很简单，参考如下形式：

```Java
@注解名(给注解各个属性赋值)
```

解释：

1. "`@`"可以认为相当于“`new`”关键字，必不可少。
2. 注解相当于给Java代码打上一个标签，所以它必须要修饰***Java代码的一个结构*,不能乱贴**。比如修饰一整个类，一整个方法，一个成员变量等等。
3.  ⭐ 实例化注解时，必须给注解的各个属性赋值，缺一不可，**赋值方式是：属性名 = 属性值**。如果是数组类型的注解属性，用"`{}`"赋值。如果有多个属性，赋值时用"，"隔开。



```java
@MyAnnotation(a = 1, b = "123", c = {"123"})
public class Test {
}

@interface MyAnnotation {
    int a();
    String b();
    String[] c();
}
```

#### 注意

1. **如果注解属性是一个引用数据类型，那么在给定默认值或者赋值时不能等于null，也不能new赋值，只能以给定常量的方式进行赋值。**

> 这意味着String只能用字面值常量字符串赋值；
>
> Class类型只能用“数据类型.class”赋值



2. 一个注解在不做任何额外设置的情况下,可以贴在任何Java代码结构的上面

*       如果想要限制注解实例化的位置,需要使用元注解Target
*       `Target`元注解，作用是定义注解可以修饰的目标
*       如果一个注解没有用该注解标明可修饰的目标，那么就表示该注解可以修饰任意结构，没有限制。



> 解释数据的数据叫元数据
>
> 解释注解的注解叫元注解
>
> >**@Target元注解，作用是定义注解可以修饰的目标，如果一个注解没有用该注解标明可修饰的目标，那么就表示该注解可以修饰任意结构，没有限制。**
>
> 该注解的常见取值如下：
>
> 1. 整个类    ElementType.TYPE
> 2. 成员变量   ElementType.FIELD
> 3. 构造方法   ElementType.CONSTRUCTOR
> 4. 成员方法   ElementType.METHOD



3. `default`关键字

> `default` 关键字的作用：
>
> 1. `switch` 中表示通配的作用
>
> 2. 接口的`default` 关键字修饰的Java8以后的默认实现方法
>
> 3. 定义注解的属性时，在定义的后面使用关键字`default` 给属性加上一个默认值



4. 当属性名字是 `value`时

**如果注解体当中的属性只有1个，并且它就叫`value` 的话，那么可以进行简化赋值。简化赋值可以直接给定取值，无需写"属性名 = "了。**



5. 特殊的，在注解体中存在value属性的基础上，还有多个其它属性。此时只要保证其它属性都有默认值，那么仍然可以采取简化手段给value赋值。



### 注解处理器

用反射来实现注解处理器

先通过反射获取注解信息，然后针对注解类型，获取注解当中定义的属性，从而执行一些操作，这样就用反射实现了一个注解处理器。

具体步骤是：

* 1.获取被注解修饰的类型的Class对象
* 2.获取被注解修饰的此Class对象当中的某个结构的对象
  * 如果注解修饰类,那么就直接用Class对象
  * 如果注解修饰成员变量,那么就先用Class对象获取此成员变量的Field对象
  * ....
* 3.再通过此结构的对象,获取修饰此结构的注解类型对象
* 4.通过注解类型对象,获取注解带来的额外信息(也就是注解的属性)
* 5.根据注解当中的属性,进行处理操作



> 限制创建对象的个数;
>
> 如果不私有化构造器，外部可以随意创建。因为构造器的作用是赋值。
>
> 所以应该私有化之后创建一个新的成员方法。

工厂的设计模式：

某个类的对象不再依赖于自身创建对象（比如new）,而是找一个工厂（类型）来生产它的对象

工厂的设计模式比较常见的实现手段就是反射



重点⭐⭐⭐

`Retention`元注解

用来解释自定义注解生效的范围

>**`@Retention`元注解，作用是定义注解的保留级别，也就是注解的存活范围。分为以下三个级别：**
>
>1. `RetentionPolicy.RUNTIME`：表示该注解会由JVM保留，因此运行时环境可以使用它，这样的一个注解才有可能影响代码执行。
>2. `RetentionPolicy.CLASS`：表示该注解在编译时由编译器保留，会进入class文件，但在类加载时期会被JVM忽略，不会进入虚拟机，不影响代码执行。**一个注解如果没有显式用元注解`@Retention`声明保留级别，那么它默认的保留级别就是`RetentionPolicy.CLASS`。**
>3. `RetentionPolicy.SOURCE`：表示该注解仅保留在.java源文件级别中，会被编译器忽略掉。（类似于注释）

所以如果希望一个注解影响源代码的执行，应该用`RUNTIME`修饰

```Java
@Retention(RetentionPolicy.RUNTIME)
```



### 注解的使用场景

注解的使用是贯穿Java学习的，比如：

SE:` @Test` `@Override` ` @Deperated`

EE : `@WebServlet`

框架: `@AutoWired`  `@Service` `@RequestMapping`  `@Data`

## GC

JVM运行时数据区域（一张图）

1. **程序计数器**（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。**(每个线程都有自己的程序计数器，线程隔离)**
2. **Java虚拟机栈**（Java Virtual Machine Stacks）Java进程中的每一个线程都有一个私有的JVM栈，它与线程同时创建。这个栈会存储"栈帧"，每个方法的执行都会创建一个新的栈帧，栈帧用于存储局部变量表、操作数栈、动态链接和方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
3. **本地方法栈**（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的native方法服务。方法栈都是线程私有的。
4. **Java堆**（Java Heap）一个Java进程中的所有线程都共享的一块内存区域，在虚拟机启动时创建。这个内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都会在这里分配内存。Java堆是垃圾收集器(GC)管理的主要区域，因此很多时候也被称做“GC堆”。
5. **方法区**（Method Area）方法区也是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量，以及即时编译器编译后的代码等数据。**方法区只是一个逻辑概念，具体的实现还需要看不同的虚拟机版本。**Java7是永久代（PermGen）Java8及其以后是元空间（Metaspace）



### 内存管理

内存溢出 VS 内存泄漏

>内存溢出（OutOfMemoryError）和内存泄漏（Memory Leak）是两种常见的内存问题，它们都可能导致应用程序的性能下降，甚至崩溃。然而，它们出现原因和解决方法是不同的。
>
>**内存溢出**：内存溢出是指程序在申请内存时，没有足够的内存空间供其使用，就会抛出OutOfMemoryError。在Java中，这通常是因为堆内存（Heap）、方法区（Method Area）或者栈（Stack）的大小不足。例如，当你试图创建一个大数组，但可用的堆内存不足以容纳它，就会发生内存溢出。
>
>解决内存溢出的方法通常是增加内存限制（例如，通过JVM启动参数-Xmx设置更大的堆内存），或者优化程序，使其使用更少的内存。
>
>**内存泄漏**：内存泄漏是指程序在使用内存后，未能正确释放已经不再使用的内存。在垃圾收集语言（如Java）中，内存泄漏通常是因为持有程序不再需要的对象的引用，使得垃圾收集器无法回收这些对象。这样，随着时间的推移，这些未被回收的对象会逐渐占用越来越多的内存，可能最终导致内存溢出。
>
>所以，内存溢出是由于可用的内存空间不足，而内存泄漏是由于程序未能正确管理内存，导致不再使用的内存无法被回收。**内存溢出可能和内存泄漏没啥关系，而内存泄漏过多则有可能导致内存溢出。**

### 如何确定垃圾

#### 引用计数算法

这种方法有缺陷，如果堆上有两个对象一直互相指向彼此

#### 根搜索算法

根节点对象

从这些节点开始向下搜索，搜索所走的路径称为引用链。当一个对象到所有的GC root之间没有任何引用链相连时，就认为该对象变成了垃圾。

### 如何回收垃圾

#### 标记清楚算法（Mark Sweep）

简单直接但该算法不可用。清除得到的空间是不连续的。基于该算法有以下两种。

#### 标记复制算法(Mark Copy)

将内存划成两块

适合大多数都被销毁

#### 标记整理算法(Mark Compact)

compact 压缩

所有存活的对象都推到前面

适合大多数对象都要活着



所以要再进行分区，新生代和老年代

新生代的对象基本都要被回收（Eden S0 S1）
